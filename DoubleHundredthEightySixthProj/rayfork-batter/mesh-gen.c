#include "rayfork/gfx/gfx.h"
#include "rayfork/model/mesh-gen.h"
#include "par_shapes/par_shapes.h"

rf_extern rf_mesh rf_gen_mesh_cube(float width, float height, float length, rf_allocator allocator, rf_allocator temp_allocator)
{
    rf_mesh mesh = {0};
    mesh.vbo_id = (unsigned int*) rf_alloc(allocator, RF_MAX_MESH_VBO * sizeof(unsigned int));
    memset(mesh.vbo_id, 0, RF_MAX_MESH_VBO * sizeof(unsigned int));

    #define rf_custom_mesh_gen_cube //Todo: Investigate this macro
    /*
    Platonic solids:
    par_shapes_mesh* par_shapes_create_tetrahedron();       // 4 sides polyhedron (pyramid)
    par_shapes_mesh* par_shapes_create_cube();              // 6 sides polyhedron (cube)
    par_shapes_mesh* par_shapes_create_octahedron();        // 8 sides polyhedron (dyamond)
    par_shapes_mesh* par_shapes_create_dodecahedron();      // 12 sides polyhedron
    par_shapes_mesh* par_shapes_create_icosahedron();       // 20 sides polyhedron
    */

    // Platonic solid generation: cube (6 sides)
    // NOTE: No normals/texcoords generated by default
    rf_global_allocator_for_thirdparty_libraries = temp_allocator;
    {
        par_shapes_mesh* cube = par_shapes_create_cube();
        cube->tcoords = rf_alloc(temp_allocator, sizeof(float) * 2 * cube->npoints);

        for (rf_int i = 0; i < 2 * cube->npoints; i++)
        {
            cube->tcoords[i] = 0.0f;
        }

        par_shapes_scale(cube, width, height, length);
        par_shapes_translate(cube, -width / 2, 0.0f, -length / 2);
        par_shapes_compute_normals(cube);

        mesh.vertices = (float*) rf_alloc(allocator, cube->ntriangles * 3 * 3 * sizeof(float));
        mesh.texcoords = (float*) rf_alloc(allocator, cube->ntriangles * 3 * 2 * sizeof(float));
        mesh.normals = (float*) rf_alloc(allocator, cube->ntriangles * 3 * 3 * sizeof(float));

        mesh.vertex_count = cube->ntriangles * 3;
        mesh.triangle_count = cube->ntriangles;

        for (rf_int k = 0; k < mesh.vertex_count; k++)
        {
            mesh.vertices[k * 3] = cube->points[cube->triangles[k] * 3];
            mesh.vertices[k * 3 + 1] = cube->points[cube->triangles[k] * 3 + 1];
            mesh.vertices[k * 3 + 2] = cube->points[cube->triangles[k] * 3 + 2];

            mesh.normals[k * 3] = cube->normals[cube->triangles[k] * 3];
            mesh.normals[k * 3 + 1] = cube->normals[cube->triangles[k] * 3 + 1];
            mesh.normals[k * 3 + 2] = cube->normals[cube->triangles[k] * 3 + 2];

            mesh.texcoords[k * 2] = cube->tcoords[cube->triangles[k] * 2];
            mesh.texcoords[k * 2 + 1] = cube->tcoords[cube->triangles[k] * 2 + 1];
        }

        par_shapes_free_mesh(cube);
    }
    //RF_SET_PARSHAPES_ALLOCATOR((rf_allocator) {0});

    // Upload vertex data to GPU (static mesh)
    rf_gfx_load_mesh(&mesh, false);

    return mesh;
}

// Generate polygonal mesh
rf_extern rf_mesh rf_gen_mesh_poly(int sides, float radius, rf_allocator allocator, rf_allocator temp_allocator)
{
    rf_mesh mesh = {0};
    mesh.vbo_id = (unsigned int*) rf_alloc(allocator, RF_MAX_MESH_VBO * sizeof(unsigned int));
    memset(mesh.vbo_id, 0, RF_MAX_MESH_VBO * sizeof(unsigned int));
    int vertex_count = sides * 3;

    // Vertices definition
    rf_vec3* vertices = (rf_vec3*) rf_alloc(temp_allocator, vertex_count * sizeof(rf_vec3));
    for (rf_int i = 0, v = 0; i < 360; i += 360/sides, v += 3)
    {
        vertices[v    ] = (rf_vec3){ 0.0f, 0.0f, 0.0f };
        vertices[v + 1] = (rf_vec3) {sinf(rf_deg2rad * i) * radius, 0.0f, cosf(rf_deg2rad * i) * radius };
        vertices[v + 2] = (rf_vec3) {sinf(rf_deg2rad * (i + 360 / sides)) * radius, 0.0f, cosf(rf_deg2rad * (i + 360 / sides)) * radius };
    }

    // Normals definition
    rf_vec3* normals = (rf_vec3*) rf_alloc(temp_allocator, vertex_count * sizeof(rf_vec3));
    for (rf_int n = 0; n < vertex_count; n++) normals[n] = (rf_vec3){0.0f, 1.0f, 0.0f }; // rf_vec3.up;

    // TexCoords definition
    rf_vec2* texcoords = (rf_vec2*) rf_alloc(temp_allocator, vertex_count * sizeof(rf_vec2));
    for (rf_int n = 0; n < vertex_count; n++) texcoords[n] = (rf_vec2) {0.0f, 0.0f };

    mesh.vertex_count = vertex_count;
    mesh.triangle_count = sides;
    mesh.vertices  = (float*) rf_alloc(allocator, mesh.vertex_count * 3 * sizeof(float));
    mesh.texcoords = (float*) rf_alloc(allocator, mesh.vertex_count * 2 * sizeof(float));
    mesh.normals   = (float*) rf_alloc(allocator, mesh.vertex_count * 3 * sizeof(float));

    // rf_mesh vertices position array
    for (rf_int i = 0; i < mesh.vertex_count; i++)
    {
        mesh.vertices[3*i] = vertices[i].x;
        mesh.vertices[3*i + 1] = vertices[i].y;
        mesh.vertices[3*i + 2] = vertices[i].z;
    }

    // rf_mesh texcoords array
    for (rf_int i = 0; i < mesh.vertex_count; i++)
    {
        mesh.texcoords[2*i] = texcoords[i].x;
        mesh.texcoords[2*i + 1] = texcoords[i].y;
    }

    // rf_mesh normals array
    for (rf_int i = 0; i < mesh.vertex_count; i++)
    {
        mesh.normals[3*i] = normals[i].x;
        mesh.normals[3*i + 1] = normals[i].y;
        mesh.normals[3*i + 2] = normals[i].z;
    }

    rf_free(temp_allocator, vertices);
    rf_free(temp_allocator, normals);
    rf_free(temp_allocator, texcoords);

    // Upload vertex data to GPU (static mesh)
    rf_gfx_load_mesh(&mesh, false);

    return mesh;
}

// Generate plane mesh (with subdivisions)
rf_extern rf_mesh rf_gen_mesh_plane(float width, float length, int res_x, int res_z, rf_allocator allocator, rf_allocator temp_allocator)
{
    rf_mesh mesh = {0};
    mesh.vbo_id = (unsigned int*) rf_alloc(allocator, RF_MAX_MESH_VBO * sizeof(unsigned int));
    memset(mesh.vbo_id, 0, RF_MAX_MESH_VBO * sizeof(unsigned int));

    #define rf_custom_mesh_gen_plane //Todo: Investigate this macro

    rf_global_allocator_for_thirdparty_libraries = temp_allocator;
    {
        par_shapes_mesh* plane = par_shapes_create_plane(res_x, res_z); // No normals/texcoords generated!!!
        par_shapes_scale(plane, width, length, 1.0f);

        float axis[] = { 1, 0, 0 };
        par_shapes_rotate(plane, -rf_pi / 2.0f, axis);
        par_shapes_translate(plane, -width / 2, 0.0f, length / 2);

        mesh.vertices   = (float*) rf_alloc(allocator, plane->ntriangles * 3 * 3 * sizeof(float));
        mesh.texcoords  = (float*) rf_alloc(allocator, plane->ntriangles * 3 * 2 * sizeof(float));
        mesh.normals    = (float*) rf_alloc(allocator, plane->ntriangles * 3 * 3 * sizeof(float));
        mesh.vbo_id     = (unsigned int*) rf_alloc(allocator, RF_MAX_MESH_VBO * sizeof(unsigned int));
        memset(mesh.vbo_id, 0, RF_MAX_MESH_VBO * sizeof(unsigned int));

        mesh.vertex_count   = plane->ntriangles * 3;
        mesh.triangle_count = plane->ntriangles;

        for (rf_int k = 0; k < mesh.vertex_count; k++)
        {
            mesh.vertices[k * 3    ] = plane->points[plane->triangles[k] * 3    ];
            mesh.vertices[k * 3 + 1] = plane->points[plane->triangles[k] * 3 + 1];
            mesh.vertices[k * 3 + 2] = plane->points[plane->triangles[k] * 3 + 2];

            mesh.normals[k * 3    ] = plane->normals[plane->triangles[k] * 3    ];
            mesh.normals[k * 3 + 1] = plane->normals[plane->triangles[k] * 3 + 1];
            mesh.normals[k * 3 + 2] = plane->normals[plane->triangles[k] * 3 + 2];

            mesh.texcoords[k * 2    ] = plane->tcoords[plane->triangles[k] * 2    ];
            mesh.texcoords[k * 2 + 1] = plane->tcoords[plane->triangles[k] * 2 + 1];
        }

        par_shapes_free_mesh(plane);
    }
    rf_global_allocator_for_thirdparty_libraries = (rf_allocator) {0};

    // Upload vertex data to GPU (static mesh)
    rf_gfx_load_mesh(&mesh, false);

    return mesh;
}

// Generate sphere mesh (standard sphere)
rf_extern rf_mesh rf_gen_mesh_sphere(float radius, int rings, int slices, rf_allocator allocator, rf_allocator temp_allocator)
{
    rf_mesh mesh = {0};
    mesh.vbo_id = (unsigned int*) rf_alloc(allocator, RF_MAX_MESH_VBO * sizeof(unsigned int));
    memset(mesh.vbo_id, 0, RF_MAX_MESH_VBO * sizeof(unsigned int));

    rf_global_allocator_for_thirdparty_libraries = (temp_allocator);
    {
        par_shapes_mesh* sphere = par_shapes_create_parametric_sphere(slices, rings);
        par_shapes_scale(sphere, radius, radius, radius);
        // NOTE: Soft normals are computed internally

        mesh.vertices  = (float*) rf_alloc(allocator, sphere->ntriangles * 3 * 3 * sizeof(float));
        mesh.texcoords = (float*) rf_alloc(allocator, sphere->ntriangles * 3 * 2 * sizeof(float));
        mesh.normals   = (float*) rf_alloc(allocator, sphere->ntriangles * 3 * 3 * sizeof(float));

        mesh.vertex_count = sphere->ntriangles * 3;
        mesh.triangle_count = sphere->ntriangles;

        for (rf_int k = 0; k < mesh.vertex_count; k++)
        {
            mesh.vertices[k * 3    ] = sphere->points[sphere->triangles[k] * 3];
            mesh.vertices[k * 3 + 1] = sphere->points[sphere->triangles[k] * 3 + 1];
            mesh.vertices[k * 3 + 2] = sphere->points[sphere->triangles[k] * 3 + 2];

            mesh.normals[k * 3    ] = sphere->normals[sphere->triangles[k] * 3];
            mesh.normals[k * 3 + 1] = sphere->normals[sphere->triangles[k] * 3 + 1];
            mesh.normals[k * 3 + 2] = sphere->normals[sphere->triangles[k] * 3 + 2];

            mesh.texcoords[k * 2    ] = sphere->tcoords[sphere->triangles[k] * 2];
            mesh.texcoords[k * 2 + 1] = sphere->tcoords[sphere->triangles[k] * 2 + 1];
        }

        par_shapes_free_mesh(sphere);
    }
    rf_global_allocator_for_thirdparty_libraries = ((rf_allocator) {0});

    // Upload vertex data to GPU (static mesh)
    rf_gfx_load_mesh(&mesh, false);

    return mesh;
}

// Generate hemi-sphere mesh (half sphere, no bottom cap)
rf_extern rf_mesh rf_gen_mesh_hemi_sphere(float radius, int rings, int slices, rf_allocator allocator, rf_allocator temp_allocator)
{
    rf_mesh mesh = {0};
    mesh.vbo_id = (unsigned int*) rf_alloc(allocator, RF_MAX_MESH_VBO * sizeof(unsigned int));
    memset(mesh.vbo_id, 0, RF_MAX_MESH_VBO * sizeof(unsigned int));

    rf_global_allocator_for_thirdparty_libraries = (temp_allocator);
    {
        par_shapes_mesh* sphere = par_shapes_create_hemisphere(slices, rings);
        par_shapes_scale(sphere, radius, radius, radius);
        // NOTE: Soft normals are computed internally

        mesh.vertices  = (float*) rf_alloc(allocator, sphere->ntriangles * 3 * 3 * sizeof(float));
        mesh.texcoords = (float*) rf_alloc(allocator, sphere->ntriangles * 3 * 2 * sizeof(float));
        mesh.normals   = (float*) rf_alloc(allocator, sphere->ntriangles * 3 * 3 * sizeof(float));

        mesh.vertex_count   = sphere->ntriangles * 3;
        mesh.triangle_count = sphere->ntriangles;

        for (rf_int k = 0; k < mesh.vertex_count; k++)
        {
            mesh.vertices[k * 3    ] = sphere->points[sphere->triangles[k] * 3];
            mesh.vertices[k * 3 + 1] = sphere->points[sphere->triangles[k] * 3 + 1];
            mesh.vertices[k * 3 + 2] = sphere->points[sphere->triangles[k] * 3 + 2];

            mesh.normals[k * 3    ] = sphere->normals[sphere->triangles[k] * 3];
            mesh.normals[k * 3 + 1] = sphere->normals[sphere->triangles[k] * 3 + 1];
            mesh.normals[k * 3 + 2] = sphere->normals[sphere->triangles[k] * 3 + 2];

            mesh.texcoords[k * 2    ] = sphere->tcoords[sphere->triangles[k] * 2];
            mesh.texcoords[k * 2 + 1] = sphere->tcoords[sphere->triangles[k] * 2 + 1];
        }

        par_shapes_free_mesh(sphere);
    }
    rf_global_allocator_for_thirdparty_libraries = ((rf_allocator) {0});

    // Upload vertex data to GPU (static mesh)
    rf_gfx_load_mesh(&mesh, false);

    return mesh;
}

// Generate cylinder mesh
rf_extern rf_mesh rf_gen_mesh_cylinder(float radius, float height, int slices, rf_allocator allocator, rf_allocator temp_allocator)
{
    rf_mesh mesh = {0};
    mesh.vbo_id = (unsigned int*) rf_alloc(allocator, RF_MAX_MESH_VBO * sizeof(unsigned int));
    memset(mesh.vbo_id, 0, RF_MAX_MESH_VBO * sizeof(unsigned int));

    rf_global_allocator_for_thirdparty_libraries = (temp_allocator);
    {
        // Instance a cylinder that sits on the Z=0 plane using the given tessellation
        // levels across the UV domain.  Think of "slices" like a number of pizza
        // slices, and "stacks" like a number of stacked rings.
        // Height and radius are both 1.0, but they can easily be changed with par_shapes_scale
        par_shapes_mesh* cylinder = par_shapes_create_cylinder(slices, 8);
        par_shapes_scale(cylinder, radius, radius, height);
        float axis[] = { 1, 0, 0 };
        par_shapes_rotate(cylinder, -rf_pi / 2.0f, axis);

        // Generate an orientable disk shape (top cap)
        float center[] = { 0, 0, 0 };
        float normal[] = { 0, 0, 1 };
        float normal_minus_1[] = { 0, 0, -1 };
        par_shapes_mesh* cap_top = par_shapes_create_disk(radius, slices, center, normal);
        cap_top->tcoords = rf_alloc(temp_allocator, sizeof(float) * 2 * cap_top->npoints);
        for (rf_int i = 0; i < 2 * cap_top->npoints; i++)
        {
            cap_top->tcoords[i] = 0.0f;
        }

        par_shapes_rotate(cap_top, -rf_pi / 2.0f, axis);
        par_shapes_translate(cap_top, 0, height, 0);

        // Generate an orientable disk shape (bottom cap)
        par_shapes_mesh* cap_bottom = par_shapes_create_disk(radius, slices, center, normal_minus_1);
        cap_bottom->tcoords = rf_alloc(temp_allocator, sizeof(float) * 2 * cap_bottom->npoints);
        for (rf_int i = 0; i < 2*cap_bottom->npoints; i++) cap_bottom->tcoords[i] = 0.95f;
        par_shapes_rotate(cap_bottom, rf_pi / 2.0f, axis);

        par_shapes_merge_and_free(cylinder, cap_top);
        par_shapes_merge_and_free(cylinder, cap_bottom);

        mesh.vertices  = (float*) rf_alloc(allocator, cylinder->ntriangles * 3 * 3 * sizeof(float));
        mesh.texcoords = (float*) rf_alloc(allocator, cylinder->ntriangles * 3 * 2 * sizeof(float));
        mesh.normals   = (float*) rf_alloc(allocator, cylinder->ntriangles * 3 * 3 * sizeof(float));

        mesh.vertex_count   = cylinder->ntriangles * 3;
        mesh.triangle_count = cylinder->ntriangles;

        for (rf_int k = 0; k < mesh.vertex_count; k++)
        {
            mesh.vertices[k * 3    ] = cylinder->points[cylinder->triangles[k] * 3    ];
            mesh.vertices[k * 3 + 1] = cylinder->points[cylinder->triangles[k] * 3 + 1];
            mesh.vertices[k * 3 + 2] = cylinder->points[cylinder->triangles[k] * 3 + 2];

            mesh.normals[k * 3    ] = cylinder->normals[cylinder->triangles[k] * 3    ];
            mesh.normals[k * 3 + 1] = cylinder->normals[cylinder->triangles[k] * 3 + 1];
            mesh.normals[k * 3 + 2] = cylinder->normals[cylinder->triangles[k] * 3 + 2];

            mesh.texcoords[k * 2    ] = cylinder->tcoords[cylinder->triangles[k] * 2    ];
            mesh.texcoords[k * 2 + 1] = cylinder->tcoords[cylinder->triangles[k] * 2 + 1];
        }

        par_shapes_free_mesh(cylinder);
    }
    rf_global_allocator_for_thirdparty_libraries = ((rf_allocator) {0});

    // Upload vertex data to GPU (static mesh)
    rf_gfx_load_mesh(&mesh, false);

    return mesh;
}

// Generate torus mesh
rf_extern rf_mesh rf_gen_mesh_torus(float radius, float size, int rad_seg, int sides, rf_allocator allocator, rf_allocator temp_allocator)
{
    rf_mesh mesh = {0};
    mesh.vbo_id = (unsigned int*) rf_alloc(allocator, RF_MAX_MESH_VBO * sizeof(unsigned int));
    memset(mesh.vbo_id, 0, RF_MAX_MESH_VBO * sizeof(unsigned int));

    if (radius > 1.0f)      radius = 1.0f;
    else if (radius < 0.1f) radius = 0.1f;

    rf_global_allocator_for_thirdparty_libraries = (temp_allocator);
    {
        // Create a donut that sits on the Z=0 plane with the specified inner radius
        // The outer radius can be controlled with par_shapes_scale
        par_shapes_mesh* torus = par_shapes_create_torus(rad_seg, sides, radius);
        par_shapes_scale(torus, size/2, size/2, size/2);

        mesh.vertices  = (float*) rf_alloc(allocator, torus->ntriangles * 3 * 3 * sizeof(float));
        mesh.texcoords = (float*) rf_alloc(allocator, torus->ntriangles * 3 * 2 * sizeof(float));
        mesh.normals   = (float*) rf_alloc(allocator, torus->ntriangles * 3 * 3 * sizeof(float));

        mesh.vertex_count   = torus->ntriangles * 3;
        mesh.triangle_count = torus->ntriangles;

        for (rf_int k = 0; k < mesh.vertex_count; k++)
        {
            mesh.vertices[k * 3    ] = torus->points[torus->triangles[k] * 3    ];
            mesh.vertices[k * 3 + 1] = torus->points[torus->triangles[k] * 3 + 1];
            mesh.vertices[k * 3 + 2] = torus->points[torus->triangles[k] * 3 + 2];

            mesh.normals[k * 3    ] = torus->normals[torus->triangles[k] * 3    ];
            mesh.normals[k * 3 + 1] = torus->normals[torus->triangles[k] * 3 + 1];
            mesh.normals[k * 3 + 2] = torus->normals[torus->triangles[k] * 3 + 2];

            mesh.texcoords[k * 2    ] = torus->tcoords[torus->triangles[k] * 2    ];
            mesh.texcoords[k * 2 + 1] = torus->tcoords[torus->triangles[k] * 2 + 1];
        }

        par_shapes_free_mesh(torus);
    }
    rf_global_allocator_for_thirdparty_libraries = ((rf_allocator) {0});

    // Upload vertex data to GPU (static mesh)
    rf_gfx_load_mesh(&mesh, false);

    return mesh;
}

// Generate trefoil knot mesh
rf_extern rf_mesh rf_gen_mesh_knot(float radius, float size, int rad_seg, int sides, rf_allocator allocator, rf_allocator temp_allocator)
{
    rf_mesh mesh = {0};
    mesh.vbo_id = (unsigned int*) rf_alloc(allocator, RF_MAX_MESH_VBO * sizeof(unsigned int));
    memset(mesh.vbo_id, 0, RF_MAX_MESH_VBO * sizeof(unsigned int));

    if (radius > 3.0f)      radius = 3.0f;
    else if (radius < 0.5f) radius = 0.5f;

    rf_global_allocator_for_thirdparty_libraries = (temp_allocator);
    {
        par_shapes_mesh* knot = par_shapes_create_trefoil_knot(rad_seg, sides, radius);
        par_shapes_scale(knot, size, size, size);

        mesh.vertices  = (float*) rf_alloc(allocator, knot->ntriangles * 3 * 3 * sizeof(float));
        mesh.texcoords = (float*) rf_alloc(allocator, knot->ntriangles * 3 * 2 * sizeof(float));
        mesh.normals   = (float*) rf_alloc(allocator, knot->ntriangles * 3 * 3 * sizeof(float));

        mesh.vertex_count   = knot->ntriangles * 3;
        mesh.triangle_count = knot->ntriangles;

        for (rf_int k = 0; k < mesh.vertex_count; k++)
        {
            mesh.vertices[k * 3    ] = knot->points[knot->triangles[k] * 3    ];
            mesh.vertices[k * 3 + 1] = knot->points[knot->triangles[k] * 3 + 1];
            mesh.vertices[k * 3 + 2] = knot->points[knot->triangles[k] * 3 + 2];

            mesh.normals[k * 3    ] = knot->normals[knot->triangles[k] * 3    ];
            mesh.normals[k * 3 + 1] = knot->normals[knot->triangles[k] * 3 + 1];
            mesh.normals[k * 3 + 2] = knot->normals[knot->triangles[k] * 3 + 2];

            mesh.texcoords[k * 2    ] = knot->tcoords[knot->triangles[k] * 2    ];
            mesh.texcoords[k * 2 + 1] = knot->tcoords[knot->triangles[k] * 2 + 1];
        }

        par_shapes_free_mesh(knot);
    }
    rf_global_allocator_for_thirdparty_libraries = ((rf_allocator) {0});

    // Upload vertex data to GPU (static mesh)
    rf_gfx_load_mesh(&mesh, false);

    return mesh;
}

// Generate a mesh from heightmap
// NOTE: Vertex data is uploaded to GPU
rf_extern rf_mesh rf_gen_mesh_heightmap(rf_image heightmap, rf_vec3 size, rf_allocator allocator, rf_allocator temp_allocator)
{
    #define rf_gray_value(c) ((c.r+c.g+c.b)/3)

    rf_mesh mesh = {0};
    mesh.vbo_id = (unsigned int*) rf_alloc(allocator, RF_MAX_MESH_VBO * sizeof(unsigned int));
    memset(mesh.vbo_id, 0, RF_MAX_MESH_VBO * sizeof(unsigned int));

    int map_x = heightmap.width;
    int map_z = heightmap.height;

    rf_pixel_buffer pixels_buf = rf_format_pixels_to_rgba32(rf_image_to_pixel_buffer(heightmap), temp_allocator);
    if (pixels_buf.valid)
    {
        rf_color* pixels = pixels_buf.data;

        // NOTE: One vertex per pixel
        mesh.triangle_count = (map_x - 1) * (map_z - 1) * 2; // One quad every four pixels

        mesh.vertex_count = mesh.triangle_count * 3;

        mesh.vertices  = (float*) rf_alloc(allocator, mesh.vertex_count * 3 * sizeof(float));
        mesh.normals   = (float*) rf_alloc(allocator, mesh.vertex_count * 3 * sizeof(float));
        mesh.texcoords = (float*) rf_alloc(allocator, mesh.vertex_count * 2 * sizeof(float));
        mesh.colors    = NULL;

        int vertex_pos_counter      = 0; // Used to count vertices float by float
        int vertex_texcoord_counter = 0; // Used to count texcoords float by float
        int n_counter               = 0; // Used to count normals float by float
        int tris_counter            = 0;

        rf_vec3 scale_factor = { size.x / map_x, size.y / 255.0f, size.z / map_z };

        for (rf_int z = 0; z < map_z-1; z++)
        {
            for (rf_int x = 0; x < map_x-1; x++)
            {
                // Fill vertices array with data
                //----------------------------------------------------------

                // one triangle - 3 vertex
                mesh.vertices[vertex_pos_counter    ] = (float) x * scale_factor.x;
                mesh.vertices[vertex_pos_counter + 1] = (float) rf_gray_value(pixels[x + z * map_x]) * scale_factor.y;
                mesh.vertices[vertex_pos_counter + 2] = (float) z * scale_factor.z;

                mesh.vertices[vertex_pos_counter + 3] = (float) x * scale_factor.x;
                mesh.vertices[vertex_pos_counter + 4] = (float) rf_gray_value(pixels[x + (z + 1) * map_x]) * scale_factor.y;
                mesh.vertices[vertex_pos_counter + 5] = (float) (z + 1) * scale_factor.z;

                mesh.vertices[vertex_pos_counter + 6] = (float)(x + 1) * scale_factor.x;
                mesh.vertices[vertex_pos_counter + 7] = (float)rf_gray_value(pixels[(x + 1) + z * map_x]) * scale_factor.y;
                mesh.vertices[vertex_pos_counter + 8] = (float)z * scale_factor.z;

                // another triangle - 3 vertex
                mesh.vertices[vertex_pos_counter + 9 ] = mesh.vertices[vertex_pos_counter + 6];
                mesh.vertices[vertex_pos_counter + 10] = mesh.vertices[vertex_pos_counter + 7];
                mesh.vertices[vertex_pos_counter + 11] = mesh.vertices[vertex_pos_counter + 8];

                mesh.vertices[vertex_pos_counter + 12] = mesh.vertices[vertex_pos_counter + 3];
                mesh.vertices[vertex_pos_counter + 13] = mesh.vertices[vertex_pos_counter + 4];
                mesh.vertices[vertex_pos_counter + 14] = mesh.vertices[vertex_pos_counter + 5];

                mesh.vertices[vertex_pos_counter + 15] = (float)(x + 1) * scale_factor.x;
                mesh.vertices[vertex_pos_counter + 16] = (float)rf_gray_value(pixels[(x + 1) + (z + 1) * map_x]) * scale_factor.y;
                mesh.vertices[vertex_pos_counter + 17] = (float)(z + 1) * scale_factor.z;
                vertex_pos_counter += 18; // 6 vertex, 18 floats

                // Fill texcoords array with data
                //--------------------------------------------------------------
                mesh.texcoords[vertex_texcoord_counter    ] = (float)x / (map_x - 1);
                mesh.texcoords[vertex_texcoord_counter + 1] = (float)z / (map_z - 1);

                mesh.texcoords[vertex_texcoord_counter + 2] = (float)x / (map_x - 1);
                mesh.texcoords[vertex_texcoord_counter + 3] = (float)(z + 1) / (map_z - 1);

                mesh.texcoords[vertex_texcoord_counter + 4] = (float)(x + 1) / (map_x - 1);
                mesh.texcoords[vertex_texcoord_counter + 5] = (float)z / (map_z - 1);

                mesh.texcoords[vertex_texcoord_counter + 6] = mesh.texcoords[vertex_texcoord_counter + 4];
                mesh.texcoords[vertex_texcoord_counter + 7] = mesh.texcoords[vertex_texcoord_counter + 5];

                mesh.texcoords[vertex_texcoord_counter + 8] = mesh.texcoords[vertex_texcoord_counter + 2];
                mesh.texcoords[vertex_texcoord_counter + 9] = mesh.texcoords[vertex_texcoord_counter + 3];

                mesh.texcoords[vertex_texcoord_counter + 10] = (float)(x + 1) / (map_x - 1);
                mesh.texcoords[vertex_texcoord_counter + 11] = (float)(z + 1) / (map_z - 1);

                vertex_texcoord_counter += 12; // 6 texcoords, 12 floats

                // Fill normals array with data
                //--------------------------------------------------------------
                for (rf_int i = 0; i < 18; i += 3)
                {
                    mesh.normals[n_counter + i    ] = 0.0f;
                    mesh.normals[n_counter + i + 1] = 1.0f;
                    mesh.normals[n_counter + i + 2] = 0.0f;
                }

                // TODO: Calculate normals in an efficient way

                n_counter    += 18; // 6 vertex, 18 floats
                tris_counter += 2;
            }
        }
    }

    rf_pixel_buffer_free(pixels_buf, allocator);

    // Upload vertex data to GPU (static mesh)
    rf_gfx_load_mesh(&mesh, false);

    return mesh;
}

// Generate a cubes mesh from pixel data
// NOTE: Vertex data is uploaded to GPU
rf_extern rf_mesh rf_gen_mesh_cubicmap(rf_image cubicmap, rf_vec3 cube_size, rf_allocator allocator, rf_allocator temp_allocator)
{
    rf_mesh mesh = {0};
    mesh.vbo_id = (unsigned int*) rf_alloc(allocator, RF_MAX_MESH_VBO * sizeof(unsigned int));
    memset(mesh.vbo_id, 0, RF_MAX_MESH_VBO * sizeof(unsigned int));

    rf_pixel_buffer pixel_buffer = rf_format_pixels_to_rgba32(rf_image_to_pixel_buffer(cubicmap), temp_allocator);
    if (pixel_buffer.valid)
    {
        rf_color* cubicmap_pixels = pixel_buffer.data;

        int map_width = cubicmap.width;
        int map_height = cubicmap.height;

        // NOTE: Max possible number of triangles numCubes*(12 triangles by cube)
        int maxTriangles = cubicmap.width*cubicmap.height*12;

        int vertex_pos_counter = 0; // Used to count vertices
        int vertex_texcoord_counter = 0; // Used to count texcoords
        int n_counter = 0; // Used to count normals

        float w = cube_size.x;
        float h = cube_size.z;
        float h2 = cube_size.y;

        rf_vec3* map_vertices  = (rf_vec3*) rf_alloc(temp_allocator, maxTriangles * 3 * sizeof(rf_vec3));
        rf_vec2 *map_texcoords = (rf_vec2*) rf_alloc(temp_allocator, maxTriangles * 3 * sizeof(rf_vec2));
        rf_vec3* map_normals   = (rf_vec3*) rf_alloc(temp_allocator, maxTriangles * 3 * sizeof(rf_vec3));

        // Define the 6 normals of the cube, we will combine them accordingly later...
        rf_vec3 n1 = {  1.0f,  0.0f,  0.0f };
        rf_vec3 n2 = { -1.0f,  0.0f,  0.0f };
        rf_vec3 n3 = {  0.0f,  1.0f,  0.0f };
        rf_vec3 n4 = {  0.0f, -1.0f,  0.0f };
        rf_vec3 n5 = {  0.0f,  0.0f,  1.0f };
        rf_vec3 n6 = {  0.0f,  0.0f, -1.0f };

        // NOTE: We use texture rectangles to define different textures for top-bottom-front-back-right-left (6)
        typedef struct rf_recf rf_recf;
        struct rf_recf
        {
            float x;
            float y;
            float width;
            float height;
        };

        rf_recf right_tex_uv  = { 0.0f, 0.0f, 0.5f, 0.5f };
        rf_recf left_tex_uv   = { 0.5f, 0.0f, 0.5f, 0.5f };
        rf_recf front_tex_uv  = { 0.0f, 0.0f, 0.5f, 0.5f };
        rf_recf back_tex_uv   = { 0.5f, 0.0f, 0.5f, 0.5f };
        rf_recf top_tex_uv    = { 0.0f, 0.5f, 0.5f, 0.5f };
        rf_recf bottom_tex_uv = { 0.5f, 0.5f, 0.5f, 0.5f };

        for (rf_int z = 0; z < map_height; ++z)
        {
            for (rf_int x = 0; x < map_width; ++x)
            {
                // Define the 8 vertex of the cube, we will combine them accordingly later...
                rf_vec3 v1 = {w * (x - 0.5f), h2, h * (z - 0.5f) };
                rf_vec3 v2 = {w * (x - 0.5f), h2, h * (z + 0.5f) };
                rf_vec3 v3 = {w * (x + 0.5f), h2, h * (z + 0.5f) };
                rf_vec3 v4 = {w * (x + 0.5f), h2, h * (z - 0.5f) };
                rf_vec3 v5 = {w * (x + 0.5f), 0, h * (z - 0.5f) };
                rf_vec3 v6 = {w * (x - 0.5f), 0, h * (z - 0.5f) };
                rf_vec3 v7 = {w * (x - 0.5f), 0, h * (z + 0.5f) };
                rf_vec3 v8 = {w * (x + 0.5f), 0, h * (z + 0.5f) };

                // We check pixel color to be RF_WHITE, we will full cubes
                if ((cubicmap_pixels[z*cubicmap.width + x].r == 255) &&
                    (cubicmap_pixels[z*cubicmap.width + x].g == 255) &&
                    (cubicmap_pixels[z*cubicmap.width + x].b == 255))
                {
                    // Define triangles (Checking Collateral Cubes!)
                    //----------------------------------------------

                    // Define top triangles (2 tris, 6 vertex --> v1-v2-v3, v1-v3-v4)
                    map_vertices[vertex_pos_counter] = v1;
                    map_vertices[vertex_pos_counter + 1] = v2;
                    map_vertices[vertex_pos_counter + 2] = v3;
                    map_vertices[vertex_pos_counter + 3] = v1;
                    map_vertices[vertex_pos_counter + 4] = v3;
                    map_vertices[vertex_pos_counter + 5] = v4;
                    vertex_pos_counter += 6;

                    map_normals[n_counter] = n3;
                    map_normals[n_counter + 1] = n3;
                    map_normals[n_counter + 2] = n3;
                    map_normals[n_counter + 3] = n3;
                    map_normals[n_counter + 4] = n3;
                    map_normals[n_counter + 5] = n3;
                    n_counter += 6;

                    map_texcoords[vertex_texcoord_counter] = (rf_vec2){top_tex_uv.x, top_tex_uv.y };
                    map_texcoords[vertex_texcoord_counter + 1] = (rf_vec2){top_tex_uv.x, top_tex_uv.y + top_tex_uv.height };
                    map_texcoords[vertex_texcoord_counter + 2] = (rf_vec2){top_tex_uv.x + top_tex_uv.width, top_tex_uv.y + top_tex_uv.height };
                    map_texcoords[vertex_texcoord_counter + 3] = (rf_vec2){top_tex_uv.x, top_tex_uv.y };
                    map_texcoords[vertex_texcoord_counter + 4] = (rf_vec2){top_tex_uv.x + top_tex_uv.width, top_tex_uv.y + top_tex_uv.height };
                    map_texcoords[vertex_texcoord_counter + 5] = (rf_vec2){top_tex_uv.x + top_tex_uv.width, top_tex_uv.y };
                    vertex_texcoord_counter += 6;

                    // Define bottom triangles (2 tris, 6 vertex --> v6-v8-v7, v6-v5-v8)
                    map_vertices[vertex_pos_counter] = v6;
                    map_vertices[vertex_pos_counter + 1] = v8;
                    map_vertices[vertex_pos_counter + 2] = v7;
                    map_vertices[vertex_pos_counter + 3] = v6;
                    map_vertices[vertex_pos_counter + 4] = v5;
                    map_vertices[vertex_pos_counter + 5] = v8;
                    vertex_pos_counter += 6;

                    map_normals[n_counter] = n4;
                    map_normals[n_counter + 1] = n4;
                    map_normals[n_counter + 2] = n4;
                    map_normals[n_counter + 3] = n4;
                    map_normals[n_counter + 4] = n4;
                    map_normals[n_counter + 5] = n4;
                    n_counter += 6;

                    map_texcoords[vertex_texcoord_counter] = (rf_vec2){bottom_tex_uv.x + bottom_tex_uv.width, bottom_tex_uv.y };
                    map_texcoords[vertex_texcoord_counter + 1] = (rf_vec2){bottom_tex_uv.x, bottom_tex_uv.y + bottom_tex_uv.height };
                    map_texcoords[vertex_texcoord_counter + 2] = (rf_vec2){bottom_tex_uv.x + bottom_tex_uv.width, bottom_tex_uv.y + bottom_tex_uv.height };
                    map_texcoords[vertex_texcoord_counter + 3] = (rf_vec2){bottom_tex_uv.x + bottom_tex_uv.width, bottom_tex_uv.y };
                    map_texcoords[vertex_texcoord_counter + 4] = (rf_vec2){bottom_tex_uv.x, bottom_tex_uv.y };
                    map_texcoords[vertex_texcoord_counter + 5] = (rf_vec2){bottom_tex_uv.x, bottom_tex_uv.y + bottom_tex_uv.height };
                    vertex_texcoord_counter += 6;

                    if (((z < cubicmap.height - 1) &&
                         (cubicmap_pixels[(z + 1)*cubicmap.width + x].r == 0) &&
                         (cubicmap_pixels[(z + 1)*cubicmap.width + x].g == 0) &&
                         (cubicmap_pixels[(z + 1)*cubicmap.width + x].b == 0)) || (z == cubicmap.height - 1))
                    {
                        // Define front triangles (2 tris, 6 vertex) --> v2 v7 v3, v3 v7 v8
                        // NOTE: Collateral occluded faces are not generated
                        map_vertices[vertex_pos_counter] = v2;
                        map_vertices[vertex_pos_counter + 1] = v7;
                        map_vertices[vertex_pos_counter + 2] = v3;
                        map_vertices[vertex_pos_counter + 3] = v3;
                        map_vertices[vertex_pos_counter + 4] = v7;
                        map_vertices[vertex_pos_counter + 5] = v8;
                        vertex_pos_counter += 6;

                        map_normals[n_counter] = n6;
                        map_normals[n_counter + 1] = n6;
                        map_normals[n_counter + 2] = n6;
                        map_normals[n_counter + 3] = n6;
                        map_normals[n_counter + 4] = n6;
                        map_normals[n_counter + 5] = n6;
                        n_counter += 6;

                        map_texcoords[vertex_texcoord_counter] = (rf_vec2){front_tex_uv.x, front_tex_uv.y };
                        map_texcoords[vertex_texcoord_counter + 1] = (rf_vec2){front_tex_uv.x, front_tex_uv.y + front_tex_uv.height };
                        map_texcoords[vertex_texcoord_counter + 2] = (rf_vec2){front_tex_uv.x + front_tex_uv.width, front_tex_uv.y };
                        map_texcoords[vertex_texcoord_counter + 3] = (rf_vec2){front_tex_uv.x + front_tex_uv.width, front_tex_uv.y };
                        map_texcoords[vertex_texcoord_counter + 4] = (rf_vec2){front_tex_uv.x, front_tex_uv.y + front_tex_uv.height };
                        map_texcoords[vertex_texcoord_counter + 5] = (rf_vec2){front_tex_uv.x + front_tex_uv.width, front_tex_uv.y + front_tex_uv.height };
                        vertex_texcoord_counter += 6;
                    }

                    if (((z > 0) &&
                         (cubicmap_pixels[(z - 1)*cubicmap.width + x].r == 0) &&
                         (cubicmap_pixels[(z - 1)*cubicmap.width + x].g == 0) &&
                         (cubicmap_pixels[(z - 1)*cubicmap.width + x].b == 0)) || (z == 0))
                    {
                        // Define back triangles (2 tris, 6 vertex) --> v1 v5 v6, v1 v4 v5
                        // NOTE: Collateral occluded faces are not generated
                        map_vertices[vertex_pos_counter] = v1;
                        map_vertices[vertex_pos_counter + 1] = v5;
                        map_vertices[vertex_pos_counter + 2] = v6;
                        map_vertices[vertex_pos_counter + 3] = v1;
                        map_vertices[vertex_pos_counter + 4] = v4;
                        map_vertices[vertex_pos_counter + 5] = v5;
                        vertex_pos_counter += 6;

                        map_normals[n_counter] = n5;
                        map_normals[n_counter + 1] = n5;
                        map_normals[n_counter + 2] = n5;
                        map_normals[n_counter + 3] = n5;
                        map_normals[n_counter + 4] = n5;
                        map_normals[n_counter + 5] = n5;
                        n_counter += 6;

                        map_texcoords[vertex_texcoord_counter] = (rf_vec2){back_tex_uv.x + back_tex_uv.width, back_tex_uv.y };
                        map_texcoords[vertex_texcoord_counter + 1] = (rf_vec2){back_tex_uv.x, back_tex_uv.y + back_tex_uv.height };
                        map_texcoords[vertex_texcoord_counter + 2] = (rf_vec2){back_tex_uv.x + back_tex_uv.width, back_tex_uv.y + back_tex_uv.height };
                        map_texcoords[vertex_texcoord_counter + 3] = (rf_vec2){back_tex_uv.x + back_tex_uv.width, back_tex_uv.y };
                        map_texcoords[vertex_texcoord_counter + 4] = (rf_vec2){back_tex_uv.x, back_tex_uv.y };
                        map_texcoords[vertex_texcoord_counter + 5] = (rf_vec2){back_tex_uv.x, back_tex_uv.y + back_tex_uv.height };
                        vertex_texcoord_counter += 6;
                    }

                    if (((x < cubicmap.width - 1) &&
                         (cubicmap_pixels[z*cubicmap.width + (x + 1)].r == 0) &&
                         (cubicmap_pixels[z*cubicmap.width + (x + 1)].g == 0) &&
                         (cubicmap_pixels[z*cubicmap.width + (x + 1)].b == 0)) || (x == cubicmap.width - 1))
                    {
                        // Define right triangles (2 tris, 6 vertex) --> v3 v8 v4, v4 v8 v5
                        // NOTE: Collateral occluded faces are not generated
                        map_vertices[vertex_pos_counter] = v3;
                        map_vertices[vertex_pos_counter + 1] = v8;
                        map_vertices[vertex_pos_counter + 2] = v4;
                        map_vertices[vertex_pos_counter + 3] = v4;
                        map_vertices[vertex_pos_counter + 4] = v8;
                        map_vertices[vertex_pos_counter + 5] = v5;
                        vertex_pos_counter += 6;

                        map_normals[n_counter] = n1;
                        map_normals[n_counter + 1] = n1;
                        map_normals[n_counter + 2] = n1;
                        map_normals[n_counter + 3] = n1;
                        map_normals[n_counter + 4] = n1;
                        map_normals[n_counter + 5] = n1;
                        n_counter += 6;

                        map_texcoords[vertex_texcoord_counter] = (rf_vec2){right_tex_uv.x, right_tex_uv.y };
                        map_texcoords[vertex_texcoord_counter + 1] = (rf_vec2){right_tex_uv.x, right_tex_uv.y + right_tex_uv.height };
                        map_texcoords[vertex_texcoord_counter + 2] = (rf_vec2){right_tex_uv.x + right_tex_uv.width, right_tex_uv.y };
                        map_texcoords[vertex_texcoord_counter + 3] = (rf_vec2){right_tex_uv.x + right_tex_uv.width, right_tex_uv.y };
                        map_texcoords[vertex_texcoord_counter + 4] = (rf_vec2){right_tex_uv.x, right_tex_uv.y + right_tex_uv.height };
                        map_texcoords[vertex_texcoord_counter + 5] = (rf_vec2){right_tex_uv.x + right_tex_uv.width, right_tex_uv.y + right_tex_uv.height };
                        vertex_texcoord_counter += 6;
                    }

                    if (((x > 0) &&
                         (cubicmap_pixels[z*cubicmap.width + (x - 1)].r == 0) &&
                         (cubicmap_pixels[z*cubicmap.width + (x - 1)].g == 0) &&
                         (cubicmap_pixels[z*cubicmap.width + (x - 1)].b == 0)) || (x == 0))
                    {
                        // Define left triangles (2 tris, 6 vertex) --> v1 v7 v2, v1 v6 v7
                        // NOTE: Collateral occluded faces are not generated
                        map_vertices[vertex_pos_counter] = v1;
                        map_vertices[vertex_pos_counter + 1] = v7;
                        map_vertices[vertex_pos_counter + 2] = v2;
                        map_vertices[vertex_pos_counter + 3] = v1;
                        map_vertices[vertex_pos_counter + 4] = v6;
                        map_vertices[vertex_pos_counter + 5] = v7;
                        vertex_pos_counter += 6;

                        map_normals[n_counter] = n2;
                        map_normals[n_counter + 1] = n2;
                        map_normals[n_counter + 2] = n2;
                        map_normals[n_counter + 3] = n2;
                        map_normals[n_counter + 4] = n2;
                        map_normals[n_counter + 5] = n2;
                        n_counter += 6;

                        map_texcoords[vertex_texcoord_counter] = (rf_vec2){left_tex_uv.x, left_tex_uv.y };
                        map_texcoords[vertex_texcoord_counter + 1] = (rf_vec2){left_tex_uv.x + left_tex_uv.width, left_tex_uv.y + left_tex_uv.height };
                        map_texcoords[vertex_texcoord_counter + 2] = (rf_vec2){left_tex_uv.x + left_tex_uv.width, left_tex_uv.y };
                        map_texcoords[vertex_texcoord_counter + 3] = (rf_vec2){left_tex_uv.x, left_tex_uv.y };
                        map_texcoords[vertex_texcoord_counter + 4] = (rf_vec2){left_tex_uv.x, left_tex_uv.y + left_tex_uv.height };
                        map_texcoords[vertex_texcoord_counter + 5] = (rf_vec2){left_tex_uv.x + left_tex_uv.width, left_tex_uv.y + left_tex_uv.height };
                        vertex_texcoord_counter += 6;
                    }
                }
                    // We check pixel color to be RF_BLACK, we will only draw floor and roof
                else if ((cubicmap_pixels[z*cubicmap.width + x].r == 0) &&
                         (cubicmap_pixels[z*cubicmap.width + x].g == 0) &&
                         (cubicmap_pixels[z*cubicmap.width + x].b == 0))
                {
                    // Define top triangles (2 tris, 6 vertex --> v1-v2-v3, v1-v3-v4)
                    map_vertices[vertex_pos_counter] = v1;
                    map_vertices[vertex_pos_counter + 1] = v3;
                    map_vertices[vertex_pos_counter + 2] = v2;
                    map_vertices[vertex_pos_counter + 3] = v1;
                    map_vertices[vertex_pos_counter + 4] = v4;
                    map_vertices[vertex_pos_counter + 5] = v3;
                    vertex_pos_counter += 6;

                    map_normals[n_counter] = n4;
                    map_normals[n_counter + 1] = n4;
                    map_normals[n_counter + 2] = n4;
                    map_normals[n_counter + 3] = n4;
                    map_normals[n_counter + 4] = n4;
                    map_normals[n_counter + 5] = n4;
                    n_counter += 6;

                    map_texcoords[vertex_texcoord_counter] = (rf_vec2){top_tex_uv.x, top_tex_uv.y };
                    map_texcoords[vertex_texcoord_counter + 1] = (rf_vec2){top_tex_uv.x + top_tex_uv.width, top_tex_uv.y + top_tex_uv.height };
                    map_texcoords[vertex_texcoord_counter + 2] = (rf_vec2){top_tex_uv.x, top_tex_uv.y + top_tex_uv.height };
                    map_texcoords[vertex_texcoord_counter + 3] = (rf_vec2){top_tex_uv.x, top_tex_uv.y };
                    map_texcoords[vertex_texcoord_counter + 4] = (rf_vec2){top_tex_uv.x + top_tex_uv.width, top_tex_uv.y };
                    map_texcoords[vertex_texcoord_counter + 5] = (rf_vec2){top_tex_uv.x + top_tex_uv.width, top_tex_uv.y + top_tex_uv.height };
                    vertex_texcoord_counter += 6;

                    // Define bottom triangles (2 tris, 6 vertex --> v6-v8-v7, v6-v5-v8)
                    map_vertices[vertex_pos_counter] = v6;
                    map_vertices[vertex_pos_counter + 1] = v7;
                    map_vertices[vertex_pos_counter + 2] = v8;
                    map_vertices[vertex_pos_counter + 3] = v6;
                    map_vertices[vertex_pos_counter + 4] = v8;
                    map_vertices[vertex_pos_counter + 5] = v5;
                    vertex_pos_counter += 6;

                    map_normals[n_counter] = n3;
                    map_normals[n_counter + 1] = n3;
                    map_normals[n_counter + 2] = n3;
                    map_normals[n_counter + 3] = n3;
                    map_normals[n_counter + 4] = n3;
                    map_normals[n_counter + 5] = n3;
                    n_counter += 6;

                    map_texcoords[vertex_texcoord_counter] = (rf_vec2){bottom_tex_uv.x + bottom_tex_uv.width, bottom_tex_uv.y };
                    map_texcoords[vertex_texcoord_counter + 1] = (rf_vec2){bottom_tex_uv.x + bottom_tex_uv.width, bottom_tex_uv.y + bottom_tex_uv.height };
                    map_texcoords[vertex_texcoord_counter + 2] = (rf_vec2){bottom_tex_uv.x, bottom_tex_uv.y + bottom_tex_uv.height };
                    map_texcoords[vertex_texcoord_counter + 3] = (rf_vec2){bottom_tex_uv.x + bottom_tex_uv.width, bottom_tex_uv.y };
                    map_texcoords[vertex_texcoord_counter + 4] = (rf_vec2){bottom_tex_uv.x, bottom_tex_uv.y + bottom_tex_uv.height };
                    map_texcoords[vertex_texcoord_counter + 5] = (rf_vec2){bottom_tex_uv.x, bottom_tex_uv.y };
                    vertex_texcoord_counter += 6;
                }
            }
        }

        // Move data from map_vertices temp arays to vertices float array
        mesh.vertex_count = vertex_pos_counter;
        mesh.triangle_count = vertex_pos_counter/3;

        mesh.vertices  = (float*) rf_alloc(allocator, mesh.vertex_count * 3 * sizeof(float));
        mesh.normals   = (float*) rf_alloc(allocator, mesh.vertex_count * 3 * sizeof(float));
        mesh.texcoords = (float*) rf_alloc(allocator, mesh.vertex_count * 2 * sizeof(float));
        mesh.colors = NULL;

        int f_counter = 0;

        // Move vertices data
        for (rf_int i = 0; i < vertex_pos_counter; i++)
        {
            mesh.vertices[f_counter] = map_vertices[i].x;
            mesh.vertices[f_counter + 1] = map_vertices[i].y;
            mesh.vertices[f_counter + 2] = map_vertices[i].z;
            f_counter += 3;
        }

        f_counter = 0;

        // Move normals data
        for (rf_int i = 0; i < n_counter; i++)
        {
            mesh.normals[f_counter] = map_normals[i].x;
            mesh.normals[f_counter + 1] = map_normals[i].y;
            mesh.normals[f_counter + 2] = map_normals[i].z;
            f_counter += 3;
        }

        f_counter = 0;

        // Move texcoords data
        for (rf_int i = 0; i < vertex_texcoord_counter; i++)
        {
            mesh.texcoords[f_counter] = map_texcoords[i].x;
            mesh.texcoords[f_counter + 1] = map_texcoords[i].y;
            f_counter += 2;
        }

        rf_free(temp_allocator, map_vertices);
        rf_free(temp_allocator, map_normals);
        rf_free(temp_allocator, map_texcoords);

        rf_free(temp_allocator, cubicmap_pixels); // Free image pixel data
    }

    rf_pixel_buffer_free(pixel_buffer, temp_allocator);

    // Upload vertex data to GPU (static mesh)
    rf_gfx_load_mesh(&mesh, false);

    #undef rf_gray_value

    return mesh;
}