// Copyright 2016 KeNan Liu
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <string.h>
#include "Rapid2D_RDPortingTypes.h"
#include "Rapid2D_RDLua.h"
#include "Rapid2D_RDLog.h"
#include "Rapid2D_RDFileSystem.h"
#include "Rapid2D_RDResolution.h"
#include "xxtea.h"

static lua_State *g_L = NULL;

/*
 ** Check whether 'status' is not OK and, if so, prints the error
 ** message on the top of the stack. It assumes that the error object
 ** is a string, as it was either generated by Lua or by 'msghandler'.
 */
static int report(lua_State *L, int status)
{
    if (status != LUA_OK) {
        const char *msg = lua_tostring(L, -1);
        RDLog("[Lua Error]: %s\n", msg);
        lua_pop(L, 1);  /* remove message */
    }
    return status;
}

static int initRapidFramework(lua_State *L, const char *name, const char *key)
{
    if (name) {
        char *fullPath = RDFileSystem::getInstance()->getFullPath(RD_FILEDIR_RES, name);
        int rtn = RDLuaLoadFromChunks(L, fullPath, key);
        free(fullPath);
        if (LUA_OK == rtn) {
            lua_getglobal(L, "package");
            lua_getfield(L, -1, "preload");
            
            lua_getfield(L, -1, "rapid2d.init");
            rtn = lua_pcall(L, 0, 0, 0);  /* call the loaded package */
            rtn = report(L, rtn);
            
            lua_pop(L, 2);// pop package[preload]
        }
        return rtn;
    } else {
        int result = RDLuaLoadFromFile(L, "rapid2d.init");
        if (result != LUA_OK) {
            return LUA_ERRERR;
        }
        
        result = lua_pcall(L, 0, 0, 0);  /* call the loaded package */
        result = report(L, result);
        return result;
    }
}

static const luaL_Reg luaStandlibs[] = {
    {"_G", luaopen_base},
    {LUA_LOADLIBNAME, luaopen_package},
    {LUA_COLIBNAME, luaopen_coroutine},
    {LUA_TABLIBNAME, luaopen_table},
    //{LUA_IOLIBNAME, luaopen_io},// io lib is NOT work on Android asserts System
    {LUA_OSLIBNAME, luaopen_os},
    {LUA_STRLIBNAME, luaopen_string},
    {LUA_MATHLIBNAME, luaopen_math},
    {LUA_UTF8LIBNAME, luaopen_utf8},
    {LUA_DBLIBNAME, luaopen_debug},
    {NULL, NULL}
};

static const luaL_Reg rapid2dLibs[] = {
    {RD_LIB_LUALOADER, luaopen_LuaLoader},
    {RD_LIB_SPRITE, luaopen_Sprite},
    {RD_LIB_TEXTURE, luaopen_Texture},
    {RD_LIB_SPRITEFRAME, luaopen_SpriteFrame},
    {RD_LIB_FILESYSTEM, luaopen_FileSystem},
    {RD_LIB_MAT4, luaopen_Mat4},
    {RD_LIB_DRAWVERTEX, luaopen_DrawVertex},
    {RD_LIB_OPENGL, luaopen_OpenGL},
	{RD_LIB_AUDIO, luaopen_audio},
    {RD_LIB_CRYPTO, luaopen_crypto},
    {"cjson", luaopen_cjson},
    {NULL, NULL}
};

static void loadLuaLibrarys(lua_State *L, const luaL_Reg libsToLoad[])
{
    const luaL_Reg *lib;
    /* "require" functions from 'loadedlibs' and set results to global table */
    for (lib = libsToLoad; lib->func; lib++) {
        luaL_requiref(L, lib->name, lib->func, 1);
        lua_pop(L, 1);  /* remove lib */
    }
}

static char *moduleToFilename(const char *module)
{
    size_t size = strlen(module) + 8;
    char *filename = (char *)malloc(size);
    memset(filename, 0, size);
    int i = 0;
    while (module[i] != '\0') {
        if (module[i] == '.') {
            filename[i] = '/';
        } else {
            filename[i] = module[i];
        }
        i++;
    }
    strcat(filename, ".lua");
    return filename;
}

static void initRDconst(lua_State *L)
{
    lua_pushglobaltable(L);// push _G
    
    // start "_G.rd = {}"
    lua_pushstring(L, "rd");
    lua_newtable(L);
    // start "rd.const = {}"
    lua_pushstring(L, "const");
    lua_newtable(L);
    /* ============== useful const for game developer =============== */
    RDSize size = RDResolution::getInstance()->getResolutionSize();
    
    lua_pushstring(L, "resolutionWidth");
    lua_pushnumber(L, size.width);
    lua_rawset(L, -3);// end of const.resolutionWidth
    
    lua_pushstring(L, "resolutionHeight");
    lua_pushnumber(L, size.height);
    lua_rawset(L, -3);// end of const.resolutionHeight
    
    lua_pushstring(L, "OSType");
#if defined(RD_PLATFORM_IOS)
    lua_pushstring(L, "iOS");
#elif defined(RD_PLATFORM_MAC)
    lua_pushstring(L, "Mac");
#elif defined(RD_PLATFORM_WIN32)
    lua_pushstring(L, "Win32");
#elif defined(RD_PLATFORM_ANDROID)
    lua_pushstring(L, "Android");
#else
    lua_pushstring(L, "unknow");
#endif
    lua_rawset(L, -3);// end of const.OSType
    
    /* ============== end of adding const =============== */
    lua_rawset(L, -3);// end of "rd.const = {}"
    lua_rawset(L, -3);// end of "_G.rd = {}"
    lua_pop(L, 1); // pop _G
}

// name : rapid2d.init
int RDLuaLoadFromFile(lua_State *L, const char *module)
{
    int result;
    // convert to filename
    char *filename = moduleToFilename(module);
    RDData *data = RDFileSystem::getInstance()->getData(RD_FILEDIR_LUA, filename, true);
    free(filename);
    filename = NULL;
    if (!data) {
        RDLog("[Lua Error]: can't open %s\n", module);
        return LUA_ERRERR;
    }
    
    result = luaL_loadbuffer(L, (const char *)data->getBuffer(), data->getSize(), module);
    result = report(L, result);
    delete data;
    return result;
}

typedef struct {
    char modelName[128];
    RD_uint32 size;
    RD_uint32 offset;
} LuaChunkInfo;

int RDLuaLoadFromChunks(lua_State *L, const char *fullPath, const char *key)
{
    RDData *source = RDFileSystem::getInstance()->getData(RD_FILEDIR_FULLPATH, fullPath, false);
    if (!source) {
        return LUA_ERRERR;
    }
    
    if (source->getSize() < 7) {
        delete source;
        return LUA_ERRERR;
    }
    
    // identifer check
    if ( 0 != memcmp(source->getBuffer(), "Rapid2D", 7)) {
        RDLog("[Error] RDLuaLoadFromChunks Fail for identifier check\n");
        delete source;
        return LUA_ERRERR;
    }
    
    size_t curPos = 7;
    // get version
    RD_uint32 version;
    memcpy((void *)&version, source->getBuffer() + curPos, sizeof(RD_uint32));
    curPos += sizeof(RD_uint32);
    // get file counts
    RD_uint32 counts;
    memcpy((void *)&counts, source->getBuffer() + curPos, sizeof(RD_uint32));
    curPos += sizeof(RD_uint32);
    
    // load chunks
    lua_getglobal(L, "package");
    lua_getfield(L, -1, "preload");
    for (int index = 0; index < counts; index++) {
        LuaChunkInfo info = {0};
        memcpy((void *)&info, source->getBuffer() + curPos, sizeof(LuaChunkInfo));
        // xxtea decrypt
        size_t outLen;
        char *luaBuffer = (char *)xxtea_decrypt(source->getBuffer() + info.offset,
                                                info.size, key, &outLen);
        if (luaBuffer) {
            int result = luaL_loadbuffer(L, luaBuffer, outLen, info.modelName);
            result = report(L, result);
            if (LUA_OK == result) {
                lua_setfield(L, -2, info.modelName);
#ifdef RD_DEBUG
                RDLog("[Info] RDLuaLoadFromChunks load: %s\n", info.modelName);
#endif
            }
            free(luaBuffer);
        } else {
            RDLog("[Error] RDLuaLoadFromChunks fail to decrypt: %s\n", info.modelName);
        }
        
        curPos += sizeof(LuaChunkInfo);
    }
    lua_pop(L, 2);// pop package[preload]
    
    RDLog("[Info] RDLuaLoadFromChunks load %d models\n", counts);
    delete source;
    return LUA_OK;
}

void RDLuaInit(const char *name, const char *key)
{
    lua_State *L = luaL_newstate();  /* create state */
    loadLuaLibrarys(L, luaStandlibs);/* load stand library */
    loadLuaLibrarys(L, rapid2dLibs);// load Rapid2D bindings
    initRDconst(L);
    
    if (initRapidFramework(L, name, key) != LUA_OK) {
        lua_close(L);
        return;
    }
    // save state
    g_L = L;
}

void RDLuaDraw(float dt)
{
    lua_State *L = g_L;
    int result;
    
#if defined(RD_DEBUG)
    if (NULL == L) {
        RDLog("Error: load firstscene fail\n");
        return;
    }
#endif
    // call 'rd.director.drawScene(dt)'
    lua_getglobal(L, "rd"); /* rd in stack */
    lua_getfield(L, -1, "director"); /* director in stack */
    lua_getfield(L, -1, "drawScene");/* drawScene in stack */
    lua_pushnumber(L, dt);/* params in stck */
    result = lua_pcall(L, 1, 0, 0);  /* do the call, remove func and params */
    report(L, result);/* pop error message */
    /* pop rd.director */
    lua_pop(L, 2);
}

void RDLuaTouchEvent(char *type, int count, intptr_t ids[], float xs[], float ys[])
{
    lua_State *L = g_L;
    int result;
    
#if defined(RD_DEBUG)
    if (NULL == L) {
        RDLog("Error: load firstscene fail\n");
        return;
    }
#endif
    // call 'rd.director.dispatchTouchEvent(t, x, y)'
    lua_getglobal(L, "rd"); /* rd in stack */
    lua_getfield(L, -1, "director"); /* director in stack */
    lua_getfield(L, -1, "sendTouchEvent");/* drawScene in stack */
    lua_pushstring(L, type);/* params in stck */
    
    float scale = RDResolution::getInstance()->getScale();
    RDSize size = RDResolution::getInstance()->getResolutionSize();
    /* make table param
     * points = {
     *     1 = {
     *         "identify" = 140703312018624
     *         "x"        = 79.5
     *         "y"        = 197.5
     *     }
     *     ...
     * }
     */
    lua_newtable(L);
    for (int i = 0; i < count; i++) {
        lua_newtable(L);
        
        lua_pushstring(L, "identify");
        lua_pushinteger(L, ids[i]);
        lua_rawset(L, -3);
        
        lua_pushstring(L, "x");
        lua_pushnumber(L, (xs[i] / scale) - (size.width / 2.0f));// Screen space -> DesignResolution space
        lua_rawset(L, -3);
        
        lua_pushstring(L, "y");
        lua_pushnumber(L, (ys[i] / scale) - (size.height / 2.0f));// Screen space -> DesignResolution space
        lua_rawset(L, -3);
        
        lua_rawseti(L, -2, i + 1);// lua table index start from 1
    }
    
    result = lua_pcall(L, 2, 0, 0);  /* do the call, remove func and params */
    report(L, result);/* pop error message */
    /* pop rd.director */
    lua_pop(L, 2);
}

void RDLuaKeyBoardEvent(char *type, int keyCode)
{
    lua_State *L = g_L;
    int result;
    
#if defined(RD_DEBUG)
    if (NULL == L) {
        RDLog("Error: load firstscene fail\n");
        return;
    }
#endif
    // call 'rd.director.dispatchKeyEvent(t, code)'
    lua_getglobal(L, "rd"); /* rd in stack */
    lua_getfield(L, -1, "director"); /* director in stack */
    lua_getfield(L, -1, "sendKeyBoardEvent");/* drawScene in stack */
    lua_pushstring(L, type);/* params in stck */
    lua_pushinteger(L, keyCode);
    result = lua_pcall(L, 2, 0, 0);  /* do the call, remove func and params */
    report(L, result);/* pop error message */
    /* pop rd.director */
    lua_pop(L, 2);
}

void RDLuaClose(void)
{
    lua_close(g_L);
    g_L = NULL;
}
