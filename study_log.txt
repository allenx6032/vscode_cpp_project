https://gpts.le10.dev/  chatgpt
https://gitdl.cn/https://raw.githubusercontent.com/ clash/v2ray常用订阅加速地址
rmdir "C:/Users"
mklink /J "C:/Users" "D:/Users"

https://dl.google.com/android/repository/android-ndk-r21e-windows-x86_64.zip
https://dl.google.com/android/repository/android-ndk-r21e-linux-x86_64.zip

ndkVersion "16.1.4479499"
ndkVersion "25.1.8937393"
ndkVersion "21.4.7075529"
D:/Android-SDK/ndk/16.1.4479499/ndk-build
D:/Android-SDK/ndk/25.1.8937393/ndk-build
mkdir bld&cd bld&cmake ..  -GNinja -DCMAKE_TOOLCHAIN_FILE=D:/Android-SDK/ndk/25.1.8937393/build/cmake/android.toolchain.cmake -DANDROID_ABI=armeabi-v7a -DANDROID_PLATFORM=android-28 -DCMAKE_BUILD_TYPE=Release
mkdir bld&cd bld&cmake ..  -GNinja -DCMAKE_TOOLCHAIN_FILE=D:/Android-SDK/ndk/25.1.8937393/build/cmake/android.toolchain.cmake -DANDROID_ABI=arm64-v8a -DANDROID_PLATFORM=android-28 -DCMAKE_BUILD_TYPE=Release
mkdir bld&cd bld&cmake -G "Visual Studio 14" -A x86  ..&cmake --build . --config Release
mkdir bld&cd bld&cmake -G "CodeBlocks - MinGW Makefiles" -A x86  ..
mkdir bld&cd bld&cmake -G "MinGW Makefiles" ..
mkdir bld&cd bld&cmake -G "Ninja"  ..
mkdir bld&cd bld&cmake  ..
cmake --build release --config Release --target all
cmake --build debug --config Debug --target all
nm *.o >> symbols.txt //可以查看 obj文件中的所有导出符号
gcc -E main.c  -I../include > main.i //查看展开后的源文件

VC万能头文件 <YVALS.H>

modelscope download --model=gongjy/minimind-v1 --local_dir ./minimind-v1
modelscope download --model=OpenBMB/MiniCPM3-4B --local_dir ./MiniCPM3-4B
huggingface-cli download --resume-download jingyaogong/minimind-v1 --local-dir minimind-v1
huggingface-cli download --resume-download runfuture/MiniCPM3-4B --local-dir MiniCPM3-4B
git clone --depth=1 https://github.com/allenx6032/vscode_cpp_project VscodiumZone
git clone --depth=1 https://github.com/
git clone --depth=1 git@gitlab.com:
git submodule update --init --recursive --depth=1 --force
git submodule update --remote  --force <路径/子模块目录>  #强制指定更新某个子模块
git config --global submodule.fetchJobs 8  # 设置并行下载数
git config --file .gitmodules --get-regexp "\.url" # 查看所有子模块的URL配置
git config -f .gitmodules submodule.external/box2d.url <NEW_REPO_URL> #手动修正子模块URL
git submodule sync  # 同步子模块远程URL
git submodule foreach "git submodule update --init --recursive --depth=1 --force --checkout || :"
git submodule foreach "git checkout -f" //强制更新所有子模块
git submodule update --init --remote --force <subodule_name> //强制更新指定子模块
git submodule update --init --recursive --depth=1 --force --checkout --jobs 8
git submodule deinit --force --all //删除子模块同步记录
rm -rf .git/modules  # 清除Git缓存的子模块元数据
 git rm --cached #清理git缓存
git submodule update --init --recursive --checkout //更新子模块

git submodule update --init --recursive --depth=1 --force//同步不存在子模块时
git submodule deinit -f <submodule> //删除子模块
git rm --cache <submodule> //清理子模块缓存

curl --proxy 127.0.0.1:7890 -O https://huggingface.co/karpathy/tinyllamas/resolve/main/stories15M.bin //通过代理下载模型
curl https://hf-mirror/karpathy/tinyllamas/resolve/main/stories15M.bin //通过镜像下载模型

modelscope模型下载
pip install modelscope #安装ModelScope
modelscope download --model swift/Qwen3-30B-A3B-AWQ #下载完整模型库
modelscope download --model swift/Qwen3-30B-A3B-AWQ README.md --local_dir ./dir #下载单个文件到指定本地文件夹（以下载README.md到当前路径下“dir”目录为例）
#SDK模型下载
from modelscope import snapshot_download
model_dir = snapshot_download('swift/Qwen3-30B-A3B-AWQ')
#Git模型下载
git lfs install
git clone https://www.modelscope.cn/swift/Qwen3-30B-A3B-AWQ.git
GIT_LFS_SKIP_SMUDGE=1 git clone https://www.modelscope.cn/swift/Qwen3-30B-A3B-AWQ.git #跳过 lfs 大文件下载


/build.gradle.kts
maven { url = uri("https://maven.aliyun.com/repository/google") }
maven { url = uri("https://maven.aliyun.com/repository/public") }
maven { url = uri("https://maven.aliyun.com/repository/central") }
maven { url = uri("https://maven.aliyun.com/repository/jcenter") }
maven { url = uri("https://maven.aliyun.com/repository/gradle-plugin") }
maven { url = uri("https://maven.aliyun.com/repository/grails-core") }
maven { url = uri("https://maven.aliyun.com/repository/apache-snapshots") 
allprojects{ buildDir = file("${rootDir}/gradle-build/${project.name}") }
applicationVariants.all {
    outputs.all {
        val ver = defaultConfig.versionName
        val minSdk = project.extensions.getByType(BaseAppModuleExtension::class.java).defaultConfig.minSdk
        val abi = filters.find{it.filterType == "ABI"}?.identifier ?:"all"
        (this as com.android.build.gradle.internal.api.BaseVariantOutputImpl).outputFileName =
            "${project.name}-$ver-${abi}-sdk$minSdk.apk";
    }
}
/build.gradle
maven { url 'https://maven.aliyun.com/repository/google' }
maven { url 'https://maven.aliyun.com/repository/public' }
maven { url 'https://maven.aliyun.com/repository/central' }
maven { url 'https://maven.aliyun.com/repository/jcenter' }
maven { url 'https://maven.aliyun.com/repository/gradle-plugin' }
maven { url 'https://maven.aliyun.com/repository/grails-core' }
maven { url 'https://maven.aliyun.com/repository/apache-snapshots' }
tasks.withType(JavaCompile).configureEach {
    // 设置全局编码
    options.encoding = 'UTF-8'
}
tasks.withType(Javadoc) {
    options.addStringOption('Xdoclint:none', '-quiet')
    options.addStringOption('encoding', 'UTF-8')
    options.addStringOption('charset', 'UTF-8')
}
buildDir = new File(rootDir, "gradle-build/${path.replaceAll(':', '/')}")
android.applicationVariants.all {
    variant ->
        variant.outputs.all {
            //指定文件输出路径
            outputFileName = "Silkswap-${variant.name}.apk"
        }
}
/gradle-wrapper.properties
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https://mirrors.cloud.tencent.com/gradle/gradle-7.5-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists


//#if LUA_VERSION_NUM < 502
//#define luaL_newlib(L,l) (lua_newtable(L), luaL_register(L,NULL,l))
//#endif
#if (LUA_VERSION_NUM == 501)
#define luaL_setfuncs(L,f,n) luaL_register(L,NULL,f)
#define luaL_newlib(L,f) luaL_register(L,"lpeg",f)
#endif
#if LUA_VERSION_NUM >= 503
    #define lua_tointegerx lua_tointegerx
#else
    #define lua_tointegerx(L,idx,isnum) \
        (*(isnum) = lua_isnumber(L,idx), lua_tointeger(L,idx))
#endif

//202002L c++20 201703L c++17 201402L c++14 201103L c++11
#if __cplusplus >=  201703L //c++17
std::cout << "Compiled as C++17 or later" << std::endl;
#elif __cplusplus >= 201402L //c++14
std::cout << "Compiled as C++14" << std::endl;
#elif __cplusplus >= 201103L //c++11
std::cout << "Compiled as C++11" << std::endl;
#else
std::cout << "Compiled as pre-C++11" << std::endl;
#endif

gcc 编译在 int main() 前添加#undef main
gcc 64位 (int) -> (int)(size_t)
gcc asm
__asm__("");
set http_proxy=http://127.0.0.1:[端口] & set https_proxy=http://127.0.0.1:[端口]
#ifndef _XXX_H_
#define _XXX_H_
#endif

强制结束进程
taskkill /im main.exe /f
wmic process where name='main.exe' delete
taskkill /f /t /im 1 <PID>

#make指定makefile文件编译
make -f makefilename
make -f makefilename clean
make -f Makefile.win32 CFG=debug
make 2>&1|tee xxx.log  编译日志打印
gcc/g++ -Wall[打印所有日志] -w[打印警告/错误日志] -fsyntax-only[打印错误日志]

# 设置环境变量（临时生效）
set PATH=D:\vcpkg;%PATH%
# 或者永久设置（需要管理员权限）
setx PATH "D:\vcpkg;%PATH%"
vcpkg install lua --triplet=x64-windows
vcpkg install lua --triplet=x64-windows --clean-build
vcpkg remove lua --triplet=x64-windows 
vcpkg remove lua --triplet=x64-windows  --recurse
vcpkg install lua --triplet=x64-mingw-static
vcpkg install lua --triplet=x64-mingw-static --clean-build
vcpkg remove lua --triplet=x64-mingw-static 
vcpkg remove lua --triplet=x64-mingw-static  --recurse
cmake -DCMAKE_TOOLCHAIN_FILE=D:/vcpkg/scripts/buildsystems/vcpkg.cmake  ..
cmake -DCMAKE_TOOLCHAIN_FILE=D:/vcpkg/scripts/buildsystems/vcpkg.cmake -DVCPKG_BUILD_TYPE=debug ..
cmake -DCMAKE_TOOLCHAIN_FILE=D:/vcpkg/scripts/buildsystems/vcpkg.cmake -DVCPKG_BUILD_TYPE=debug -DVCPKG_TARGET_TRIPLET=x64-mingw-static ..
vcpkg list
vcpkg update
vcpkg upgrade

set PROMTP=$p$_$+$g /m //缩短cmd路径显示
set JAVA_HOME=U:\android-studio\jre 临时用户变量
setx "JAVA_HOME" "U:\android-studio\jre" 临时系统变量
setx /m "JAVA_HOME" "U:\android-studio\jre" 永久系统变量
setx -m "JAVA_HOME" "U:\android-studio\jre" 追加临时系统变量
setx  HTTP_PROXY socks5://127.0.0.1:7890
setx  HTTPS_PROXY socks5://127.0.0.1:7890
setx PATH %PATH%;D:\android-sdk\platform-tools
set DEPOT_TOOLS_UPDATE=0
set DEPOT_TOOLS_WIN_TOOLCHAIN=0
set HTTP_PROXY=http://127.0.0.1:7897 
set HTTPS_PROXY=http://127.0.0.1:7897
set ALL_PROXY=socks5://127.0.0.1:7890
set GOBIN=D:\go\bin
set GOPATH=D:\go
set GOROOT=D:\go
setx "DEPOT_TOOLS_UPDATE" "0" 
setx "DEPOT_TOOLS_WIN_TOOLCHAIN" "0" 
git config --global http.proxy 127.0.0.1:7897
git config --global https.proxy 127.0.0.1:7897
netsh winhttp set proxy 127.0.0.1:7897
adb connect 127.0.0.1:62001 夜神模拟器
adb pair 192.168.2.23:38391 
adb connect 192.168.2.23:38391 
adb -s 设备号 tcpip 端口号
adb pair IP:端口号
adb connect IP:端口号


gradlew app:assembleRelease
gradlew :app:dependencies  > app.txt
gradlew :app:androidDependencies > app.txt
gradlew clean  assembleRelease --stacktrace --no-daemon
gradlew clean  assembleRelease --stacktrace --no-daemon --debug --scan

adb exec-out screencap -p > s2c_1.png //手机屏幕截屏导出图片
adb install -r -d xxx.apk //强制降级安装

set GRADLE_USER_HOME="C:/.gradle"
setx GRADLE_USER_HOME C:/.gradle
setx GRADLE_USER_HOME C:/.gradle /m

jarsigner -verify -verbose -certs 获取apk签名状态、信息
jarsigner -verbose -keystore {签名证书存放路径} -signedjar {签名后apk存放路径} {未签名的apk路径} {证书别名}
jarsigner -verbose -keystore test.jks -signedjar unsign_test.apk signed_test.apk test
jarsigner -verbose -keystore {签名证书存放路径} -storepass {签名证书密码} -signedjar {签名后文件存放路径} {未签名的文件路径} {您的证书别名}
jarsigner -verbose -keystore test.jks -storepass 123123 -signedjar test.apk before_test.apk test
jarsigner -verbose -keystore (签名地址) -signedjar (签名后的apk地址) (待签名apk地址) (别名) V1签名（jarsigner方式）
apksigner sign --ks (签名地址) --ks-key-alias (别名) --out (签名后的apk地址) (待签名apk地址)  V2签名（apksigner方式）
jarsigner -verbose -keystore {签名证书存放路径} -signedjar {签名后apk存放路径} {未签名的apk路径} {证书别名

git config --global filter.lfs.smudge "git-lfs smudge --skip"#跳过大文件clone pull
git config --global filter.lfs.smudge "git-lfs smudge -- %f"#解除跳过大文件clone pull
set GIT_LFS_SKIP_SMUDGE=1&git clone --depth=1 https://github.com/google/angle
git clone --depth=1 https://github.com/
git submodule update --init --recursive --depth=1
git submodule deinit -f <module_name>
git rm <module_name>
git config --global http.proxy socks5://127.0.0.1:7890#全局代理
git config --local https.proxy socks5://127.0.0.1:7890#临时代理
git config --global http.https://github.com.proxy socks5://127.0.0.1:7890#针对github代理
git config --global --unset http.https://github.com.proxy#取消对github代理
git config --global --unset http.proxy#取消git代理
git config --global url."https://gitdl.cn/https://github.com".insteadOf https://github.com#针对github替换
git config --global http.version HTTP/1.1//配置https lts标准
git config --global http.sslVerify false
git config --global http.postBuffer 5120m
git config --global core.compression 0#设置压缩机别 0表示无压缩
git config --global core.filemode false#设置文件格式（忽略权限变化）\不信任文件模式（跨系统文件复制和使用）
git config --global core.safecrlf true#拒绝提交包含混合换行符的文件
git config --global core.autocrfl false#设置git换行符 不转换换行符
git config --system core.longpaths true#启用 Git 的长路径支持
git config --global http.lowSpeedLimit 0
git config --global http.lowSpeedTime 99
git config --global pack.threads 1#设置git 线程数
git config --global pack.deltaCacheSize 2560m
git config --global pack.SizeLimit 2560m#设置一个包最大的压缩尺寸
git config --global pack.windowMemory 5120m
git config --global core.protectNTFS false #关闭NTFS 保护机制
git config --global submodule.fetchJobs 8  # 设置并行下载数
git-lfs filter-process
git log 
git show
git diff
git revert
git reset --hard //重置历史修改
git reset //在使用 git reset --hard 或者重写历史之后，一定要记得强制推送（--force），这样远程仓库的历史才会被更新。
git filter-branch
git checkout/swhitch ^Tag/<commit-id> #命令切换到某一节点但保留之后的所有更改
git reset --soft <commit-id>  #不改变工作目录和暂存区的内容，仅仅是重置HEAD到指定的commit
git reset --hard <commit-id>   # 切换到某一节点并丢弃当前改动
git reset --mixed <commit-id>  # 切换到某一节点但保留当前改动
git revert <commit-id> #撤销指定commit (不改变历史)
git revert -m 1 <commit-id> #撤销指定commit (不改变历史) 如果该commit不是最新的 指定-m选项来指定父提交
git cherry-pick 
git add .
git commit -m ”“
git checkout master
git push origin master
git pull --rebase
git pull --rebase -i <commit-id> #彻底删除 Git 中的commit提交的内容
git pull --rebase origin main
git push -u origin main #推送新的“main”分支到远程仓库
git reflog #显示可引用的历史版本记录. 找到要撤回的commit的前面的
git push origin HEAD --force #将本地分支代码强制推送到远处分支

git remote add origin <remote_repository_url> #关联远程仓库
git merge dev
git fetch
git reset ^HEAD
git reset --unshallow
git config --system https.sslbackend openssl
git config --global url."https://github.moeyy.xyz/https://github.com".insteadOf https://github.com
git config --global url."https://mirror.ghproxy.com/https://github.com".insteadOf https://github.com
git config --global url."https://ghproxy.net/https://github.com".insteadOf https://github.com
git config --global url."https://ghp.ci/https://github.com".insteadOf https://github.com
git config --global url."https://gitdl.cn/https://github.com".insteadOf https://github.com
git config --global url.https://source.codeaurora.org.insteadOf git://codeaurora.org
git config --global url.https://beijing.source.codeaurora.org.insteadOf git://codeaurora.org
git config --global url.https://beijing.source.codeaurora.org.insteadOf https://source.codeaurora.org
git config --global url."https://mirrors.tuna.tsinghua.edu.cn/git/chromiumos".insteadOf https://chromium.googlesource.com
git config --global --unset url.https://github.moeyy.xyz/https://github.com.insteadof
git config --global --unset url.https://ghproxy.net/https://github.com/.insteadof
git config --global --unset url.https://gitdl.cn/https://github.com.insteadof
.gitconfig查看配置文件

git config --global pack.deltaCacheSize 2560m
git config --global pack.SizeLimit 2560m
git config --global pack.windowMemory 5120m
git config --global core.protectNTFS false
git config --global core.longpaths true
git config --global core.autocrfl false
git config --global core.filemode false
git config --global core.compression 0
git config --global http.sslVerify false
git config --global https.sslVerify false
git config --global http.version HTTP/1.1
git config --global https.version HTTP/1.1
git config --global http.lowSpeedLimit 0
git config --global http.lowSpeedTime 99
git config --global http.postBuffer 5120m
git config --global https.lowSpeedLimit 0
git config --global https.lowSpeedTime 99
git config --global https.postBuffer 5120m
git config --global http.proxy socks5://127.0.0.1:7890
git config --global https.proxy socks5://127.0.0.1:7890
git config --global url."https://gitdl.cn/https://github.".insteadOf git://github.
git config --global url."https://gitdl.cn/https://github.com".insteadOf https://github.com
git config --global url."https://gitdl.cn/https://github.com/".insteadOf git@github.com:
git config --global url."https://ghp.ci/https://github.".insteadOf git://github.
git config --global url."https://ghp.ci/https://github.com".insteadOf https://github.com
git config --global url."https://ghp.ci/https://github.com/".insteadOf git@github.com:
git config --global url."https://ghproxy.net/https://github.".insteadOf git://github.
git config --global url."https://ghproxy.net/https://github.com".insteadOf https://github.com
git config --global url."https://ghproxy.net/https://github.com/".insteadOf git@github.com:
git config --global url."https://mirrors.tuna.tsinghua.edu.cn/git/chromiumos".insteadOf https://chromium.googlesource.com


ncnn 多平台编译
Build for Windows
cd <ncnn-root-dir>
mkdir build
cd build
cmake -DNCNN_VULKAN=ON -G "MinGW Makefiles" .. //cmake -DNCNN_VULKAN=OFF -G "MinGW Makefiles" ..
cmake --build . --config Release -j 4
cmake --build . --config Release --target install
Build for Android
1.build-android-armv7
cd <ncnn-root-dir>
mkdir -p build-android-armv7
cd build-android-armv7
cmake -GNinja -DCMAKE_TOOLCHAIN_FILE="D:/Android-SDK/ndk/16.1.4479499/build/cmake/android.toolchain.cmake" -DANDROID_ABI="armeabi-v7a" -DANDROID_ARM_NEON=ON -DANDROID_PLATFORM=android-14 -DNCNN_VULKAN=ON -DCMAKE_BUILD_TYPE=Release .. 
# If you use cmake >= 3.21 and ndk-r23
# you need to add -DANDROID_USE_LEGACY_TOOLCHAIN_FILE=False option for working optimization flags
make -j$(nproc)
make install
2.build-android-aarch64
cd <ncnn-root-dir>
mkdir -p build-android-aarch64
cd build-android-aarch64
cmake -DCMAKE_TOOLCHAIN_FILE="D:/Android-SDK/ndk/16.1.4479499/build/cmake/android.toolchain.cmake"\
    -DANDROID_ABI="arm64-v8a" \
    -DANDROID_PLATFORM=android-21 -DNCNN_VULKAN=ON ..
# If you use cmake >= 3.21 and ndk-r23
# you need to add -DANDROID_USE_LEGACY_TOOLCHAIN_FILE=False option for working optimization flags
make -j$(nproc)
make install
apk反编译
java -jar .\apktool_2.9.3.jar d autoHR.apk -o org.example.autostar2048
新增
C:\Users\Administrator\Downloads\org.example.autostar2048\smali\org\example\autostar2048\X5FileUtils.smali
.class public Lorg/example/autostar2048/X5FileUtils;
.super Ljava/lang/Object;
# direct methods
.method public constructor <init>()V
    .registers 1
    .prologue
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V
    return-void
.end method
.method public static DeleteFile(Ljava/io/File;)V
    .registers 5
    .param p0, "file"    # Ljava/io/File;
    .prologue
    invoke-virtual {p0}, Ljava/io/File;->exists()Z
    move-result v2
    if-nez v2, :cond_7
    :cond_6
    :goto_6
    return-void
    :cond_7
    invoke-virtual {p0}, Ljava/io/File;->isFile()Z
    move-result v2
    if-eqz v2, :cond_11
    invoke-virtual {p0}, Ljava/io/File;->delete()Z
    goto :goto_6
    :cond_11
    invoke-virtual {p0}, Ljava/io/File;->isDirectory()Z
    move-result v2
    if-eqz v2, :cond_6
    invoke-virtual {p0}, Ljava/io/File;->listFiles()[Ljava/io/File;
    move-result-object v0
    .local v0, "childFile":[Ljava/io/File;
    if-eqz v0, :cond_20
    array-length v2, v0
    if-nez v2, :cond_24
    :cond_20
    invoke-virtual {p0}, Ljava/io/File;->delete()Z
    goto :goto_6
    :cond_24
    array-length v3, v0
    const/4 v2, 0x0
    :goto_26
    if-ge v2, v3, :cond_30
    aget-object v1, v0, v2
    .local v1, "f":Ljava/io/File;
    invoke-static {v1}, Lorg/example/autostar2048/X5FileUtils;->DeleteFile(Ljava/io/File;)V
    add-int/lit8 v2, v2, 0x1
    goto :goto_26
    .end local v1    # "f":Ljava/io/File;
    :cond_30
    invoke-virtual {p0}, Ljava/io/File;->delete()Z
    goto :goto_6
.end method
.method public static copyAssets(Landroid/content/Context;Ljava/lang/String;Ljava/lang/String;)Z
    .registers 16
    .param p0, "context"    # Landroid/content/Context;
    .param p1, "oldPath"    # Ljava/lang/String;
    .param p2, "newPath"    # Ljava/lang/String;
    .prologue
    :try_start_0
    invoke-virtual {p0}, Landroid/content/Context;->getAssets()Landroid/content/res/AssetManager;
    move-result-object v8
    invoke-virtual {v8, p1}, Landroid/content/res/AssetManager;->list(Ljava/lang/String;)[Ljava/lang/String;
    move-result-object v5
    .local v5, "fileNames":[Ljava/lang/String;
    array-length v8, v5
    if-lez v8, :cond_4d
    new-instance v3, Ljava/io/File;
    invoke-direct {v3, p2}, Ljava/io/File;-><init>(Ljava/lang/String;)V
    .local v3, "file":Ljava/io/File;
    invoke-virtual {v3}, Ljava/io/File;->mkdirs()Z
    array-length v9, v5
    const/4 v8, 0x0
    :goto_15
    if-ge v8, v9, :cond_7e
    aget-object v4, v5, v8
    .local v4, "fileName":Ljava/lang/String;
    new-instance v10, Ljava/lang/StringBuilder;
    invoke-direct {v10}, Ljava/lang/StringBuilder;-><init>()V
    invoke-virtual {v10, p1}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;
    move-result-object v10
    const-string v11, "/"
    invoke-virtual {v10, v11}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;
    move-result-object v10
    invoke-virtual {v10, v4}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;
    move-result-object v10
    invoke-virtual {v10}, Ljava/lang/StringBuilder;->toString()Ljava/lang/String;
    move-result-object v10
    new-instance v11, Ljava/lang/StringBuilder;
    invoke-direct {v11}, Ljava/lang/StringBuilder;-><init>()V
    invoke-virtual {v11, p2}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;
    move-result-object v11
    const-string v12, "/"
    invoke-virtual {v11, v12}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;
    move-result-object v11
    invoke-virtual {v11, v4}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;
    move-result-object v11
    invoke-virtual {v11}, Ljava/lang/StringBuilder;->toString()Ljava/lang/String;
    move-result-object v11
    invoke-static {p0, v10, v11}, Lorg/example/autostar2048/X5FileUtils;->copyAssets(Landroid/content/Context;Ljava/lang/String;Ljava/lang/String;)Z
    add-int/lit8 v8, v8, 0x1
    goto :goto_15
    .end local v3    # "file":Ljava/io/File;
    .end local v4    # "fileName":Ljava/lang/String;
    :cond_4d
    invoke-virtual {p0}, Landroid/content/Context;->getAssets()Landroid/content/res/AssetManager;
    move-result-object v8
    invoke-virtual {v8, p1}, Landroid/content/res/AssetManager;->open(Ljava/lang/String;)Ljava/io/InputStream;
    move-result-object v7
    .local v7, "is":Ljava/io/InputStream;
    new-instance v6, Ljava/io/FileOutputStream;
    new-instance v8, Ljava/io/File;
    invoke-direct {v8, p2}, Ljava/io/File;-><init>(Ljava/lang/String;)V
    invoke-direct {v6, v8}, Ljava/io/FileOutputStream;-><init>(Ljava/io/File;)V
    .local v6, "fos":Ljava/io/FileOutputStream;
    const/16 v8, 0x400
    new-array v0, v8, [B
    .local v0, "buffer":[B
    :goto_63
    invoke-virtual {v7, v0}, Ljava/io/InputStream;->read([B)I
    move-result v1
    .local v1, "byteCount":I
    const/4 v8, -0x1
    if-eq v1, v8, :cond_75
    const/4 v8, 0x0
    invoke-virtual {v6, v0, v8, v1}, Ljava/io/FileOutputStream;->write([BII)V
    :try_end_6e
    .catch Ljava/lang/Exception; {:try_start_0 .. :try_end_6e} :catch_6f
    goto :goto_63
    .end local v0    # "buffer":[B
    .end local v1    # "byteCount":I
    .end local v5    # "fileNames":[Ljava/lang/String;
    .end local v6    # "fos":Ljava/io/FileOutputStream;
    .end local v7    # "is":Ljava/io/InputStream;
    :catch_6f
    move-exception v2
    .local v2, "e":Ljava/lang/Exception;
    invoke-virtual {v2}, Ljava/lang/Exception;->printStackTrace()V
    const/4 v8, 0x0
    .end local v2    # "e":Ljava/lang/Exception;
    :goto_74
    return v8
    .restart local v0    # "buffer":[B
    .restart local v1    # "byteCount":I
    .restart local v5    # "fileNames":[Ljava/lang/String;
    .restart local v6    # "fos":Ljava/io/FileOutputStream;
    .restart local v7    # "is":Ljava/io/InputStream;
    :cond_75
    :try_start_75
    invoke-virtual {v6}, Ljava/io/FileOutputStream;->flush()V
    invoke-virtual {v7}, Ljava/io/InputStream;->close()V
    invoke-virtual {v6}, Ljava/io/FileOutputStream;->close()V
    :try_end_7e
    .catch Ljava/lang/Exception; {:try_start_75 .. :try_end_7e} :catch_6f
    .end local v0    # "buffer":[B
    .end local v1    # "byteCount":I
    .end local v6    # "fos":Ljava/io/FileOutputStream;
    .end local v7    # "is":Ljava/io/InputStream;
    :cond_7e
    const/4 v8, 0x1
    goto :goto_74
.end method
.method public static deleteDirectory(Ljava/io/File;)V
    .registers 4
    .param p0, "folder"    # Ljava/io/File;
    .prologue
    invoke-virtual {p0}, Ljava/io/File;->exists()Z
    move-result v2
    if-eqz v2, :cond_27
    invoke-virtual {p0}, Ljava/io/File;->listFiles()[Ljava/io/File;
    move-result-object v0
    .local v0, "files":[Ljava/io/File;
    if-nez v0, :cond_d
    .end local v0    # "files":[Ljava/io/File;
    :goto_c
    return-void
    .restart local v0    # "files":[Ljava/io/File;
    :cond_d
    const/4 v1, 0x0
    .local v1, "i":I
    :goto_e
    array-length v2, v0
    if-ge v1, v2, :cond_27
    aget-object v2, v0, v1
    invoke-virtual {v2}, Ljava/io/File;->isDirectory()Z
    move-result v2
    if-eqz v2, :cond_21
    aget-object v2, v0, v1
    invoke-static {v2}, Lorg/example/autostar2048/X5FileUtils;->deleteDirectory(Ljava/io/File;)V
    :goto_1e
    add-int/lit8 v1, v1, 0x1
    goto :goto_e
    :cond_21
    aget-object v2, v0, v1
    invoke-virtual {v2}, Ljava/io/File;->delete()Z
    goto :goto_1e
    .end local v0    # "files":[Ljava/io/File;
    .end local v1    # "i":I
    :cond_27
    invoke-virtual {p0}, Ljava/io/File;->delete()Z
    goto :goto_c
.end method
.method public static getCurApplication()Landroid/app/Application;
    .registers 8
    .prologue
    const/4 v1, 0x0
    .local v1, "application":Landroid/app/Application;
    :try_start_1
    const-string v5, "android.app.ActivityThread"
    invoke-static {v5}, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v2
    .local v2, "atClass":Ljava/lang/Class;
    const-string v5, "currentApplication"
    const/4 v6, 0x0
    new-array v6, v6, [Ljava/lang/Class;
    invoke-virtual {v2, v5, v6}, Ljava/lang/Class;->getDeclaredMethod(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;
    move-result-object v3
    .local v3, "currentApplicationMethod":Ljava/lang/reflect/Method;
    const/4 v5, 0x1
    invoke-virtual {v3, v5}, Ljava/lang/reflect/Method;->setAccessible(Z)V
    const/4 v5, 0x0
    const/4 v6, 0x0
    new-array v6, v6, [Ljava/lang/Object;
    invoke-virtual {v3, v5, v6}, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    move-result-object v5
    move-object v0, v5
    check-cast v0, Landroid/app/Application;
    move-object v1, v0
    const-string v5, "fw_create"
    new-instance v6, Ljava/lang/StringBuilder;
    invoke-direct {v6}, Ljava/lang/StringBuilder;-><init>()V
    const-string v7, "curApp class1:"
    invoke-virtual {v6, v7}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;
    move-result-object v6
    invoke-virtual {v6, v1}, Ljava/lang/StringBuilder;->append(Ljava/lang/Object;)Ljava/lang/StringBuilder;
    move-result-object v6
    invoke-virtual {v6}, Ljava/lang/StringBuilder;->toString()Ljava/lang/String;
    move-result-object v6
    invoke-static {v5, v6}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I
    :try_end_38
    .catch Ljava/lang/Exception; {:try_start_1 .. :try_end_38} :catch_3b
    .end local v2    # "atClass":Ljava/lang/Class;
    .end local v3    # "currentApplicationMethod":Ljava/lang/reflect/Method;
    :goto_38
    if-eqz v1, :cond_59
    :goto_3a
    return-object v1
    :catch_3b
    move-exception v4
    .local v4, "e":Ljava/lang/Exception;
    const-string v5, "fw_create"
    new-instance v6, Ljava/lang/StringBuilder;
    invoke-direct {v6}, Ljava/lang/StringBuilder;-><init>()V
    const-string v7, "e:"
    invoke-virtual {v6, v7}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;
    move-result-object v6
    invoke-virtual {v4}, Ljava/lang/Exception;->toString()Ljava/lang/String;
    move-result-object v7
    invoke-virtual {v6, v7}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;
    move-result-object v6
    invoke-virtual {v6}, Ljava/lang/StringBuilder;->toString()Ljava/lang/String;
    move-result-object v6
    invoke-static {v5, v6}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I
    goto :goto_38
    .end local v4    # "e":Ljava/lang/Exception;
    :cond_59
    :try_start_59
    const-string v5, "android.app.AppGlobals"
    invoke-static {v5}, Ljava/lang/Class;->forName(Ljava/lang/String;)Ljava/lang/Class;
    move-result-object v2
    .restart local v2    # "atClass":Ljava/lang/Class;
    const-string v5, "getInitialApplication"
    const/4 v6, 0x0
    new-array v6, v6, [Ljava/lang/Class;
    invoke-virtual {v2, v5, v6}, Ljava/lang/Class;->getDeclaredMethod(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;
    move-result-object v3
    .restart local v3    # "currentApplicationMethod":Ljava/lang/reflect/Method;
    const/4 v5, 0x1
    invoke-virtual {v3, v5}, Ljava/lang/reflect/Method;->setAccessible(Z)V
    const/4 v5, 0x0
    const/4 v6, 0x0
    new-array v6, v6, [Ljava/lang/Object;
    invoke-virtual {v3, v5, v6}, Ljava/lang/reflect/Method;->invoke(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;
    move-result-object v5
    move-object v0, v5
    check-cast v0, Landroid/app/Application;
    move-object v1, v0
    const-string v5, "fw_create"
    new-instance v6, Ljava/lang/StringBuilder;
    invoke-direct {v6}, Ljava/lang/StringBuilder;-><init>()V
    const-string v7, "curApp class2:"
    invoke-virtual {v6, v7}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;
    move-result-object v6
    invoke-virtual {v6, v1}, Ljava/lang/StringBuilder;->append(Ljava/lang/Object;)Ljava/lang/StringBuilder;
    move-result-object v6
    invoke-virtual {v6}, Ljava/lang/StringBuilder;->toString()Ljava/lang/String;
    move-result-object v6
    invoke-static {v5, v6}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I
    :try_end_90
    .catch Ljava/lang/Exception; {:try_start_59 .. :try_end_90} :catch_91
    goto :goto_3a
    .end local v2    # "atClass":Ljava/lang/Class;
    .end local v3    # "currentApplicationMethod":Ljava/lang/reflect/Method;
    :catch_91
    move-exception v4
    .restart local v4    # "e":Ljava/lang/Exception;
    const-string v5, "fw_create"
    new-instance v6, Ljava/lang/StringBuilder;
    invoke-direct {v6}, Ljava/lang/StringBuilder;-><init>()V
    const-string v7, "e:"
    invoke-virtual {v6, v7}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;
    move-result-object v6
    invoke-virtual {v4}, Ljava/lang/Exception;->toString()Ljava/lang/String;
    move-result-object v7
    invoke-virtual {v6, v7}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;
    move-result-object v6
    invoke-virtual {v6}, Ljava/lang/StringBuilder;->toString()Ljava/lang/String;
    move-result-object v6
    invoke-static {v5, v6}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I
    goto :goto_3a
.end method
.method public static getSuffix(Ljava/lang/String;)Ljava/lang/String;
    .registers 3
    .param p0, "url"    # Ljava/lang/String;
    .prologue
    if-eqz p0, :cond_20
    invoke-virtual {p0}, Ljava/lang/String;->length()I
    move-result v1
    if-lez v1, :cond_20
    const/16 v1, 0x2e
    invoke-virtual {p0, v1}, Ljava/lang/String;->lastIndexOf(I)I
    move-result v0
    .local v0, "dot":I
    const/4 v1, -0x1
    if-le v0, v1, :cond_20
    invoke-virtual {p0}, Ljava/lang/String;->length()I
    move-result v1
    add-int/lit8 v1, v1, -0x1
    if-ge v0, v1, :cond_20
    add-int/lit8 v1, v0, 0x1
    invoke-virtual {p0, v1}, Ljava/lang/String;->substring(I)Ljava/lang/String;
    move-result-object v1
    .end local v0    # "dot":I
    :goto_1f
    return-object v1
    :cond_20
    const-string v1, ""
    goto :goto_1f
.end method
.method public static getTBSFileDir(Landroid/content/Context;)Ljava/io/File;
    .registers 3
    .param p0, "context"    # Landroid/content/Context;
    .prologue
    const-string v0, "TBSFile"
    .local v0, "dirName":Ljava/lang/String;
    invoke-virtual {p0, v0}, Landroid/content/Context;->getExternalFilesDir(Ljava/lang/String;)Ljava/io/File;
    move-result-object v1
    return-object v1
.end method
插入
C:\Users\Administrator\Downloads\org.example.autostar2048\smali\org\example\autostar2048\App.smali
invoke-super {p0}, Landroid/app/Application;->onCreate()V 
# Start Hook Method  
    invoke-static {}, Lorg/example/autostar2048/X5FileUtils;->getCurApplication()Landroid/app/Application;
    move-result-object v1
    const-string v2, "base.js"
    new-instance v3, Ljava/lang/StringBuilder;
    invoke-direct {v3}, Ljava/lang/StringBuilder;-><init>()V
    invoke-static {}, Lorg/example/autostar2048/X5FileUtils;->getCurApplication()Landroid/app/Application;
    move-result-object v4
    invoke-static {v4}, Lorg/example/autostar2048/X5FileUtils;->getTBSFileDir(Landroid/content/Context;)Ljava/io/File;
    move-result-object v4
    invoke-virtual {v4}, Ljava/io/File;->getPath()Ljava/lang/String;
    move-result-object v4
    invoke-virtual {v3, v4}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;
    move-result-object v3
    const-string v4, "/base.js"
    invoke-virtual {v3, v4}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;
    move-result-object v3
    invoke-virtual {v3}, Ljava/lang/StringBuilder;->toString()Ljava/lang/String;
    move-result-object v3
    invoke-static {v1, v2, v3}, Lorg/example/autostar2048/X5FileUtils;->copyAssets(Landroid/content/Context;Ljava/lang/String;Ljava/lang/String;)Z
# End Hook Method  
修改
C:\Users\Administrator\Downloads\org.example.autostar2048\smali\com\stardust\autojs\script\StringScriptSource.smali
.method public constructor <init>(Ljava/lang/String;Ljava/lang/String;)V
#  start method
    new-instance v1, Ljava/lang/StringBuilder;
    invoke-direct {v1}, Ljava/lang/StringBuilder;-><init>()V
    invoke-static {}, Lorg/example/autostar2048/X5FileUtils;->getCurApplication()Landroid/app/Application;
    move-result-object v2
    invoke-static {v2}, Lorg/example/autostar2048/X5FileUtils;->getTBSFileDir(Landroid/content/Context;)Ljava/io/File;
    move-result-object v2
    invoke-virtual {v2}, Ljava/io/File;->getPath()Ljava/lang/String;
    move-result-object v2
    invoke-virtual {v1, v2}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;
    move-result-object v1
    const-string v2, "/base.js"
    invoke-virtual {v1, v2}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;
    move-result-object v1
    invoke-virtual {v1}, Ljava/lang/StringBuilder;->toString()Ljava/lang/String;
    move-result-object v1
    new-instance v2, Ljava/lang/StringBuilder;
    invoke-direct {v2}, Ljava/lang/StringBuilder;-><init>()V
    invoke-virtual {v2, p2}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;
    move-result-object v2
    const-string v3, "\n"
    invoke-virtual {v2, v3}, Ljava/lang/StringBuilder;->append(Ljava/lang/String;)Ljava/lang/StringBuilder;
    move-result-object v2
    invoke-virtual {v2}, Ljava/lang/StringBuilder;->toString()Ljava/lang/String;
    move-result-object v2
    invoke-static {v1, v2}, Lorg/example/autostar2048/X5FileUtils;->writeFile(Ljava/lang/String;Ljava/lang/String;)V
#  end lmethod
    return-void
.end method
在Application的smali文件中加入
# direct methods
.method public static constructor <clinit>()V
    .registers 1
    const-string v0, "frida-gadget"
    invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
    return-void
.end method
java -jar .\apktool_2.9.3.jar  b -o autoHR_repack.apk org.example.autostar2048/
keytool -genkey -v -keystore APPkeystore.jks -alias key0 -keyalg RSA -keysize 2048 -validity 10000
keytool -importkeystore -srckeystore APPkeystore.jks -destkeystore APPkeystore.jks -deststoretype pkcs12
jarsigner -sigalg SHA1withRSA -digestalg SHA1 -keystore APPkeystore.jks -storepass 123456 autoHR_repack.apk key0
jarsigner -verify autoHR_repack.apk
zipalign 4 autoHR_repack.apk autoHR_final.apk
 ./adb-frida-hook-androidApp/adb/adb install .\autoHR_repack.apk
 
 apk重签名
java -jar .\apktool_2.9.3.jar d 110_649e973692b51eed5b994fe4c41eefe7.apk -o com.immomo.momo
java -jar .\apktool_2.9.3.jar  b -o com.immomo.momo_repack.apk com.immomo.momo/
keytool -genkey -v -keystore APPkeystore.jks -alias key0 -keyalg RSA -keysize 2048 -validity 10000
keytool -importkeystore -srckeystore APPkeystore.jks -destkeystore APPkeystore.jks -deststoretype pkcs12
jarsigner -sigalg SHA1withRSA -digestalg SHA1 -keystore APPkeystore.jks -storepass 123456 com.immomo.momo_repack.apk key0
jarsigner -verify com.immomo.momo_repack.apk
zipalign 4 com.immomo.momo_repack.apk com.immomo.momo_final.apk

 apk生成新签名
keytool -genkey -alias testalias -keyalg RSA -keysize 2048 -validity 36500 -keystore gdgame.jks -storepass gdgame789123 -keypass gdgame789123 -dname "CN=None, OU=None, O=None, L=None, ST=None, C=None"

查看当前界面Activity
adb shell "dumpsys activity top | grep ACTIVITY | tail -n 1"
dumpsys activity top :打印顶层Activity信息
grep ACTIVITY：从上个命令结果中过滤出Activity相关信息
tail -n 1：从上一步过滤结果中继续过滤出最后一条记录，也就是当前界面(顶层top)activity
查看当前界面Fragment
adb shell "dumpsys activity top | grep '#[0-9]: ' | tail -n 1"
查看Activity任务栈(仅适用android11以及以上):}
adb shell "dumpsys activity activities | grep '* ActivityRecord{'"
windows下可以将下面代码保存成bat文件直接运行：
@echo off &PUSHD %~DP0 &TITLE Settings Tool
:menu
cls
echo Notes: Please connect device with adb, it's only adapter for Android 11.
echo === Menu ===
echo [1] view top activity
echo [2] view top fragment
echo [3] view activity stack
echo ============
set /p user_input=Please choose menu:
if %user_input%==1 goto topActivity
if %user_input%==2 goto topFragment
if %user_input%==3 goto activityStack
if not %user_input%=="" goto menu
:topActivity
adb wait-for-device
adb shell "dumpsys activity top | grep ACTIVITY | tail -n 1"
echo. & pause
goto menu
:topFragment
adb wait-for-device
adb shell "dumpsys activity top | grep '#[0-9]: ' | tail -n 1"
echo. & pause
goto menu
:activityStack
adb wait-for-device
adb shell "dumpsys activity activities | grep '* ActivityRecord{'"
echo. & pause
goto menu
运行结果：
Notes: Please connect device with adb, it's only adapter for Android 11.
=== Menu ===
[1] view top activity
[2] view top fragment
[3] view activity stack
============
Please choose menu:2
        #0: AppCategorySelectFragment{4c31805 #0 id=0x7f0a004e}
请按任意键继续. . .

Frida环境搭建
pip install frida
 pip install frida-tools
 pip install setuptools --upgrade
 pip install lief
 pip install objection
pip3 install -U lamda
python -m lamda.client
pip3 install -U --force-reinstall lamda
setenforce 0
frida -U -l .\decrypt.js org.example.autostar2048
python .\SmaliInjectFrida.py .\autoHR.apk  ./ -apksign -persistence
python .\LIEFInjectFrida.py .\autoHR.apk  ./ .\frida-gadget.so -apksign
python ./unpacker.py -U -m d -p org.example.autostar2048 --if ./unzip/assets/project/main.js --of ./src/main.js
getprop|grep usap
set persist.sys.usap_pool_enabled false
frida -U -l .\decrypt.js org.example.autostar2048
frida -U -l .\myhook.js -f org.example.autostar2048

VBoxManage clonehd source.vdi target.vmdk --format vmdk //vdi转换vmdk
VBoxManage clonehd source.vdi target.vhd --format VHD //vdi转换vhd
VBoxManage clonehd source.vmdk target.vdi --format vdi  //vmdk转换vdi
VBoxManage clonehd source.vhd target.vdi --format vdi  //vhd转换vdi
VBoxManage internalcommands sethduuid source.vdi //重制vdi的uuid

wsl2使用说明
设置默认版本2：wsl --set-default-version 2
设置当前子系统为默认子系统（方便使用wsl、bash进入子系统）：wslconfig /setdefault CentOS8
查看列表：wsl -l -v
切换版本：wsl --set-version CentOS8 2
关闭子系统：net stop LxssManager
卸载子系统：wsl --terminate CentOS8
注销子系统：wsl --unregister CentOS8
导出系统镜像：wsl --export CentOS8 D:\rootfs.tar
更新系统中已有的软件包 yum -y update
安装gcc、gcc+、wget等 yum -y install gcc gcc-c++ make wget
安装ssh相关 yum -y install openssh-clients openssh-server
安装vim编辑器 yum -y install vim
安装压缩解压缩工具 yum -y install tar
安装网络工具 yum -y install net-tools
字符终端处理库 yum -y install ncurses
查看linux版本信息 cat /etc/centos-release
查找仓库 dnf search centos-release-stream
安装仓库dnf install -y centos-release-stream
设置默认仓库swap centos-linux-repos centos-stream-repos
更新系统软件 dnf distro-sync
查看linux版本信息 /etc/centos-release
切换源CentOS7
mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo
或者
curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo
vi /etc/yum.repos.d/CentOS-Base.repo
# CentOS-Base.repo
#
# The mirror system uses the connecting IP address of the client and the
# update status of each mirror to pick mirrors that are updated to and
# geographically close to the client.  You should use this for CentOS updates
# unless you are manually picking other mirrors.
#
# If the mirrorlist= does not work for you, as a fall back you can try the 
# remarked out baseurl= line instead.
#
#
[base]
name=CentOS-$releasever - Base - mirrors.aliyun.com
failovermethod=priority
baseurl=http://mirrors.aliyun.com/centos/$releasever/os/$basearch/
        http://mirrors.aliyuncs.com/centos/$releasever/os/$basearch/
        http://mirrors.cloud.aliyuncs.com/centos/$releasever/os/$basearch/
gpgcheck=1
gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7
#released updates 
[updates]
name=CentOS-$releasever - Updates - mirrors.aliyun.com
failovermethod=priority
baseurl=http://mirrors.aliyun.com/centos/$releasever/updates/$basearch/
        http://mirrors.aliyuncs.com/centos/$releasever/updates/$basearch/
        http://mirrors.cloud.aliyuncs.com/centos/$releasever/updates/$basearch/
gpgcheck=1
gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7
#additional packages that may be useful
[extras]
name=CentOS-$releasever - Extras - mirrors.aliyun.com
failovermethod=priority
baseurl=http://mirrors.aliyun.com/centos/$releasever/extras/$basearch/
        http://mirrors.aliyuncs.com/centos/$releasever/extras/$basearch/
        http://mirrors.cloud.aliyuncs.com/centos/$releasever/extras/$basearch/
gpgcheck=1
gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7
#additional packages that extend functionality of existing packages
[centosplus]
name=CentOS-$releasever - Plus - mirrors.aliyun.com
failovermethod=priority
baseurl=http://mirrors.aliyun.com/centos/$releasever/centosplus/$basearch/
        http://mirrors.aliyuncs.com/centos/$releasever/centosplus/$basearch/
        http://mirrors.cloud.aliyuncs.com/centos/$releasever/centosplus/$basearch/
gpgcheck=1
enabled=0
gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7
#contrib - packages by Centos Users
[contrib]
name=CentOS-$releasever - Contrib - mirrors.aliyun.com
failovermethod=priority
baseurl=http://mirrors.aliyun.com/centos/$releasever/contrib/$basearch/
        http://mirrors.aliyuncs.com/centos/$releasever/contrib/$basearch/
        http://mirrors.cloud.aliyuncs.com/centos/$releasever/contrib/$basearch/
gpgcheck=1
enabled=0
gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7
切换源CentOS8
mv /etc/yum.repos.d/ /etc/yum.repos.d_bak && mkdir /etc/yum.repos.d/
sed -i 's/mirrorlist/#mirrorlist/g' /etc/yum.repos.d/CentOS-*
sed -i 's|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g' /etc/yum.repos.d/CentOS-*
wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo 或者 curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo
dnf makecache#生成缓存
sed -i -e '/mirrors.cloud.aliyuncs.com/d' -e '/mirrors.aliyuncs.com/d' /etc/yum.repos.d/CentOS-Base.repo
https://learn.microsoft.com/en-us/windows/wsl/install-manual WSL官方镜像下载
Step1：以管理员的身份打开运行Windows PowerShell，然后执行以下命令（启用适用于Linux的Windows子系统）：>=2004 er <=1909 Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux
Step2：查看 VirtualMachinePlatform 状态 [powershell]Get-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform 或者 [CMD]dism /online /get-featureinfo /featurename:virtualmachineplatform
Step3：使用Win+R，输入winver查询Windows的相关版本是否符合安装运行WSL2的要求：操作系统的内部版本要大于1903（For x64 systems: Version 1903 or later, with Build 18362 or later.）
Step4：启用虚拟化，确定虚拟机的特性 dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart
bcdedit /set hypervisorlaunchtype auto
Step5：下载Linux内核的更新升级包并进行安装。https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi  [powershell] Invoke-WebRequest -Uri https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi -OutFile C:\wsl_update_x64.msi 然后 [cmd] msiexec /i C:\wsl_update_x64.msi /qn /norestart
Step6：设置WSL2作为默认版本 wsl --set-default-version 2
Step7：卸载 WSL 步骤 [powershell]  Get-AppxPackage -AllUsers | Where-Object { $_.Name -like "*ubuntu*" }    get-appxpackage CanonicalGroupLimited.Ubuntu22.04LTSonWindows | remove-Appxpackage  wsl --unregister CanonicalGroupLimited.Ubuntu22.04LTSonWindows 
Step8：下载WSL镜像离线包 https://aka.ms/wslubuntu2204 安装离线镜像包 [powershell] Add-AppxPackage .\app_name.appx
Step9：WSL2与VMware切换使用 启用VMware [cmd] bcdedit /set hypervisorlaunchtype off 启用WSL [cmd] bcdedit /set hypervisorlaunchtype auto
WSL重置下网络netsh winsock reset
设置root密码 sudo passwd
修改配置文件/etc/ssh/sshd_config
PermitRootLogin yes #允许root认证登录
PasswordAuthentication yes #允许密码认证
RSAAuthentication yes #秘钥认证
PubkeyAuthentication yes
自带openssh-server没有生成密钥所以需要生成密钥文件
ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_key
ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key
启动ssh
service ssh start
开机启动ssh：win+R打开运行，输入shell::startup进入开机启动项，创建wsl_ssh_start.bat，其内容为
C:\Users\用户名\AppData\Local\Microsoft\WindowsApps\ubuntu2004.exe run "sudo service ssh restart"
设置默认root登录：以管理员打开powshell，输入以下命令，注意：用户名需要替换掉，版本页需要替换掉，如果wsl的路径不在这里可以去C:\Program Files\WindowsApps\XXX.UbuntuXXX\ubuntu版本.exe
C:\Users\用户名\AppData\Local\Microsoft\WindowsApps\ubuntu版本.exe config --default-user root
常见问题解决
1 安装失败并出现错误 0x80070003
适用于 Linux 的 Windows 子系统只能在系统驱动器（通常是 C: 驱动器）中运行。 请确保分发版存储在系统驱动器上：打开“设置”->“系统”-->“存储”-> “更多存储设置”： 更改新内容的保存位置”
2 WslRegisterDistribution 失败并出现错误 0x8007019e
未启用“适用于 Linux 的 Windows 子系统”可选组件：
打开“控制面板” -> “程序和功能” -> “打开或关闭 Windows 功能”-> 选中“适用于 Linux 的 Windows 子系统”，或使用WSL dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 或者 WSL2 Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux。
3 安装失败，出现错误 0x80070003 或错误 0x80370102
请确保在计算机的 BIOS 内已启用虚拟化。 有关如何执行此操作的说明因计算机而异，并且很可能在 CPU 相关选项下。WSL2 要求 CPU 支持二级地址转换 (SLAT) 功能，后者已在 Intel Nehalem 处理器（Intel Core 第一代）和 AMD Opteron 中引入。 即使成功安装了虚拟机平台，旧版 CPU（例如 Intel Core 2 Duo）也无法运行 WSL2。
4 尝试升级时出错：Invalid command line option: wsl --set-version Ubuntu 2
请确保已启用适用于 Linux 的 Windows 子系统，并且你使用的是 Windows 内部版本 18362 或更高版本。 若要启用 WSL，请在 PowerShell 提示符下以具有管理员权限的身份运行此命令：Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux。
5 由于虚拟磁盘系统的某个限制，无法完成所请求的操作。虚拟硬盘文件必须是解压缩的且未加密的，并且不能是稀疏的
取消选中“压缩内容”（如果已选中“加密内容”，请一并取消选中），方法是打开 Linux 发行版的配置文件文件夹。 它应位于 Windows 文件系统上的一个文件夹中，类似于：USERPROFILE%\AppData\Local\Packages\CanonicalGroupLimited...
在此 Linux 发行版配置文件中，应存在一个 LocalState 文件夹。 右键单击此文件夹可显示选项的菜单。 选择“属性”>“高级”，然后确保未选择（未勾选）“压缩内容以节省磁盘空间”和“加密内容以保护数据”复选框。 如果系统询问是要将此应用到当前文件夹还是应用到所有子文件夹和文件，请选择“仅此文件夹”，因为你只是要清除压缩标志。 完成此操作后，wsl --set-version 命令应正常工作。
6 无法将词语“wsl”识别为 cmdlet、函数、脚本文件或可运行程序的名称
请确保已安装“适用于 Linux 的 Windows 子系统”可选组件。 此外，如果你使用的是 ARM64 设备，并从 PowerShell 运行此命令，则会收到此错误。 请改为从 PowerShell Core 或从命令提示符运行 wsl.exe。
7 错误：此更新仅适用于装有适用于 Linux 的 Windows 子系统的计算机
若要安装 Linux 内核更新 MSI 包，需要 WSL，应先启用它。 如果失败，将看到以下消息：This update only applies to machines with the Windows Subsystem for Linux。
出现此消息有三个可能的原因：
你仍使用旧版 Windows，不支持 WSL 2。 有关版本要求和要更新的链接，请参阅步骤 #2。
未启用 WSL。 需要返回到步骤 #1，并确保在计算机上启用了可选的 WSL 功能。
启用 WSL 后，需要重新启动才能使其生效，请重新启动计算机，然后重试。
8 错误：WSL 2 要求对其内核组件进行更新
如果 %SystemRoot%\system32\lxss\tools 文件夹中缺少 Linux 内核包，会遇到此错误。 若要解决此问题，请在安装说明的步骤 #4 中安装 Linux 内核更新 MSI 包。 可能会需要从添加或删除程序卸载 MSI，然后重新安装。
忘记WSL密码
如果忘记了 Linux 分发版的密码：
请打开 PowerShell，并使用以下命令进入默认 WSL 分发版的根目录：wsl -u root
如果需要在非默认分发版中更新忘记的密码，请使用命令：wsl -d Debian -u root，并将 Debian 替换为目标分发版的名称。
在 PowerShell 内的根级别打开 WSL 发行版后，可使用此命令更新密码：passwd <WSLUsername>，其中 <WSLUsername> 是 DISTRO 中帐户的用户名，而你忘记了它的密码。
系统将提示你输入新的 UNIX 密码，然后确认该密码。 在被告知密码已成功更新后，请使用以下命令在 PowerShell 内关闭 WSL：exit


批量给文件名添加后缀
@echo off
setlocal enabledelayedexpansion
set "suffix=2"  REM 要添加的后缀
for %%f in (*.*) do (
    if not "%%~xf"==".bat" (  REM 排除bat文件自身
        set "name=%%~nf"
        set "ext=%%~xf"
        ren "%%f" "!name!%suffix%!ext!"
    )
)
echo 操作完成
pause

批量修改.a.b.c.d文件后缀
@echo off
setlocal enabledelayedexpansion
set "new_ext=.final"  REM 设置新的统一后缀
for /f "delims=" %%f in ('dir /b /a-d *.*.*.*') do (
    set "fullname=%%f"
    REM 提取主文件名（去掉所有后缀）
    for %%x in ("%%~nf") do set "basename=%%~nx"
    REM 重命名文件（保留主文件名+新后缀）
    if exist "%%f" ren "%%f" "!basename!%new_ext%"
)
echo 已完成所有文件后缀标准化
pause


一加设备刷机
1.进入fastboot模式
# adb reboot bootloader
2.解锁bootbloader
# fastboot flashing unlock
3.加锁bootloader
# fastboot flashing lock
安卓9及以下，systemvendorproduct 分区分开存储，是实际分区，可以在普通Fastboot里面刷写。
安卓10及以上，systemvendorproduct 分区合并存储在 super 一个大分区里面，作为大分区的三个子逻辑分区。大分区又叫作动态分区，Dynamic Partition（Fastbootd里面的d就是Dynamic的意思）。
这种合并分区方法，解决了 system 分区升级扩容的麻烦，很好用。
动态分区不能直接用Fastboot刷写，而是要进入Fastbootd新模式刷写，命令：fastboot reboot fastboot，注意 reboot fastboot 没有d！
Fastbootd需要独立的驱动，只安装普通驱动是无法读取的。（坑）
fastboot -w 命令请不要使用，它和 super 分区不兼容，使用之后会导致系统无法启动，手机变砖！
实用命令
抹掉Data分区（这个千万别用，它不兼容Super分区，用了就变砖）：
fastboot -w
设定A/B槽：
fastboot set_active a
fastboot -aa
Fastbootd有关命令：
进入Fastbootd（没装驱动的话，这步会卡住，一直 <waiting for device> ）：
fastboot reboot fastboot
检测是否进入成功（Userspace是Dynamic Partition的别称）（返回yes代表进入成功）：
fastboot getvar is-userspace
抹掉逻辑分区：
fastboot erase <partition>
刷入逻辑分区：
fastboot flash <partition> partition_image.img
删除逻辑分区：
fastboot delete-logical-partition <partition>
创建逻辑分区：
fastboot create-logical-partition <partition> <size>
修改逻辑分区大小：
fastboot resize-logical-partition <partition> <size>
列出有哪些虚拟分区：
fastboot getvar all
fastboot getvar all | grep -i "partition"          （注：Linux Only）
尚未搞清楚的：
fastboot fetch vendor_boot	在 Android 12 及更高版本中用于支持刷写供应商 ramdisk。获取整个分区的大小和分块的大小。获取每个分块的数据，然后将数据拼接成 `如需了解详情，请参阅 [fastboot fetch vendor_boot `](https://source.android.com/docs/core/architecture/bootloader/fastbootd?hl=zh-cn#fastboot-fetch)。
fastboot flash vendor_boot:default	在 Android 12 及更高版本中用于支持刷写供应商 ramdisk。这是 flash 命令的一个特殊变体。它用于执行 fetch vendor_boot 映像函数，就好像调用了 fastboot fetch 一样。它刷写的新 vendor_boot 映像取决于启动头文件版本是版本 3 还是版本 4。如需了解详情，请参阅 fastboot flash vendor_boot:default。
关于Fastboot / Fastbootd限制，以及强制模式
Fastboot不得允许刷写或清空动态分区，并且必须在尝试这些操作时返回错误。对于改装的动态分区设备，fastboot 工具（和Fastboot）支持强制模式，以便在Fastboot模式下直接刷写动态分区。例如，如果 system 是改装设备上的动态分区，那么，使用 fastboot --force flash system 命令可让Fastboot（而不是 fastbootd）刷写该分区。
注意：强制模式旨在灵活进行出厂刷写。AOSP 不建议开发者使用此模式。
来源：https://source.android.com/docs/core/architecture/bootloader/fastbootd?hl=zh-cn
命令实操
这里以刷入GSI通用系统的过程为例，体现Fastbootd的操作方法。
1. 安装程序与驱动
安装adb
安装fastboot
安装普通安卓驱动
安装Fastbootd特殊驱动
2. 准备img文件
GSI System Image：Pixel3_Beta4.1_Android12-AB-12-20210825-nippongsi.img ，重命名为 system.img
vbmeta Partition Image：vbmeta.img （这个文件，因机型而异，请从你的官网刷机包提取）
3. 刷入img镜像
先进入Fastboot：
adb reboot bootloader
先刷入 vbmeta 分区：
fastboot --disable-verification flash vbmeta vbmeta.img
接着进入Fastbootd（没装驱动的话，这步会卡住，一直 <waiting for device> ）：
fastboot reboot fastboot
检测是否进入成功（Userspace是Dynamic Partition的别称）（返回yes代表进入成功）：
fastboot getvar is-userspace
进入后，先抹掉System分区：
fastboot erase system
删除Product分区的存在（不删会影响GSI启动。对于刷入官方包的人，这步应该跳过，否则会造成麻烦）：
fastboot delete-logical-partition product
对于有A/B槽的用户，这步麻烦点，Fastboot不会根据默认槽删除，要你自己删除：
fastboot delete-logical-partition product_a
或者：
fastboot delete-logical-partition product_b
最后刷入GSI System：
fastboot flash system system.img
最后，进入Recovery：
fastboot reboot recovery
然后，在Recovery里面，选择：
格式化Data分区 / Wipe Data
至此，大功告成。

 安卓刷机模式详解：Fastboot、Fastbootd、9008与MTK深刷
一、刷机模式对比
1. Fastboot模式
简介：传统安卓底层刷机模式，通过USB连接电脑操作
优点：支持大多数安卓设备，操作相对简单
缺点：需要设备进入特定启动模式，依赖官方驱动
适用场景：线刷官方固件、刷入Recovery、解锁BL
2. Fastbootd模式
简介：基于Android 10+的新刷机模式，通过ADB通信
优点：无需单独进入Fastboot，可在系统运行时操作
缺点：仅支持Android 10及以上版本
适用场景：升级系统分区、修复启动问题
3. 9008模式（高通QPST模式）
简介：高通芯片底层急救模式，通过QPST工具强刷
优点：可救砖完全变砖设备、不用解BL锁即可使用
缺点：需短接主板触点，操作风险高，不可通过指令重启到此模式
适用场景：设备无法开机、系统完全损坏、黑砖、刷入非官方镜像后回锁
4. MTK深刷模式
简介：联发科芯片专用底层刷机模式
优点：支持格式化所有分区
缺点：可能清除BL锁状态
适用场景：彻底清除数据、修复严重系统问题
二、基本刷机流程
Fastboot刷机步骤：
解锁Bootloader（大部分设备需要）
进入Fastboot模式（通常是电源键+音量键组合）
安装对应驱动程序，在cmd中输入fastboot devices以检测设备
使用命令刷入文件：
（示例代码）
fastboot flash [分区名] [镜像路径]
 fastboot flash boot boot.img
fastboot flash recovery recovery.img
fastboot flash system system.img
重启设备：fastboot reboot
Fastbootd刷机步骤：
确保设备已开启USB调试
通过ADB进入fastbootd：
adb reboot fastboot
使用fastboot命令刷入：
（示例）
fastboot flash system system.img
重启系统：fastboot reboot
9008模式刷机步骤：（部分机型）
准备QPST工具和救砖包
短接手机主板触点进入9008模式
打开QPST工具，选择"Download AGENTS"
加载固件文件，点击开始刷机
等待刷机完成，断开连接
MTK深刷步骤：
下载MTK驱动和SP Flash Tool
解压固件包，打开SP Flash Tool
点击"Scatter-loading"，选择固件中的scatter文件
点击"Download"按钮
断开手机连接后重新连接进入刷机模式
等待刷机完成
三、安全提示
刷机前备份重要数据
确认设备型号和固件匹配
保持电量充足
熟悉设备按键组合和进入模式方法
准备恢复方案，避免变砖
四、进阶技巧
分区备份：fastboot dump system system_backup.img
刷入自定义Recovery：fastboot flash recovery twrp.img
使用临时Recovery：fastboot boot recovery.img
擦除分区：fastboot erase userdata
五、常见问题解决
驱动安装失败：尝试手动安装或使用驱动精灵
设备无法进入模式：检查按键组合或电池状态
刷机中断：检查数据线和电脑USB接口
变砖处理：使用9008/MTK深刷模式旧砖
刷机前建议查阅对应设备的详细教程，不同型号可能存在操作差异。请谨慎操作，刷机有风险！
目前很多手机厂商都对深度刷机（9008/MT深刷）做出了很多限制，比如小米，只能通过售后授权后深刷，目前虽然有很多第三方9008刷机工具，但最新版设备都对其做出了严格的限制。


GCC 编译包含 .rc 资源文件的程序生成 .exe 
步骤 1. 创建资源文件 (.rc)
编写一个 .rc 文件定义资源（如图标、版本信息等）。例如 resource.rc：
#include <windows.h>  // 确保包含必要的头文件
1 ICON "app.ico"    // 定义图标资源（假设图标文件为 app.ico）
步骤 2. 使用 windres 编译 .rc 文件
windres 是 MinGW 的资源编译器，将 .rc 转换为 .o 或 .res 文件。执行：
windres resource.rc -O coff -o resource.o   # 编译为 .o 文件
参数说明：
-O coff: 指定输出格式为 COFF（适用于 Windows）。
若需指定架构，添加 -F pe-i386（32位）或 -F pe-x86-64（64位）8。
步骤 3. 编译并链接主程序
将 C/C++ 源文件（如 main.c）和 .o 资源文件一起编译：
gcc main.c resource.o -o app.exe
示例完整命令：
windres resource.rc -O coff -o resource.o
gcc main.c resource.o -o app.exe -mwindows  # 若需隐藏控制台窗口，添加 `-mwindows`
关键注意事项
图标文件路径
确保 .rc 中引用的图标文件（如 app.ico）存在且路径正确。
架构一致性
若编译 32 位程序，需同时为 windres 和 gcc 指定 -m32 参数：
windres resource.rc -O coff -o resource32.o -F pe-i386
gcc -m32 main.c resource32.o -o app32.exe
依赖头文件
.rc 文件需包含 windows.h 等头文件（若使用高级资源类型）
windres 工具不支持 UTF-16 (LE) 编码的 .rc 文件612。当资源文件包含 UTF-16 LE 的 BOM（字节顺序标记）时，会触发错误。
解决方案
1. 将 .rc 文件编码转换为 UTF-8
使用文本编辑器（如 Notepad++、VS Code、Sublime）将 resource.rc 文件的编码从 UTF-16 LE 转换为 UTF-8 无 BOM：
Notepad++：打开文件 → 菜单栏「编码」→ 选择「转为 UTF-8 无 BOM」→ 保存。
VS Code：右下角点击编码 → 「通过编码保存」→ 选择「UTF-8」→ 确保无 BOM。
2. 确保 .rc 文件中不包含 BOM
UTF-8 文件默认无 BOM。如果编辑器添加了 BOM（如 Windows 记事本），需手动移除：
sed -i '1s/^\xEF\xBB\xBF//' resource.rc  # Linux/Mac 移除 BOM
3. 重新编译资源文件
使用 windres 重新编译转换后的 UTF-8 文件：
windres resource.rc -O coff -o resource.o
4. 检查文件路径和内容
确保 .rc 文件中引用的资源路径（如图标 app.ico）不含非 ASCII 字符7。
若需在资源中使用中文，确保 UTF-8 编码正确（如使用 L"中文" 宽字符）。
其他注意事项
GCC 编译选项：若主程序源文件含非 ASCII 字符，需指定编码：
gcc -finput-charset=UTF-8 -fexec-charset=UTF-8 main.c resource.o -o app.exe
跨平台兼容性：在 Windows 上开发时，建议统一使用 UTF-8 编码，并配置编辑器默认保存为 UTF-8 无 BOM


keytool生成证书 查看证书信息 ，以及java操作的简单用例
首先用keytool生成证书
1 产生密钥
keytool -genkey -alias wenger -keysize 1024 -keypass abcdef -keystore myKeys
tore -storepass abcdef -dname "CN=chen sr, OU=tanglab, O=lab, L=gz, ST=gd, C=cn"
2 导出密钥，用证书的形式保存
keytool -export -alias wenger -file mycert.cer -keystore myKeystore -storepass abcdef
保存在文件中的认证 <mycert.cer>
用java读出证书的信息
 import  java.io. * ;
 import  java.security.cert. * ;
 public   class  TestCert  {
  public static void main(String[] args) {
    try {
      FileInputStream fis = new FileInputStream("mycert.cer");
      CertificateFactory cf=CertificateFactory.getInstance("X509");
      X509Certificate c=(X509Certificate) cf.generateCertificate(fis);
      System.out.println("Certficate for" + c.getSubjectDN());
      System.out.println("Generated with "+c.getSigAlgName());
    }
    catch (FileNotFoundException ex) {
    }
    catch (CertificateException ex) {
      /** @todo Handle this exception */
    }
  }
}
输出：
Certficate forCN=chen sr, OU=tanglab, O=lab, L=gz, ST=gd, C=cn
Generated with SHA1withDSA
JDK中keytool常用命令
-genkey      在用户主目录中创建一个默认文件".keystore",还会产生一个mykey的别名，mykey中包含用户的公钥、私钥和证书
-alias       产生别名
-keystore    指定密钥库的名称(产生的各类信息将不在.keystore文件中
-keyalg      指定密钥的算法  
-validity    指定创建的证书有效期多少天
-keysize     指定密钥长度
-storepass   指定密钥库的密码
-keypass     指定别名条目的密码
-dname       指定证书拥有者信息 例如：  "CN=sagely,OU=atr,O=szu,L=sz,ST=gd,C=cn"
-list        显示密钥库中的证书信息      keytool -list -v -keystore sage -storepass ....
-v           显示密钥库中的证书详细信息
-export      将别名指定的证书导出到文件  keytool -export -alias caroot -file caroot.crt
-file        参数指定导出到文件的文件名
-delete      删除密钥库中某条目          keytool -delete -alias sage -keystore sage
-keypasswd   修改密钥库中指定条目口令    keytool -keypasswd -alias sage -keypass .... -new .... -storepass ... -keystore sage
-import      将已签名数字证书导入密钥库  keytool -import -alias sage -keystore sagely -file sagely.crt
             导入已签名数字证书用keytool -list -v 以后可以明显发现多了认证链长度，并且把整个CA链全部打印出来。
1.证书的显示
-list
[-v | -rfc] [-alias <alias>]
[-keystore <keystore>] [-storepass <storepass>]
[-storetype <storetype>] [-provider <provider_class_name>]
例如：keytool -list -v -alias RapaServer -keystore cacerts -storepass 12345678
keytool -list -v -keystore d2aapplet.keystore -storepass 12345678 -storetype IAIKKeystore
2.将证书导出到证书文件
例如：keytool -export -keystore monitor.keystore -alias monitor -file monitor.cer
将把证书库 monitor.keystore 中的别名为 monitor 的证书导出到 monitor.cer 证书文件中，它包含证书主体的信息及证书的公钥，不包括私钥，可以公开。
keytool -export -keystore d2aApplet.keystore -alias RapaServer -file Rapa.cert -storetype IAIKKeystore
3.将keystore导入证书中
这里向Java默认的证书 cacerts导入Rapa.cert
keytool -import -alias RapaServer -keystore cacerts -file Rapa.cert -keystore cacerts
4.证书条目的删除
keytool的命令行参数 -delete 可以删除密钥库中的条目，如： keytool -delete -alias RapaServer -keystore d2aApplet.keystore ，这条命令将 d2aApplet.keystore 中的 RapaServer 这一条证书删除了。
5.证书条目口令的修改
使用 -keypasswd 参数，如：keytool -keypasswd -alias RapaServer -keystore d2aApplet.keystore，可以以交互的方式修改 d2aApplet.keystore证书库中的条目为 RapaServer 的证书。
Keytool -keypasswd -alias RapaServer -keypass 654321 -new 123456 -storepass 888888 -keystore d2aApplet.keystore这一行命令以非交互式的方式修改库中别名为 RapaServer 的证书的密码为新密码 654321，行中的 123456 是指该条证书的原密码， 888888 是指证书库的密码。



Android 平台签名证书
生成签名证书
使用keytool -genkey命令生成证书：
keytool -genkey -alias testalias -keyalg RSA -keysize 2048 -validity 36500 -keystore test.keystore -storepass android -keypass android -dname "CN=None, OU=None, O=None, L=None, ST=None, C=None"
导出密钥，用证书的形式保存
keytool -export -alias testalias -file mycert.cer -keystore test.keystore -storepass android
keytool: 调用密钥管理工具。
-genkey: 指示 keytool 生成一个新的密钥对。
-alias testalias: 设置密钥对的别名（alias）为 testalias。别名是在密钥库中唯一标识密钥对的名称。
-keyalg RSA: 指定密钥算法为RSA。RSA是一种广泛使用的公钥加密算法。
-keysize 2048: 指定密钥长度为2048位。2048位是目前广泛推荐的安全强度。
-validity 36500: 设置证书的有效期为36500天，大约等于100年。证书有效期可以根据需要调整，但通常设置为足够长的时间，以避免频繁的证书更新。
-storepass android:JKS 文件的访问密码
-keypass android:密钥密码
Enter keystore password:  //输入证书文件密码，输入完成回车  
Re-enter new password:   //再次输入证书文件密码，输入完成回车  
What is your first and last name?  
  [Unknown]:  //输入名字和姓氏，输入完成回车  
What is the name of your organizational unit?  
  [Unknown]:  //输入组织单位名称，输入完成回车  
What is the name of your organization?  
  [Unknown]:  //输入组织名称，输入完成回车  
What is the name of your City or Locality?  
  [Unknown]:  //输入城市或区域名称，输入完成回车  
What is the name of your State or Province?  
  [Unknown]:  //输入省/市/自治区名称，输入完成回车  
What is the two-letter country code for this unit?  
  [Unknown]:  //输入国家/地区代号（两个字母），中国为CN，输入完成回车  
Is CN=XX, OU=XX, O=XX, L=XX, ST=XX, C=XX correct?  
  [no]:  //确认上面输入的内容是否正确，输入y，回车  
Enter key password for <testalias>  
        (RETURN if same as keystore password):  //确认证书密码与证书文件密码一样（HBuilder|HBuilderX要求这两个密码一致），直接回车就可以
 查看证书信息
keytool -list -v -keystore test.keystore  
Enter keystore password: //输入密码，回车      
会输出以下格式信息：
Keystore type: PKCS12    
Keystore provider: SUN    
Your keystore contains 1 entry    
Alias name: test    
Creation date: 2019-10-28    
Entry type: PrivateKeyEntry    
Certificate chain length: 1    
Certificate[1]:    
Owner: CN=Tester, OU=Test, O=Test, L=HD, ST=BJ, C=CN    
Issuer: CN=Tester, OU=Test, O=Test, L=HD, ST=BJ, C=CN    
Serial number: 7dd12840    
Valid from: Fri Jul 26 20:52:56 CST 2019 until: Sun Jul 02 20:52:56 CST 2119    
Certificate fingerprints:    
         MD5:  F9:F6:C8:1F:DB:AB:50:14:7D:6F:2C:4F:CE:E6:0A:A5    
         SHA1: BB:AC:E2:2F:97:3B:18:02:E7:D6:69:A3:7A:28:EF:D2:3F:A3:68:E7    
         SHA256: 24:11:7D:E7:36:12:BC:FE:AF:2A:6A:24:BD:04:4F:2E:33:E5:2D:41:96:5F:50:4D:74:17:7F:4F:E2:55:EB:26    
Signature algorithm name: SHA256withRSA    
Subject Public Key Algorithm: 2048-bit RSA key    
Version: 3
其中证书指纹信息（Certificate fingerprints）：
MD5
证书的MD5指纹信息（安全码MD5）
SHA1
证书的SHA1指纹信息（安全码SHA1）
SHA256
证书的SHA256指纹信息（安全码SHA245） 
注意事项
云端打包默认会添加V1/V2签名，已知V1签名不支持2048位的DSA算法，使用2048-bit DSA key云端打包可能失败，提示以下错误：
* What went wrong:  
Execution failed for task ':app:packageRelease'.  
> A failure occurred while executing com.android.build.gradle.tasks.PackageAndroidArtifact$IncrementalSplitterRunnable  
   > java.io.IOException: Failed to generate v1 signature
解决方法
第一种方法：重新生成证书，在生成证书命令中添加“-keyalg RSA”参数指定使用RSA算法
第二种方法：设置miniSdkVersion大于等于24，因为V2签名需Android7及以上设备才支持，设置miniSdkVersion大于等于24表示不支持android7以下设备，从而不需要包含V1签名，设置miniSdkVersion详情参考：https://ask.dcloud.net.cn/article/193
查看证书算法的方法
使用“keytool -list -v”查看证书信息，看“Subject Public Key Algorithm: ”项的信息，如下表示使用DSA算法：
Subject Public Key Algorithm: 2048-bit DSA key
JKS 密钥库使用专用格式。建议使用 "keytool -importkeystore -srckeystore test.keystore -destkeystore test.keystore -deststoretype pkcs12" 迁移到行业标准格式 PKCS12
// 构建 keytool 命令
ProcessBuilder processBuilder = new ProcessBuilder(
        "keytool",
        "-genkey",  //  表明需要生成一个密钥对
        "-alias", "cert-tk",    //  为密钥对指定一个别名
        "-keyalg", "RSA",   //  指定密钥算法
        "-keysize", "2048",     //  设置密钥的长度
        "-validity", "36500",     //  设定证书的有效期，单位"天"
        "-keystore", "keystore.jks",  //  指定生成的 JKS 文件的名称
        "-storepass", "123456",  //  设置 JKS 文件的访问密码
        "-keypass", "123456",      //  设置密钥的密码(etg. hjkRTYF54549vghuIJNxdrjhk459qw987ty78igu6e54rds3)
        "-dname", "CN=twinkle, OU=twinkle-home, O=none, L=YiChun, ST=JiangXi-Province, C=China"     //  指定证书的主体信息
        //  通用名称（CN）、组织单位（OU）、组织（O）、城市（L）、州（ST）和国家（C）
);
// 启动进程
Process process = processBuilder.start();


keytool常用命令
-genkey      产生密钥对（genkeypair 简写）；表示要创建一个新的密钥；alias和keystore缺省时，在用户主目录中创建一个”.keystore”文件，且别名为mykey，包含用户的公钥、私钥证书 
-alias       产生证书别名，和keystore关联的唯一别名，不区分大小写（默认 `mykey`） 
-keystore    指定密钥库文件的名称（默认在用户主目录创建证书库） 
-keyalg      指定密钥的算法（可选择密钥算法：`RSA`、`DSA`、`EC`，默认`DSA`） 
-keysize     指定密钥长度（与keyalg默认对应关系：`RSA=2048`、`DSA=2048`、`EC=256`） 
-sigalg      指定签名算法（MD5和 SHA1的签名算法已经不安全） 
-validity    指定证书有效期天数（默认 `90`天） 
-storepass   指定密钥库口令，推荐与keypass一致（获取keystore信息所需的密码） 
-storetype   指定密钥库的类型，可用类型为：JKS、PKCS12等。（jdk9以前，默认为JKS。自jdk9开始，默认为PKCS12） 
-keypass     指定别名条目口令（私钥的密码） 
-dname       指定证书发行者信息（其中 CN 要和服务器的 `域名` 或 `IP` 相同，本地测试则使用localhost，其他的可以不填） 
-list        显示密钥库中的证书信息 
-v           详细输出，显示密钥库中的证书详细信息 
-file        指定导出或导出的文件名 
-export      将别名指定的证书导出到文件（exportcert 简写） 
-import      将已签名数字证书导入密钥库（importcert 简写） 
-printcert   查看导出的证书信息 
-delete      删除密钥库中某条目 
-keypasswd   修改密钥库中指定条目口令 
-storepasswd 修改keystore口令 
-ext X.509   扩展
创建证书
keytool -genkey 
        -alias <alias> 
        -keyalg RSA 
        [-sigalg SHA256withRSA] 
        [-keysize 2048] 
        -keypass <keypasswd> 
        -keystore <keystore_file> 
        -storetype JKS|PKCS12 
        -storepass <keystore_passwd> 
        -validity 3650 
        -dname "CN=github.com,OU=github.com,Inc.,O=Github, Inc.,L=San Francisco,ST=California,C=US" 
        -ext SAN=dns:github.com,dns:www.github.com,ip:127.0.0.1 
Options：
-genkey     产生密钥对（genkeypair 简写）
-alias      证书别名；和keystore关联的唯一别名，这个alias通常不区分大小写（默认`mykey`）
-keyalg     指定加密算法，RSA：非对称加密（默认`DSA`）
-sigalg     指定签名算法，可选;
-keysize    指定密钥长度，可选;
-keypass    指定别名条目口令（私钥的密码）
-storetype  生成证书类型，可用的证书库类型为：JKS、PKCS12等。（jdk9以前，默认为JKS。自jdk9开始，默认为PKCS12）
-keystore   指定产生的密钥库的位置；
-storepass  指定密钥库的存取口令，推荐与keypass一致
-validity   证书有效期天数；（默认为 90天）
-dname      表明了密钥的发行者身份（Distinguished Names）生成证书时，其中 CN 要和服务器的 `域名` 或 `IP` 相同，本地测试则使用localhost，其他的可以不填
-ext        X.509 扩展
keytool.exe -genkeypair -alias rootca -keyalg RSA -keysize 2048 -keypass 11111111 -validity 36500 -keystore lytest.jks -storepass 11111111
导出证书公钥
导出自签证书
Usage：
keytool -export 
        -alias <alias> 
        -keystore <keystore_file> 
        -storepass <keystore_passwd> 
        -file <file_cer>    
        [-rfc] 
Options：
-export     执行证书导出操作（exportcert 简写）
-alias      密钥库中的证书条目别名（jks里可以存储多对公私钥文件，通过别名指定导出的公钥证书）
-keystore   指定密钥库文件
-storepass  密钥库口令
-file       导出文件的输出路径
-rfc        使用Base64格式输出（输出pem编码格式的证书，文本格式），不适用则导出的证书为DER编码格式
需要输入密钥库口令keytool -export -alias rootca -keystore D:\lytest.jks -file D:\lytest.cer
不需要输入秘钥库口令keytool -export -alias rootca -keystore D:\lytest.jks -storepass 11111111 -file D:\lytest.cer
获取认证证书（生成CSR）
keytool -certreq 
        -alias <alias> 
        -keystore <keystore_file> 
        -storepass <keystore_passwd> 
        -file <file_csr> 
Options：
-certreq    执行证书签发申请导出操作
-alias      密钥库中的证书条目别名
-keystore   密钥库文件名称
-storepass  密钥库口令
-file       输出的csr文件路径
keytool -certreq -alias test -file D:\lytest.csr -keystore D:\lytest.jks
导入证书库
keytool -import 
        [-trustcacerts] 
        -alias <alias_cer> 
        -keystore <keystore_file>
        -storepass <keystore_passwd> 
        -file <file_cer> 
Options：
-import     执行证书导入操作（importcert 简写）
-alias      指定导入密钥库中的证书别名（指定的条目别名不能与密钥库中已存在的条目别名重复（导入签发证书除外））
-trustcacerts    将证书导入信任库（信任来自 cacerts 的证书）
-keystore   密钥库名称
-storepass  密钥库口令
-file       输入文件名
签发证书（对CSR文件签发）
keytool -gencert
        [-trustcacerts] 
        -alias <alias_cer> 
        -keystore <keystore_file>
        -storepass <keystore_passwd> 
        -infile <file_csr> 
        -outfile <file_cer>
Options：
-gencert     根据证书请求生成证书
-alias       指定导入密钥库中的证书别名（指定的条目别名不能与密钥库中已存在的条目别名重复（导入签发证书除外））
-keystore   密钥库名称
-storepass  密钥库口令
-infile     待签发的证书请求，csr文件
-outfile    签发的证书，cer文件
keytool -gencert -alias rootca -infile D:\lytest.csr -outfile D:\lytest.cer -keystore D:\lytest.jks
导入证书
keytool -importcert
        -alias <alias_cer> 
        -keystore <keystore_file>
        -storepass <keystore_passwd> 
        -file <file_cer>
Options：
-importcert  导入证书或证书链
-alias       指定导入密钥库中的证书别名（指定的条目别名不能与密钥库中已存在的条目别名重复（导入签发证书除外））
-keystore    密钥库名称
-storepass   密钥库口令
-file        证书或者证书链文件
keytool -importcert -alias test -file D:\lytestcer -keystore D:\lytest.jks -storepass
查看证书
# 查看单个证书（cer | crt）
keytool -printcert -file <cert_file> [-v|-rfc]
# 查看密钥库中的证书条目
keytool -list [-alias <alias_name>] -keystore <keystore_file> -storepass <keystore_passwd> [-v|-rfc]
# 查看生成的CSR证书请求
keytool -printcertreq -file <certreq_file>     
Options：
-alias      密钥库中的证书条目别名；
-keystore   指定密钥库文件；
-storepass  密钥库口令；
-printcert  执行证书打印命令；
-list       缺省情况下，命令打印证书的 MD5 指纹。
    如果指定了 -v 选项，将以可读格式打印证书，
    如果指定了 -rfc 选项，将以可打印的编码格式输出证书。 
 其他命令
# 删除keystore里面指定证书条目
keytool -delete -alias <alias> -keystore <keystore_file> -storepass <keystore_passwd>
# 修改条目别名
keytool -changealias -keystore <keystore_file> -alias <old_alias> -destalias <new_alias>
# 修改条目密码
keytool -keypasswd -alias <alias> -keypass <old_keypasswd> -new <new_keypasswd> -keystore <keystore_file> -storepass <keystore_passwd>
# 修改keysore密码
keytool -storepasswd -new <new_storepasswd> -keystore <keystore_file> -storepass <old_storepasswd>
# 列出信任的CA证书（查看 JVM的信任库中的证书，storepass 默认为changeit）
## 该证书文件存在于JAVA_HOME\jre\lib\security目录下，是Java系统的CA证书仓库，可以用 'alias' 来查看证书是否真的导入到JVM中
keytool -list -v [-alias clientCer] -keystore $JAVA_HOME/jre/lib/security/cacerts -storepass changeit
# 导入新的CA到信任证书，导入到 JRE的信任证书库
## 常出现的异常：“未找到可信任的证书”  -- 主要原因为在客户端未将服务器下发的证书导入到JVM中。
keytool -import -trustcacerts -alias clientCer -keystore $JAVA_HOME/jre/lib/security/cacerts -storepass changeit -file ~/ssl/client.cer

 openssl一条命令生成ssl证书
列：生成 tomcat.lucky.com 域名的ssl证书
openssl req -x509 -sha256 -nodes -days 3650 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj "/C=CN/ST=Beijing/L=Beijing/O=DevOps/CN=tomcat.lucky.com"
SSL&OpenSSL   
构建根证书
构建随机文件，命令如下
openssl rand -out private/.rand 1000   
构建根证书密钥，命令如下
openssl genrsa -aes256 -out private/ca.key.pem 2048  
各参数含义如下：
genrsa	产生RSA密钥命令
-aes256	使用AES算法（256位密钥）对产生的私钥加密。可选算法包括DES，DESede，IDEA和AES
-out	输出路径，这里指private/ca.key.pem
2048	这里的参数是2048，指RSA密钥长度位数，默认长度为512位
生成根证书签发申请文件（ca.csr），命令如下
openssl req -new -key private/ca.key.pem -out private/ca.csr -subj "/C=CN/ST=BJ/L=BJ/O=yewenjie/OU=yewenjie/CN=*.yewenjie.org"
各参数含义如下：
req	产生证书签发申请命令
-new	表示新请求
-key	密钥，这里是private/ca.key.pem文件
-out	输出路径，这里为private/ca.csr文件
-subj	指定用户信息，这里使用泛域名 *.yewenjie.org 作为用户名
得到根证书签发申请文件后，我们可以将其发送给CA签发。也可以自行签发根证书。签发根证书命令如下
openssl x509 -req -days 365 -sha1 -extensions v3_ca -signkey private/ca.key.pem -in private/ca.csr -out certs/ca.cer
各参数含义如下：
x509	签发x.509格式证书命令
-req	证书输入请求
-days	有效天数，这里为365天
-sha1	证书摘要算法，这里为sha1算法
-extensions	按openssl配置文件v3_ca项添加扩展
-signkey	自签名密钥，这里为private/ca.key.pem
-in	输入文件，这里为private/ca.csr
-out	输出文件，这里为certs/ca.cer
由于通过openssl生成的证书无法直接在Java环境中使用，需要转换证书的编码格式才行。根证书转换格式命令如下
openssl pkcs12 -export -cacerts -inkey private/ca.key.pem -in certs/ca.cer -out certs/ca.p12
各参数含义如下：
pkcs12	PKCS#12编码格式证书命令
-export	导出证书
-cacerts	仅导出CA证书
-inkey	输入密钥，这里为private/ca.key.pem
-in	输入文件，这里为certs/ca.cer
-out	输出文件，这里为certs/ca.p12

构建服务器证书
首先构建私钥，命令如下
openssl genrsa -aes256 -out private/server.key.pem 2048
各参数含义如下：
genrsa	产生RSA密钥命令
-aes256	使用AES算法（256位密钥）对产生的私钥加密，可选算法包括DES，DESede，IDEA和AES
-out	输出路径，这里指private/server.key.pem
参数2048	指RSA密钥长度位数，默认长度位512
生成服务器证书签发申请，命令如下
openssl req -new -key private/server.key.pem -out private/server.csr -subj "/C=CN/ST=BJ/L=BJ/O=yewenjie/OU=yewenjie/CN=www.yewenjie.org"
各参数含义如下
req	生成证书签发申请命令
-new	新请求
-key	密钥，这里为private/ca.key.pem文件
-out	输出路径，这里为private/ca.csr文件
-subj	指定用户信息，这里使用域名www.yewenjie.org作为用户名
使用根证书签发服务器证书，命令如下
openssl x509 -req -days 365 -sha1 -extensions v3_req -CA certs/ca.cer -CAkey private/ca.key.pem -CAserial ca.srl -CAcreateserial -in private/server.csr -out certs/server.cer
各参数含义如下
x509	签发x.509格式证书命令
-req	证书输入请求
-days	有效天数，这里为365天
-sha1	证书摘要算法，这里为SHA1算法
-extensions	按Openssl配置文件v3_req项添加扩展
-CA	CA证书，这里为certs/ca.cer
-CAkey	CA证书密钥，这里为private/ca.key.pem
-CAserial	CA证书序列号文件，这里为ca.srl
-CAcreateserial	创建CA证书序列号
-in	输入文件，这里为private/server.csr
-out	输出文件，这里为certs/server.cer
转换证书格式，命令如下
openssl pkcs12 -export -clcerts -inkey private/server.key.pem -in certs/server.cer -out certs/server.p12
各参数含义如下：
pkcs12	PKCS#12编码格式证书命令
-export	导出证书
-clcerts	仅导出客户证书
-inkey	输入密钥文件路径，这里为private/server.key.pem
-in	输入文件路径，这里为certs/ca.cer
-out	输出文件路径，这里为certs/server.p12
构建客户证书
构建私钥，命令如下
openssl genrsa -aes256 -out private/client.key.pem 2048
各参数含义如下
genrsa	产生RSA密钥命令
-aes256	使用AES算法（256位密钥）对产生的私钥加密，可选算法包括DES，DESede，IDEA和AES
-out	输出路径，这里指private/client.key.pem
参数2048	指RSA密钥长度位数，默认长度位512位
生成客户端证书签发申请，命令如下
openssl req -new -key private/client.key.pem -out private/client.csr -subj "/C=CN/ST=BJ/L=BJ/O=yewenjie/OU=yewenjie/CN=yewenjie"
各参数含义如下
req	产生证书签发申请命令
-new	新请求
-key	密钥，这里是private/client.key.pem文件
-out	输出路径，这里是private/client.csr文件
-subj	指定用户信息，这里使用yewenjie作为用户名
使用根证书签发客户证书，命令如下
openssl ca -days 365 -in private/client.csr -out certs/client.cer -cert certs/ca.cer -keyfile private/ca.key.pem
各参数命令如下
ca	签发证书命令
-days	证书有效期，这里是365天
-in	输入文件，这里是private/client.csr
-out	输出文件，这里是certs/server.cer
-cert	证书文件，这里是certs/ca.cer
-keyfile	根证书密钥文件，这里是private/ca.key.pem
证书格式转换，命令如下
openssl pkcs12 -export -inkey private/client.key.pem -in certs/client.cer -out certs/client.p12
各参数含义如下：
pkcs12	PKCS#12编码格式证书命令
-export	导出证书
-clcerts	仅导出客户证书
-inkey	输入密钥，这里为private/client.key.pem
-in	输入文件，这里是certs/client.cer
-out	输出文件，这里是certs/client.p12

openssl工具 生成ssl证书
一，检查openssl是否安装
使用命令openssl version  出现一下结果表示已经安装该工具。
openssl version
二，创建RSA Private Key
执行这个命令会输入两次密码，自己记住就行。
openssl genrsa -des3 -out server.pass.key 2048
这个命令用于生成一个带密码保护的 RSA 私钥文件。具体来说，它的作用可以分解为以下几个部分：
genrsa: 这是 OpenSSL 的一个子命令，用于生成 RSA 私钥。
-des3: 这个选项指定使用 DES3（Triple DES）加密算法来加密私钥。它会要求你设置一个密码，来保护生成的私钥文件。-des3 表示三重 DES 算法，用来增加安全性。
-out server.pass.key: 这个选项指定输出文件的名称。也就是说，生成的私钥文件会保存为 server.pass.key。
2048: 这个数字指定生成的 RSA 密钥的长度。2048 位密钥是当前比较常用的安全级别，既有较好的安全性，又不会造成过高的计算负担。
三，提取私钥
执行命令输入上一步设置的密码
openssl rsa -in server.pass.key -out server.key
四，证书签名请求
openssl req -new -key server.key -out server.csr -subj "/C=CN/ST=SX/L=XA/O=MORISE/OU=JIAOHU/CN=192.148.3.140"
五，生成证书
openssl x509 -req -days 3650 -in server.csr -signkey server.key -out server.crt
其中3650为有效时长
  
  
查看源文件预处理结果
编译C/C++源代码时，源代码首先会被预处理器（preprocessor）进行预处理（preprocess）。
预处理器执行源代码中的预处理指令，如：
——文件包含
#include
——条件编译
#if、 #ifdef、 #ifndef、 #elif、 #else、 #endif
——宏
#define、 #undef、宏标识符、宏扩展
——其他
#error、#line、#pragma
……
预处理之后的结果（即将提交给编译器）与程序员看到的源代码也许会有很大的差异。
尤其在源代码中含有许多错综复杂的宏与条件编译时。
当我们被这些狂乱的宏与条件编译折磨的时候， 如果能看到预处理的结果， 也许会有很大的帮助。
下面将以一个示例说明msvc与gcc中得到预处理结果的方式。
零、 示例
假设我们需要查看 _MSC_VER 与 __GUNC__ 两个宏最终被扩展出的文本： 
int main() {
    int result = 
#if defined(__GNUC__)
__GNUC__
#elif defined(_MSC_VER)
_MSC_VER
#else
#error unknown compiler
#endif
;
    return result;
}
该程序很简单， main函数返回一个result，然后立即退出。
而result的值， 根据条件编译得到：
1. 如果是GCC编译器， 那么result赋值为__GNUC__
2. 否则如果是VC编译器， 那么result赋值为_MSC_VER
3. 否则是一个未知的编译器， 错误
接下来， 我们来看看_MSC_VER与__GNUC__这2个宏最终到底被扩展为什么文本。
一、 GCC
一.1、 -E 选项
-E选项将把预处理的结果，写入stdout。
也就是说， 执行如下命令：
gcc -E preporcess_only.c
就能在控制台中得到预处理后的结果，大致如下：
# 1 "../preprocess_only.c"
# 1 "<built-in>"
# 1 "<command line>"
# 1 "../preprocess_only.c"
int main() {
    int result =3;
    return result;
}
可以看到， __GUNC__ 宏最终被扩展为整数字面量3（GCC 3）。
如果源代码很长， 输出到命令行窗口中查看也许不方便。
如何将其输出到一个文件中呢？
一.1.1、 重定向
因为-E是输出到stdout， 显然可以将其重定向到另一个文件， 如执行如下命令：
gcc -E preprocess_only.c >stdout.txt
那么stdout.txt中， 就能得到刚才命令行窗口中的内容。
一.1.2、 -o （小写） 选项
-o选项用于指定出文件名。
对于-c， -o指定的是目标文件名。
对于-S ，-o指定的是汇编文件名。
对于-E， -o自然也可以指定预处理文件名， 如执行如下命令：
gcc -E preprocess_only.c -o output.txt
那么output.txt中会得到“一.1.1”中的stdout.txt和“一.1”中控制台窗口一样的结果。
一.2、-save-temps 选项
-save-temps选项将保留中间文件：如预处理后的结果文件、汇编代码文件与目标文件。
其中的预处理结果文件（通常有.i后缀）是我们所需要的。
举例：
1、 gcc -save-temps -E preprocess_only.c
0个中间文件。
输出预处理结果， 同“一.1”一样， 输出到控制台窗口中。
对比如下命令：
1.1、 gcc -save-temps -E preprocess_only.c -o temp_output.txt
1.2、 gcc -save-temps -E preprocess_only.c >temp_output.txt
可以看出， -E选项不产生中间文件。 预处理结果就是最终结果。
同时可以使用 -o选项或者重定向， 把结果保存到一个文件中。
2、 gcc -save-temps -S preprocess_only.c
1个中间文件： preprocess_only.i（预处理结果）
1个输出文件：preprocess_only.s（汇编代码）
对比如下命令：
2.1、 gcc -save-temps -S preprocess_only.c -o unknown
得到preprocess_only.i文件，内容是预处理结果，是中间文件。
得到unknown文件，内容是汇编代码， 是最终结果文件。
3、 gcc -save-temps -c preprocess_only.c
2个中间文件： preprocess_only.i与preprocess_only.s。
1个输出文件： preprocess_only.o（目标代码）
对比如下命令：
3.1、 gcc -save-temps -c preprocess_only.c -o unknown
得到preprocess_only.i 与 preprocess_only.s文件，内容分别是预处理结果与汇编代码，是中间结果。
unknown文件， 内容是目标代码，是最终结果文件。
4、 gcc -save-temps preprocess_only.c
3个中间文件： preprocess_only.i、preprocess_only.s、preprocess_only.o。
1个输出文件： a.out（a.exe with mingw）。
对比如下命令：
4.1、 gcc -save-temps preprocess_only.c -o what
得到上述3个文件， 是中间文件。
what文件（what.exe with mingw）， 内容是可执行代码， 是最终结果文件。
二、 MSVC
VC6、8、9中与查看预处理相关的选项可以通过如下命令查看：
cl /help
在输出中， 找 -PREPROCESSOR- 这个类别。
其中与预处理结果相关的有如下一些选项：
二.1、/E 选项
/E preprocess to stdout
/E 将预处理定向到 stdout
显然， 这和“一.1”是等价的， 如：
cl /E preprocess_only.c
在命令行窗口中将得到类似结果：
#line 1 "preprocess_only.c"
int main() {
    int result = 
#line 6 "preprocess_only.c"
1200
#line 10 "preprocess_only.c"
;
    return result;
}
可以看到， _MSC_VER宏最终被扩展为整数字面值1200（VC6）。
对于较长的源文件， 我们同样希望将结果输出到一个文件中。
二.1.1、重定向
执行：
cl /E preprocess_only.c >stdout.txt
stdout.txt将保存上面的结果。
注意： 在msvc中，没有“一.1.2”的对应物。
执行：
cl /help
在输出中找到-OUTPUT FILES-类别， 可以看到没有命名预处理结果的方式。有两个相似的选项：
/Fe 命名可执行文件。
/Fp 命名预编译头文件。
但不是我们需要的选项。
也许VC认为通过 “/E + 重定向”就可以达到命名输出文件的目的。
所以就没有设计达到此目的的另一种方法。
二.2、/P 选项
/P preprocess to file
/P 预处理到文件
执行：
cl /P preprocess_only.c
将得到 preprocess_only.i
/P会将对 xxx.suffix 的预处理结果输出到 xxx.i 文件中。
没有指定文件名的方式。 如果需要指定输出文件名， 可以使用 “/E + 重定向”
二.3 /EP 选项
/E与/P选项都将保留一部分（源文件）行信息，如“二.1”所示。
如果这是不需要的， 可以使用 /EP选项。
/EP preprocess to stdout, no #line
/EP 预处理到标准输出，没有 #line
如：
cl /EP preprocess_only.c
将得到如下输出：
int main() {
    int result = 1200;
    return result;
}
同样， 如果需要输出到指定文件， 可以使用重定向。
二.4 其他一些有趣的选项
1. /C （大写）
don't strip comments（不抽出注释）
如果保留注释对理解预处理结果有帮助， 可以使用这个选项。
2. /U /u
/u remove all predefined macros
/u 移除所有预定义的宏
/U<name> remove predefined macro
/U<name> 移除预定义的宏
比如可以通过：
cl /u preprocess_only.c
cl /U_MSC_VER preprocess_only.c
来得到一个 unknown complier错误囧……
3. /D
/D<name>{=|#}<text> define macro
/D<name>{=|#}<text> 定义宏
可以通过：
cl /D__GUNC__=3 preprocess_only.c
来假装gcc编译器囧……
  
include(FetchContent)
FetchContent_Declare(
        AndroidImgui  # 第三方库名
        GIT_REPOSITORY https://github.com/enenH/AndroidImgui.git  # GitHub库的URL
        GIT_TAG v1.9 # 你想要的分支或标签
)
FetchContent_MakeAvailable(AndroidImgui)  # 下载并使库可用
target_link_libraries(your_lib_name AndroidImgui)  # 链接库
include(FetchContent)
FetchContent_Declare(
        curl_android
        GIT_REPOSITORY https://github.com/enenH/curl-android.git
        GIT_TAG v8.8.1
)
FetchContent_MakeAvailable(curl_android)
target_link_libraries(your_lib_name curl::curl_static)
  
 rm -f NUL 强制删除文件
 rmdir -f NUL 强制删除文件夹
del /f/q/s *.* > NUL //强制删除文件 /F：强制删除只读文件 /Q：在模糊文件名匹配删除的时候，不询问是否删除 /S：删除当前目录和子目录中指定文件
rd /f/s/q   强制删除文件夹

nul 和prn都属于设备名称，等价于一个 DOS 设备，这类文件无法在图形界面删除，因为 Windows 不允许以这种方式删除设备。在系统看来，这个 nul,prn 文件夹就是设备。
不过可以在MS-DOS下删除它们。
开始—运行—输入cmd—确定。然后在打开的命令提示符窗口中输入：
RD/S/Q \\.\“C:\Documents and Settings\Administrator\桌面\Internetexploer\nul ” 回车，再输入
RD/S/Q \\.\“C:\Documents and Settings\Administrator\桌面\Internetexploer\prn” 回车，再手动删除Internetexploe文件夹即可。（注：RD/S/Q后面是一个空格，\\后面是一个点“.”）。
del /f /s /q \\.\D:\WorkZone\MyAssist\nelua-lang\NUL

VS 常量$(LatestTargetPlatformVersion)$(DefaultPlatformToolset)$(SolutionDir)$(ProjectDir)$(Configuration)$(OutDir)$(ProjectName)$(Platform)$(IntDir)$(MSBuildProjectName)$(IncludePath)$(LibraryPath)
VS 链接-> 命令行 ->其他 \verbose:lib查看链接过程 \utf-8编码支持[#pragma warning (disable:4819)]
VS 链接 -> 清单文件 -> UAC执行级别 /level='requireAdministrator'
VS dumpbin /exports xxx.lib > xxx.txt dumpbin 可以查看 lib 库中的所有导出符号
VS dumpbin /archivemembers  xxx.lib > xxx.txt  可以查看 lib 库中成员的基本信息
VS dumpbin /dependents  xxx.lib > xxx.txt  可以查看 lib 库中的所依赖的DLL
VS dumpbin /disasm  xxx.lib > xxx.txt  可以查看 lib 库中的代码段反编译结果
VS dumpbin /headers  xxx.lib > xxx.txt  可以查看文件所有段的头部信息 当文件为库文件时显示成员对象的头部信息
VS dumpbin /imports  xxx.lib > xxx.txt  可以查看文件或DLL文件中导入的DLL文件和函数列表
VS undname ?XXX@XXX@XX undname方便查看未经过编译器处理的函数名
Microsoft.Cpp.Win32.user.props Microsoft.Cpp.x64.user.props VS2010VC++目录
Microsoft.Cpp.MSVC.Toolset.Win32.props Microsoft.Cpp.MSVC.Toolset.x64.props VS2022VC++目录
Windows导出环境变量 set >> evn.reg

Huggingface镜像站hf-mirror.com 大模型下载
pip install -U huggingface_hub hf_transfer
set HF_ENDPOINT=https://hf-mirror.com;set HF_HOME=D:/Work/hf-mirror/.cache/huggingface/hub;set TRANSFORMERS_CACHE=D:/Work/hf-mirror/.cache
huggingface-cli download --resume-download xxx/xx --local-dir xx

https://gitdl.cn/https://github.com/gorhill/uBlock/releases/download/1.60.1b13/uBlock0_1.60.1b13.chromium.zip
https://www.tampermonkey.net/crx/tampermonkey_stable.crx

flutter dart环境配置
openssl x509 -inform der -in tuna.tsinghua.edu.cn.der -out tuna.tsinghua.edu.cn.pem//利用镜像网站der/cer证书文件生成pem信任证书文件
openssl x509 -inform der -in mirrors.sjtug.sjtu.edu.cn.crt -out mirrors.sjtug.sjtu.edu.cn.pem//利用镜像网站der/cer证书文件生成pem信任证书文件
set PUB_HOSTED_URL=https://pub.flutter-io.cn//推荐flutter镜像站
set FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn//推荐第三方镜像站
set DART_VM_OPTIONS="--root-certs-file=mirrors.sjtug.sjtu.edu.cn.gem"//设置环境变量并指定证书文件
set https_proxy="--root-certs-file=mirrors.sjtug.sjtu.edu.cn.gem"//设置环境变量并指定证书文件
flutter pub get//获取第三方包
flutter build apk//打包apk

ollama添加gguf模型
ollama list
<model_name>.mf : FROM ./<model_name>.gguf
ollama create <model_name> -f <model_name>.mf
ollama run <model_name>
ollama rm <model_name>

msys64
修改 D:\msys64\etc\pacman.d 目录下的所有 mirrorlist.* 文件，将原来的注释掉，添加如下
#清华源
Server = http://mirrors.tuna.tsinghua.edu.cn
#中科大源
Server = http://mirrors.ustc.edu.cn
#北理源
Server = http://mirror.bit.edu.cn
添加目录 ;D:\msys64\mingw64\bin;D:\msys64; 到path中
pacman -U [包名.tar.zst | 包名.tar.xz] #归档包安装
pacman -R 包名 #卸载软件包
pacman -Q #查询已安装包信息
pacman -Suy
pacman -Su
pacman -S base-devel
pacman -S gcc
pacman -S gcc-c++
pacman -S pkg-config
pacman -S make
pacman -S wget
pacman -S curl
pacman -S git
pacman -S python
pacman -S ncurses
pacman -S llvm
pacman -S clangd
pacman -S gdb
pacman -S glib
pacman -S 7zip-full
pacman -S maven
pacman -S apache
pacman -S docker
pacman -S nasm
pacman -S zsh
pacman -S ninja
pacman -S meson
pacman -S cmake
pacman -S xmake
pacman -S mingw-w64-x86_64-gcc
pacman -S mingw-w64-x86_64-cmake-gui
pacman -S mingw-w64-x86_64-gdb
pacman -S mingw-w64-x86_64-make
pacman -S mingw-w64-x86_64-boost
pacman -S mingw-w64-x86_64-opencv
pacman -S mingw-w64-x86_64-toolchain
pacman -S mingw-w64-i686-toolchain
pacman -S mingw64/mingw-w64-x86_64-clang
pacman -S mingw32/mingw-w64-i686-clang

FFMPEG最简Windows编译方案[msys]
pacman -Syu
pacman -S git make diffutils pkg-config
pacman -S mingw-w64-x86_64-toolchain
pacman -S --needed base-devel mingw-w64-x86_64-toolchain
pacman -S mingw-w64-ucrt-x86_64-gcc
pacman -S mingw-w64-x86_64-ffmpeg
pacman -S nasm
pacman -S mingw-w64-ucrt-x86_64-SDL2
git clone github.com/FFmpeg/FFmpe
cd FFmpeg
./configure --arch=x86_64 --enable-shared --enable-static
make
make install

https://github.com/ViRb3/magisk-frida[frida-server on boot with the following rooting tools: Magisk, KernelSU and APatch] 
https://zhuanlan.zhihu.com/p/151851826[模拟来电，假装来电话，关键时刻有妙用]

//Android Gradle ktx
编译完release版本后复制apk到特定目录，apk文件名字符合自己的需求，例如增加版本号，版本名字。翻了一遍网上基本上都是Groovy编写，但是项目刚好切换到kts了，之前Groovy代码用不了。
原来的Groovy版本

// Version
def versionPropertiesFile = project.file("version.properties")
def versionProperties = new Properties()
versionProperties.load(new FileInputStream(versionPropertiesFile))
/////////////
artifact_version=1.0.4
artifact_name=pager-demo
/////////////
def getGitHash() { 
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine 'git', 'rev-parse', '--short', 'HEAD'
        standardOutput = stdout
    }
    return stdout.toString().trim()
}

def releaseTime() {
    return new Date().format("yyyyMMdd", TimeZone.getTimeZone("GMT+08:00"))
}
android {
    /////其他代码
    android.applicationVariants.all {
        variant ->
//            if (!assembleProvider.name.contains("Release")) {
//                return
//            }
            println(" rootDir  = ${rootDir.absolutePath}")
            println(" buildDir =${buildDir.absolutePath}")
            def isDebuggable = variant.getBuildType().isDebuggable()
            def appName = "Silkswap"
            println(" isDebuggable  = ${isDebuggable}")
            println(" appName  = ${appName}")
            variant.outputs.all { output ->
                //指定文件输出名称
                if (isDebuggable) {
                    outputFileName = "${appName}-${variant.name}-${output.baseName}-${variant.versionName}-${getGitHash()}.apk"
                } else {
                    outputFileName = "${appName}-${variant.name}-${output.baseName}-${variant.versionName}.apk"
                }
            }
//            variant.outputs.all {
//                //指定文件输出路径
//                outputFileName = "Silkswap-${variant.name}.apk"
//            }
            def outputFileDir = new File("${rootDir.absolutePath}/apkFile/")
            // 删除旧的 assets 目录及其内容
            if (!outputFileDir.exists()) {
                outputFileDir.mkdir()
            }
            variant.assembleProvider.configure() {
                it.doLast {
                    if (variant.mappingFile != null && variant.mappingFile.exists()) {
                        def mappingFileName = "$archivesBaseName-$variant.baseName-mapping.txt"
                        (new File(variant.mappingFile.parent, mappingFileName)).delete()
                        if (isDebuggable) {
                            variant.mappingFile.renameTo(variant.mappingFile.parent + "/$appName-$variant.baseName-${variant.versionName}-${getGitHash()}-mapping.txt")
                        } else {
                            variant.mappingFile.renameTo(variant.mappingFile.parent + "/$appName-$variant.baseName-${variant.versionName}-mapping.txt")
                        }
                    }
                    copy{
                        variant.outputs.all { file ->
                                copy {
                                    from(file.outputFile)
                                    into(outputFileDir)
                                }
                        }
//                        variant.outputs.forEach { file ->
//                            copy {
//                                from file.outputFile
//                                into outputFileDir
//                            }
//                        }
                    }
                }
            }
    }
}
下面是kts版本。
全部代码如下，只需要在你的主模块的android中增加代码即可。
 getGitHash = { ->
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine 'git', 'rev-parse', '--short', 'HEAD'
        standardOutput = stdout
    }
    return stdout.toString().trim()
}
getDateOfBuild = { -> // ISO 8601 time format
    return new Date().format("yyyy-MM-dd'T'HH:mm'Z'").toString().trim()
}
android {
    /////其他代码
    applicationVariants.all {
        val variant = this
        if (!assembleProvider.name.contains("Release")) {
            return@all
        }
        outputs.forEach {
            val output = it as BaseVariantOutputImpl
            output.outputFileName = "sob_" + buildType.name + "_v" + versionName + "_" + versionCode + ".apk"
        }    
        // 打包完成后复制apk到指定文件夹,根目录apkFile
        var outputFileDir = File("${rootDir.absolutePath}/apkFile/")
        if (!outputFileDir.exists()) {
            outputFileDir.mkdir()
        }
        assembleProvider.configure {
            doLast {
                copy {
                    variant.outputs.forEach { outFile ->
                        // 只复制文件
                        outFile.outputFile.isFile.ifTrue {
                            copy {
                                from(outFile.outputFile)
                                into(outputFileDir)
                            }
                        }
                    }
                }
            }
        }
    }
}

//Android Gradle编译JNI Android.mk项目
ndk {
        moduleName "Test"
        ldLibs "log"
       abiFilters "armeabi", "armeabi-v7a", "x86" //输出指定三种abi体系结构下的so库，目前可有可无
}
sourceSets {
    main {
        jniLibs.srcDirs = ['libs', 'src/main/libs']
    }
}
repositories {
    flatDir {
        dirs 'libs', 'src/main/libs'
    }
}
import org.apache.tools.ant.taskdefs.condition.Os
tasks.withType(JavaCompile) {
    compileTask -> compileTask.dependsOn ndkBuild
}
String getNdkBuildPath() {
    Properties properties = new Properties()
    properties.load(project.rootProject.file('local.properties').newDataInputStream())
    def ndkBuildingDir = properties.getProperty("ndk.dir")
    def ndkBuildPath = ndkBuildingDir
    if (Os.isFamily(Os.FAMILY_WINDOWS)) {
        ndkBuildPath = ndkBuildingDir + '/ndk-build.cmd'
    } else {
        ndkBuildPath = ndkBuildingDir + '/ndk-build'
    }
    return ndkBuildPath
}
task ndkBuild(type: Exec, description: 'Compile JNI source via NDK') {
    println('executing ndkBuild')
    def ndkBuildPath = getNdkBuildPath();
    commandLine ndkBuildPath, '-j8', '-C', file('src/main').absolutePath
}
task ndkClean(type: Exec, description: 'clean JNI libraries') {
    println('executing ndkBuild clean')
    def ndkBuildPath = getNdkBuildPath();
    commandLine ndkBuildPath, 'clean', '-C', file('src/main').absolutePath
}
clean.dependsOn 'ndkClean'

使用KTransformers部署（保姆级教程）
KTransformers作为一个开源框架，专门为优化大规模语言模型的推理过程而设计。它支持GPU/CPU异构计算，并针对MoE架构的稀疏性进行了特别优化，可以有效降低硬件要求，允许用户在有限的资源下运行像DeepSeek-R1这样庞大的模型。KTransformers实现了强大的CPU+DDR5+24GB显存环境下本地运行DeepSeek-R1满血版的能力，大大降低了部署成本和技术门槛。
2. 实践环境描述
硬件配置：
CPU: 使用的是Intel Xeon Silver 4310 CPU @ 2.10GHz，拥有24个物理核心（每个插槽12个核心），支持超线程技术，总共有48个逻辑处理器。
内存: 系统配备了1T的DDR4内存，频率为3200MHz。
GPU: NVIDIA GeForce RTX 3090，显存为24GB。
软件环境：
操作系统版本：Ubuntu 22.04
CUDA版本：12.1
软件框架: KTransformers v0.2.1，支持DeepSeek-R1模型的本地推理。
模型参数：DeepSeek-R1-Q4_K_M
2. 环境准备与资源下载
KTransformers：
ktransformers：https://github.com/kvcache-ai/ktransformers
ktransformers安装指南：https://kvcache-ai.github.io/ktransformers/en/install.html
模型文件：
huggingface：https://huggingface.co/unsloth/DeepSeek-R1-GGUF
modelscope（国内推荐）：https://modelscope.cn/models/unsloth/DeepSeek-R1-GGUF
3. 实践过程
步骤一：环境搭建
CUDA 12.1及以上版本
如果您还没有安装CUDA，可以从这里下载并安装。
添加CUDA到PATH环境变量：
export PATH=/usr/local/cuda/bin:$PATH
export LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH
export CUDA_PATH=/usr/local/cuda
Linux-x86_64 系统，带有 gcc, g++ 和 cmake
更新包列表并安装必要的工具：
sudo apt-get update
sudo apt-get install gcc g++ cmake ninja-build
使用 Conda 创建虚拟环境
我们建议使用Conda来创建一个Python=3.11的虚拟环境来运行程序：
conda create --name ktransformers python=3.11
conda activate ktransformers  # 您可能需要先运行 `conda init` 并重新打开shell
确保安装了 PyTorch、packaging、ninja 等依赖项：
pip install torch packaging ninja cpufeature numpy
或者直接拉取已经构建好的docker镜像（推荐）：docker pull approachingai/ktransformers:0.2.1
下载源代码并编译
初始化源代码：
git clone https://github.com/kvcache-ai/ktransformers.git
cd ktransformers
git submodule init
git submodule update
博主提供已经git submodule update后的文件下载的ktransformers包（更新时间：20250218）：
链接: https://pan.baidu.com/s/1WvPK_lcLY9MdKxCWxoqonQ?pwd=mcbd 提取码: mcbd
安装（Linux）：
bash install.sh
步骤二：模型加载
下载Deepseek原模型配置文件
modelscope：https://modelscope.cn/models/deepseek-ai/DeepSeek-R1
huggingface：https://huggingface.co/deepseek-ai/DeepSeek-R1
博主分享的配置文件：
链接: https://pan.baidu.com/s/1XKdP2L0QmX7YPGkqi7ujgg?pwd=6p7v 提取码: 6p7v
检查一下配置文件是否完整
本地聊天测试命令如下：
numactl -N 1 -m 1 python ./ktransformers/local_chat.py --model_path <your model path> --gguf_path <your gguf path> --cpu_infer 33 --max_new_tokens 1000
参数说明
numactl -N 1 -m 1
使用numactl工具来绑定CPU核心和内存节点。这里的-N 1表示使用第1号CPU核心，-m 1表示使用第1号内存节点。这有助于提高多核系统的性能。
python ./ktransformers/local_chat.py
运行KTransformers的本地聊天Python脚本。
--model_path <your model path>
指定模型路径。可以是本地路径或在线Hugging Face路径（如deepseek-ai/DeepSeek-V3）。如果在线连接有问题，可以尝试使用镜像站点（如hf-mirror.com）。
--gguf_path <your gguf path>
指定GGUF格式的模型路径。由于GGUF文件较大，建议您下载到本地并根据需要进行量化处理。注意这里是指向包含GGUF文件的目录路径。
--cpu_infer 33
设置用于推理的CPU线程数。这里设置为33，可以根据您的硬件配置调整这个数值。
--max_new_tokens 1000
设置最大输出token长度。默认值为1000，如果您发现生成的答案被截断了，可以增加这个数值以生成更长的回答。但请注意，增加这个数值可能会导致内存不足（OOM），并且会降低生成速度。
示例
（以博主目录结构假设）模型路径为/root/DeepSeek-R1-GGUF，GGUF路径为/root/DeepSeek-R1-GGUF/DeepSeek-R1-Q4_K_M，那么完整的命令应
numactl -N 1 -m 1 python ./ktransformers/local_chat.py --model_path /root/DeepSeek-R1-GGUF --gguf_path /root/DeepSeek-R1-GGUF/DeepSeek-R1-Q4_K_M  --cpu_infer 33 --max_new_tokens 1000
部分加载日志
首次加载时间较长
步骤三：推理与测试
4. 实践结果
在复现KTransformers部署满血版DeepSeek-R1的过程中，我们遇到了一些性能上的差异。尽管已经按照官方指南进行了配置和优化，但最终的推理速度和效率并未达到预期水平。以下是具体的实践结果及分析。
测试结果
经过多次测试，我们得到了5.2 tokens/s的生成速度。
这些数据显示，在我们的实验环境中，模型的推理速度显著低于官方宣称14 tokens/s的生成速度。

分析原因
通过对比实验配置与官方推荐的最佳实践，我们发现以下几个关键因素可能导致了性能差异：
我们的测试平台使用的是Intel Xeon Silver 4310 CPU，而官方文档中提到的理想配置包括第四代至强可扩展处理器，这类处理器集成了高级矩阵扩展指令集（AMX），能够大幅提升计算密集型任务的执行效率。相比之下，Silver系列的处理器在处理能力上存在差距，特别是在需要大量矩阵运算的任务中表现不佳。
在内存方面，我们使用的DDR4内存虽然提供了足够的带宽和容量，但是与最新的DDR5内存相比，在读写速度上有明显的劣势。根据相关测试，DDR5内存的读写速度比DDR4内存高出约2000MB/s，提升幅度在35%~41%之间。这种速度上的差异可能影响到数据加载和处理的速度，进而影响整体的推理效率
虽然NVIDIA GeForce RTX 3090是一款高性能显卡，但在处理极其庞大的模型时，其24GB的显存限制可能成为瓶颈。相比之下，RTX 4090采用了更先进的架构，能够在相同条件下提供更高的计算能力和更好的能效比。这可能是导致我们在实际测试中未能达到理想推理速率的一个重要原因。
综上所述，为了进一步提升DeepSeek-R1模型在本地部署时的推理性能，建议考虑升级硬件配置，特别是选择支持AMX指令集的CPU、采用DDR5内存以及选用更高性能的GPU。


Qwen3-235B-A22B与KTransformers 0.3部署实践：源码安装与多并发测试全指南！
一、环境准备
#配置
测试总结：
1）#Qwen3-235B-A22B GGUF模型选择下载Q4_K_M（其它Q4版本如Q4_0不支持，报NotImplementedError错误）
2）cpu_infer默认情况下，四路并发时cpu存在瓶颈，拉低了每路的推理速度（2.73tps），设置合适cpu_infer消除瓶颈后，每路稳定到4.4tps
3）1k上下文+cpu_infer默认：单路推理速度 6.5tps，显存占用 10.4g，首次推理速度未减少；四路并发每路平均 2.73 tps，显存没明显变化，四路并发cpu存在瓶颈；
4）8k上下文+cpu_infer 62：单路推理速度 7.5 tps，显存占用 10.4g，首次推理速度未减少；四路并发每路平均 4.4 tps，显存没明显变化，四路并发cpu无瓶颈；
1，设置conda环境
# 新建环境
# Download Miniconda
# 从0.2.4版本升级（需卸载ktransformers）
pip list | grep ktransformers
说明：两种方式均可以编译成功
2，系统环境（libstdcxx-ng、torch、cuda等依赖项）
环境依赖安装参考kt0.2.4版本安装
DeepSeek-R1 671B + KTransformer 0.2.4 部署实践：源码安装 + 多并发测试
二、源码安装
1，下载源码
# Clone repository
2，编译安装
# Install single NUMA dependencies
3，模型准备
说明：原始模型model-*.safetensors文件不用下载
# 下载GGUF文件
# pip install huggingface_hub hf_transfer
注意：模型选择下载Q4_K_M（其它Q4版本如Q4_0不支持）
4，启动命令
# llamafile backend
说明：intel四代及以上支持AMX命令的使用第二个命令
python ktransformers/server/main.py \
参数说明：
--port：设置kt服务端口
三、测试体验
参数：1k上下文 + 四路并发 + cpu_infer 默认
1，启动kt推理服务 （1k + cpu_infer默认）
python ktransformers/server/main.py \
2，单路测试 ( 1k + cpu_infer 默认）
curl -X 'POST' \
# 单次首次推理速度 6.5 tps ( 1k + cpu_infer 默认）
# 单次非首次推理速度 6.5 tps ( 1k + cpu_infer 默认）
curl -X POST http://localhost:10002/v1/chat/completions \
# gpu使用
3，四路并发测试 ( 1k + cpu_infer 默认)
# 测试命令
curl -X 'POST' \
# 四路并发测试结果：每路平均速度 2.73 tps ( 1k + cpu_infer 默认)
# 场景1：四路同时在跑，单路平均 2.5tps
# 场景2：完成1路后，3路在跑，单路平均3.2tps
# 场景3：完成2路后，2路在跑，单路平均4.3tps
# 场景4：完成3路后，1路在跑，单路平均7.5tps
# gpu使用（基本没啥变化）
说明：cpu_infer默认情况下，四路并发时cpu存在瓶颈，拉低了每路的推理速
四、参数调优测试
参数：8k上下文 + 四路并发 + cpu_infer 62
1，启动kt服务 (8k + cpu_infer 62)
# 8k + cpu_infer 62 
2，单路测试（8k + cpu_infer 62)
测试场景一：数字比较
# 单路推理速度：7.5 tps （8k + cpu_infer 62）
# gpu使用（没什么变化）
# 测试场景二：扑克牌问题
curl -X POST http://localhost:10002/v1/chat/completions \
# 单路推理速度：7.5 tps （8k + cpu_infer 62）
# gpu使用（显存占用基本没变化）
3，四路并发测试（8k + cpu_infer 62)
curl -X POST http://localhost:10002/v1/chat/completions \
# 四路数字比较
# 四路推理速度：每路平均速度 4.44 tps （8k + cpu_infer 62)
# 场景1：四路同时在跑，单路平均 4.4tps
# 场景2：完成1路后，3路在跑，单路平均 4.4tps
# 场景3：完成2路后，2路在跑，单路平均4.4tps
# 场景4：完成3路后，1路在跑，单路平均7.7tps
# gpu使用（变化不大）
说明：
1）增加上下文，参数需满足： cache_lens > max_batch_size * max_new_tokens
2）设置cpu_infer参数，能明显提升推理速度，特别是思路并发
五、问题及总结
#Qwen3-235B-A22B #KTransformers 0.3
#KTransformers部署 #KTransformers多并发测试
问题1:
解决：进入项目根目录
git submodule update --init --recursive
问题2:
解决：在ktransformers/csrc/balance_serve/CMakeLists.txt里第一行增加以下设置
set(CMAKE_CUDA_STANDARD 17)
问题3:
解决：更换Qwen3-235B-A22B-GGUF模型，使用Q4_K_M版本


qwen3-235B部署步骤.md
Qwen3-235B-A22B部署步骤
官网：https://qwenlm.github.io/zh/blog/qwen3/
github：https://github.com/QwenLM/Qwen
魔搭千问官方的模型权重地址：https://modelscope.cn/models/Qwen/Qwen3-235B-A22B/
Hugging Face千问官方的模型权重地址：https://huggingface.co/Qwen/Qwen3-235B-A22B
unsloth提供的GGUF格式的权重地址：https://huggingface.co/unsloth/Qwen3-235B-A22B-GGUF
GGUF-Q4_K_M格式的权重地址：https://huggingface.co/lmstudio-community/Qwen3-235B-A22B-GGUF
ktransformers官方文档： https://kvcache-ai.github.io/ktransformers/en/injection_tutorial.html
transformers针对Qwen3的文档地址：https://github.com/kvcache-ai/ktransformers/blob/main/doc/en/AMX.md
flash-atte库地址:https://github.com/Dao-AILab/flash-attention/releases
qwen3推荐微调设置：https://docs.unsloth.ai/basics/qwen3-how-to-run-and-fine-tune
Qwen3 GPU内存需求和吞吐量：https://qwen.readthedocs.io/en/latest/getting_started/speed_benchmark.html
系统环境：PyTorch 2.5.1，Python 3.11(ubuntu22.04)，CUDA 12.4
GPU：RTX 4090D(24GB) * 4
CPU：60 vCPU Intel(R) Xeon(R) Platinum 8474C
内存：320GB
硬盘系统盘：30 GB
数据盘：180GB SSD
下载模型
# 由于实际下载时间可能持续4-6个小时，因此最好使用screen开启持久化会话，避免因为关闭会话导致下载中断。
# 安装screen工具用于持久化会话
sudo apt install screen -y
# 开启持久会话
screen -S kt
# 如果会话断开，可以输入如下命令回到之前的会话：
screen -r kt
# 使用 huggingface_hub 下载模型
pip install huggingface_hub
# 默认情况下，Huggingface会将下载文件保存在/root/.cache文件夹中，在 /root/autodl-tmp 下创建名为 HF_download 文件夹作为huggingface下载文件保存文件夹，这样模型就保存在磁盘而非系统盘
cd /root/autodl-tmp
mkdir -p HF_download Qwen3-235B-A22B-GGUF Qwen3-235B-A22B
#  配置HuggingFace下载目录环境变量，找到root文件夹下的 .bashrc 文件
echo 'export HF_HOME="/root/autodl-tmp/HF_download"' >> ~/.bashrc
source ~/.bashrc
# 在AutoDL开启学术资源加速，（针对HuggingFace等境外资源加速）
# 文档：https://www.autodl.com/docs/network_turbo/
source /etc/network_turbo
# 方式一：使用jupyter下载模型权重
# 进入下载目录：
cd /root/autodl-tmp
# 启动Jupyter
jupyter lab --allow-root
# 开启AutoDL隧道工具可以让本地访问服务器的jupyter，并使用jupyter下载模型权重
# 文档：https://www.autodl.com/docs/ssh_proxy/
# 访问Jupyter Web：http://127.0.0.1:8889/lab?token=d05632341ad9255a31ed844b5d1737604d5d1983b1fa918a
# 这个是Q4_K_M的模型文件:
# lmstudio社区模型下载地址： https://huggingface.co/lmstudio-community/Qwen3-235B-A22B-GGUF
# Q4_K_M 参考文档：D:\deepseek_ubuntu本地部署\ktransformers\doc\zh\install.md
# 页面创建一个ipynb文件运行以下代码：
from huggingface_hub import snapshot_download
snapshot_download(
    repo_id = 'lmstudio-community/Qwen3-235B-A22B-GGUF',
    local_dir = '/root/autodl-tmp/Qwen3-235B-A22B-GGUF',
    allow_patterns = ['*Q4_K_M*'],
)
# 方式二：使用python代码下载特定量化模型
# 使用Python代码下载Qwen3-235B-A22B-GGUF-Q4_K_M量化模型（133GB，推荐选择，平衡性能和质量）
python -c "
from huggingface_hub import snapshot_download
snapshot_download(
    repo_id = 'unsloth/Qwen3-235B-A22B-GGUF',
    local_dir = '/root/autodl-tmp/Qwen3-235B-A22B-GGUF',
    allow_patterns = ['*Q4_K_M*'],
)
# 如果需要AMX优化(仅适用于支持AMX的CPU)，可以下载BF16版本
# 注意：BF16版本约470GB，需要确保有足够存储空间
# 参考文档 D:\deepseek_ubuntu本地部署\ktransformers\doc\zh\AMX.md
# 下载地址：https://huggingface.co/unsloth/Qwen3-235B-A22B-GGUF/tree/main/BF16
# python -c "
# from huggingface_hub import snapshot_download
# snapshot_download(
#     repo_id = 'unsloth/Qwen3-235B-A22B-GGUF',
#     local_dir = '/root/autodl-tmp/Qwen3-235B-A22B-GGUF',
#     allow_patterns = ['*BF16*'],
# )
# "
# 模型权重下载完成需要取消学术加速，避免对正常网络造成影响
unset http_proxy && unset https_proxy
# 下载 Qwen3-235B-A22B 原版模型的配置文件
# 根据KTransformer的要求，还需要下载 Qwen3-235B-A22B 原版模型的除了模型权重文件外的其他配置文件，方便进行灵活的专家加载。# 因此我们还需要使用 modelscope 下载 Qwen3-235B-A22B 模型除了模型权重（.safetensors）外的其他全部文件，可以按照如下方式进行下载，地址：https://modelscope.cn/models/Qwen/Qwen3-235B-A22B/
# Qwen3并没有提供模型架构代码，但是KTransformers自行实现了一套代码(Qwen3 MoE(混合专家)模型的核心实现)，用于读取Qwen3的模型配置文件，并进行专家加载。代码地址：D:\deepseek_ubuntu本地部署\ktransformers\ktransformers\models\modeling_qwen3_moe.py
# 安装魔搭
pip install modelscope
# 进入下载目录：
cd /root/autodl-tmp
# 下载Qwen3-235B-A22B模型配置文件（不包含模型权重）
modelscope download --model Qwen/Qwen3-235B-A22B --exclude '*.safetensors' --local_dir /root/autodl-tmp/Qwen3-235B-A22B
# 最终我们是下载了 Qwen3-235B-A22B-GGUF-Q4_K_M 模型权重和 Qwen3-235B-A22B 的模型配置文件，并分别保存在两个文件夹中：
Qwen3-235B-A22B-GGUF-Q4_K_M 模型权重地址：/root/autodl-tmp/Qwen3-235B-A22B-GGUF
Qwen3-235B-A22B 的模型配置文件地址：/root/autodl-tmp/Qwen3-235B-A22B
# 检查GGUF模型文件
ls -lh /root/autodl-tmp/Qwen3-235B-A22B-GGUF/
# 检查模型配置文件
ls -lh /root/autodl-tmp/Qwen3-235B-A22B/
安装基础依赖
# 1. 创建独立Python环境,防止对系统环境造成兼容性影响
# 创建Python 3.11环境（KTransformers在3.11下测试更充分）
conda init bash # 初始化conda环境
source ~/.bashrc # 使环境变量生效
# 创建 Python 3.11 环境，kt311 是环境名称
conda create -n kt311 python=3.11 -y
# 激活环境
conda activate kt311
# 2. 安装系统依赖
# 基础编译工具，参考文档：D:\deepseek_ubuntu本地部署\ktransformers\doc\zh\install.md
sudo apt-get update
sudo apt-get install -y gcc g++ build-essential cmake ninja-build patchelf
# 多并发支持依赖（balance_serve后端需要），Balance Serve是KTransformers框架中的一个组件，主要用于实现多并发支持。
# 参考文档：D:\deepseek_ubuntu本地部署\ktransformers\doc\zh\install.md
sudo apt install -y libtbb-dev libssl-dev libcurl4-openssl-dev libaio1 libaio-dev libgflags-dev zlib1g-dev libfmt-dev libnuma-dev
# 3.升级libstdc++（针对 Ubuntu 22.04 需要添加）
# 参考文档：D:\deepseek_ubuntu本地部署\ktransformers\doc\zh\FAQ.md
# 安装软件源工具
sudo apt-get install -y software-properties-common
# 添加 Ubuntu Toolchain PPA
sudo add-apt-repository -y ppa:ubuntu-toolchain-r/test
sudo apt-get update
# 升级libstdc++6
sudo apt-get install -y --only-upgrade libstdc++6
# 确保conda环境的libstdc++也是更新到最新版本C++标准库
# 参考文档：D:\deepseek_ubuntu本地部署\ktransformers\doc\zh\install.md
conda install -c conda-forge libstdcxx-ng -y
# 验证libstdc++版本（应包含3.4.32）
strings /usr/lib/x86_64-linux-gnu/libstdc++.so.6 | grep GLIBCXX | tail
# 4. 安装 Python 依赖和基础环境依赖
# 参考文档：D:\deepseek_ubuntu本地部署\ktransformers\doc\zh\balance-serve.md
# ktransformers对于0.3版本的PyTorch使用的是2.7.0版本进行测试的，所以需要安装2.7.0版本的PyTorch以及配套的torchvision和torchaudio
pip install torch==2.7.0 torchvision==0.22.0 torchaudio==2.7.0 --index-url https://download.pytorch.org/whl/cu126
pip install packaging ninja cpufeature numpy openai
# 验证 torch 版本
python -c "import torch; print(torch.__version__)"
# 验证 torchvision 版本
python -c "import torchvision; print(torchvision.__version__)"
# 5. 安装Flash-Attention（flash attention的实现比标准注意力机制更高效）
# 参考文档：D:\deepseek_ubuntu本地部署\ktransformers\doc\zh\install.md
# 验证 CUDA 版本
nvcc --version
# 当前环境：CUDA 12.4 Python 3.11 PyTorch 2.7.0
# 进入数据盘目录
cd autodl-tmp/
# 先卸载可能已经安装的版本
pip uninstall -y flash-attn
# Flash-Attention 安装地址：https://github.com/Dao-AILab/flash-attention/releases
# 最合适的 flash_attn 地址：https://github.com/Dao-AILab/flash-attention/releases/download/v2.7.4.post1/flash_attn-2.7.4.post1+cu12torch2.6cxx11abiTRUE-cp311-cp311-linux_x86_64.whl
# 这个版本有以下特点：
# cu12: 适用于CUDA 12.x
# torch2.6: 专门为PyTorch 2.7构建（匹配PyTorch 2.7.0）
# cp311: 针对Python 3.11构建
# cxx11abiTRUE: 与PyTorch 2.7.0版本的ABI兼容
# linux_x86_64: 适用于Linux x86_64平台
# 下载适合PyTorch 2.7.0的预编译wheel
wget https://github.com/Dao-AILab/flash-attention/releases/download/v2.7.4.post1/flash_attn-2.7.4.post1+cu12torch2.6cxx11abiTRUE-cp311-cp311-linux_x86_64.whl
pip install ./flash_attn-2.7.4.post1+cu12torch2.6cxx11abiTRUE-cp311-cp311-linux_x86_64.whl
# 验证安装
python -c "import flash_attn; print(flash_attn.__version__)"
构建web服务
  # 参考文档：D:\deepseek_ubuntu本地部署\ktransformers\doc\zh\api\server\website.md
  sudo apt-get update -y && sudo apt-get install -y apt-transport-https ca-certificates curl gnupg
  curl -fsSL https://deb.nodesource.com/gpgkey/nodesource-repo.gpg.key | sudo gpg --dearmor -o /usr/share/keyrings/nodesource.gpg
  sudo chmod 644 /usr/share/keyrings/nodesource.gpg
  echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/nodesource.gpg] https://deb.nodesource.com/node_23.x nodistro main" | sudo tee /etc/apt/sources.list.d/nodesource.list
  # 确保安装新版Node.js
  sudo apt-get update -y
  sudo apt-get install nodejs -y
  # 进入网站目录并安装Vue CLI
  cd /root/autodl-tmp/ktransformers/website
  npm install @vue/cli
  # 构建前端项目
  npm run build
ktransformers安装步骤
# 确保conda环境激活
conda activate kt311
# 卸载现有ktransformers
pip uninstall -y ktransformers
# 删除旧仓库文件
rm -rf /root/autodl-tmp/ktransformers
# 开启学术加速
source /etc/network_turbo
# 进入数据盘目录
cd /root/autodl-tmp
# 克隆KTransformers仓库
git clone https://github.com/kvcache-ai/ktransformers.git
# 取消学术加速
unset http_proxy && unset https_proxy
# 进入KTransformers目录
cd ktransformers
# 初始化和更新子模块
git submodule update --init --recursive
# 检查AMX支持（对于使用AMX优化部署方案）
# 参考文档：D:\deepseek_ubuntu本地部署\ktransformers\doc\zh\AMX.md
lscpu | grep -i amx
# 如果输出中包含amx-bf16、amx-int8和amx-tile，说明CPU支持AMX
# 例如：Flags: ... amx-bf16 amx-int8 amx-tile ...
# 如果没有找到AMX相关标志，您的CPU可能不支持AMX，或AMX在BIOS中被禁用
# 根据CPU配置选择安装方式，获取详细的GPU计算能力信息
nvidia-smi --query-gpu=name,compute_cap --format=csv
# 当前RTX 4090 D具有8.9的计算能力
# 8.9代表Hopper架构（如H100 GPU）的计算能力，9.0代表最新的Blackwell架构，+PTX表示包含PTX中间代码，确保向后兼容性
(kt311) root@autodl-container-b4bd4c9525-4d58915a:~# nvidia-smi --query-gpu=name,compute_cap --format=csv
name, compute_cap
NVIDIA GeForce RTX 4090 D, 8.9
NVIDIA GeForce RTX 4090 D, 8.9
NVIDIA GeForce RTX 4090 D, 8.9
NVIDIA GeForce RTX 4090 D, 8.9
# 设置环境变量，在编译KTransformers时针对特定的NVIDIA GPU架构进行优化
# 这个设置确保KTransformers编译出来的代码能够最大限度地发挥GPU硬件性能
# 参考：D:\deepseek_ubuntu本地部署\ktransformers\Dockerfile
export TORCH_CUDA_ARCH_LIST="8.9;9.0+PTX"
# 查看系统NUMA节点配置，确定CPU拓扑结构
lscpu | grep NUMA
# 输出结果：
# 系统有2个NUMA节点，这通常对应于2个物理CPU插槽
# 第一个CPU插槽控制着逻辑CPU核心0-47和96-143
# 第二个CPU插槽控制着逻辑CPU核心48-95和144-191
NUMA node(s):                       2
NUMA node0 CPU(s):                  0-47,96-143
NUMA node1 CPU(s):                  48-95,144-191
# 安装numactl工具，在启用USE_NUMA=1和USE_BALANCE_SERVE=1后，系统会根据NUMA信息优化任务调度
# KTransformers在启用USE_NUMA=1时需要numactl工具及其库来访问和管理NUMA节点信息
# 如果没有这个工具，系统无法获取正确的NUMA拓扑，导致NUMA优化无效
apt-get install -y numactl
# 检查和确认系统的NUMA(非统一内存访问)架构信息
numactl --hardware
# NUMA优化对于多插槽服务器至关重要
# NUMA（Non-Uniform Memory Access）是一种内存架构，在多插槽服务器中，每个CPU插槽都有自己的本地内存
# 当一个CPU核心访问另一个CPU插槽的内存时，会产生额外的延迟，这称为NUMA惩罚
# KTransformers的NUMA优化可以确保计算任务尽可能在本地内存上执行，减少跨NUMA节点访问
# NUMA优化配置选择指南：
# 1. 对于双插槽或多插槽服务器：启用NUMA支持（USE_NUMA=1）
#    - 这将使KTransformers根据CPU拓扑结构优化线程分配，使其合理分配计算任务
#    - 对于MoE（混合专家）模型如DeepSeek-V3 或 Qwen3-235B，NUMA优化可以显著提高推理性能
#    - 特别是在处理多并发请求时，减少跨NUMA节点访问，可以减少内存访问延迟
# 2. 对于单插槽服务器：不需要启用NUMA支持
#    - 单插槽服务器没有NUMA架构，所有CPU核心访问内存的延迟相同
#    - 在这种情况下，启用NUMA支持不会带来性能提升，反而可能增加不必要的开销
# 1. 对于双槽服务器(60+ vCPU)，启用NUMA支持和多并发功能
# 参考文档：D:\deepseek_ubuntu本地部署\ktransformers\doc\zh\balance-serve.md
# 在命令行中设置环境变量：
export USE_NUMA=1 # 启用NUMA支持，优化多核CPU性能
export USE_BALANCE_SERVE=1 # 启用多并发支持，实现高效请求处理
export KTRANSFORMERS_FORCE_BUILD=TRUE # 强制重新编译，确保使用最新的代码和配置
# 打印环境变量确认设置成功
echo $USE_NUMA
echo $USE_BALANCE_SERVE
echo $KTRANSFORMERS_FORCE_BUILD
# 在同一命令行中设置环境变量并执行安装脚本：
USE_NUMA=1 USE_BALANCE_SERVE=1 KTRANSFORMERS_FORCE_BUILD=TRUE bash ./install.sh
# 安装完成后验证NUMA配置是否生效
# 如果返回True，说明NUMA支持已成功启用
# 如果返回False，可能是因为在容器环境中NUMA支持受限，或者libnuma-dev未正确安装
# python -c "import ktransformers; print('NUMA支持：', hasattr(ktransformers, 'numa_available') and ktransformers.numa_available())"
# 2. 对于不支持AMX的CPU或单NUMA节点系统,正确做法（在同一命令行中设置环境变量并执行安装脚本）：
export USE_BALANCE_SERVE=1 # 启用多并发支持，实现高效请求处理
USE_BALANCE_SERVE=1 KTRANSFORMERS_FORCE_BUILD=TRUE bash ./install.sh
# 查看ktransformers安装版本
pip show ktransformers
# 验证 ktransformers 安装是否成功
python -c "import ktransformers; print(ktransformers.__version__)"
# 验证 NUMA 支持（如果启用了USE_NUMA=1），查看进程的NUMA映射
test -f /proc/self/numa_maps && echo "NUMA支持已启用" || echo "NUMA未启用"
启动KTransformers服务（普通版）
# 确保处于ktransformers目录下
cd /root/autodl-tmp/ktransformers
# 确保激活Python环境
conda activate kt311
# 确保在命令行中设置环境变量：
export USE_NUMA=1 # 启用NUMA支持，优化多核CPU性能
export USE_BALANCE_SERVE=1 # 启用多并发支持，实现高效请求处理
export KTRANSFORMERS_FORCE_BUILD=TRUE # 强制重新编译，确保使用最新的代码和配置
# 验证NUMA支持（如果启用了USE_NUMA=1），查看进程的NUMA映射
test -f /proc/self/numa_maps && echo "NUMA支持已启用" || echo "NUMA未启用"
# 启动KTransformers服务，使用Q4_K_M模型权重和配置文件
# 简单启动：
# 参考文档：D:\deepseek_ubuntu本地部署\ktransformers\doc\zh\AMX.md
python ktransformers/server/main.py --architectures Qwen3MoeForCausalLM --model_path /root/autodl-tmp/Qwen3-235B-A22B --gguf_path /root/autodl-tmp/Qwen3-235B-A22B-GGUF --optimize_config_path ktransformers/optimize/optimize_rules/Qwen3Moe-serve.yaml --backend_type balance_serve
# 解释：
1. 通过 --model_path 和 --architectures Qwen3MoeForCausalLM 参数，系统会知道需要加载 Qwen3 MoE 架构的模型
2. KTransformers框架内部会根据 architectures 参数查找并加载对应的模型类，这个过程中会自动导入这两个文件：
  - ktransformers/ktransformers/models/modeling_qwen3_moe.py
  - ktransformers/ktransformers/models/configuration_qwen3_moe.py
  - configuration_qwen3_moe.py：定义了Qwen3MoeConfig类，包含模型的所有超参数
  - modeling_qwen3_moe.py：实现了模型的核心架构，包括Qwen3MoeForCausalLM类
3. 框架在初始化时，会先从model_path加载模型原版配置文件（config.json），然后用 Qwen3MoeConfig 解析这些配置
4. 然后使用这些配置实例化Qwen3MoeForCausalLM类来创建模型
5. 我们使用--optimize_config_path ktransformers/optimize/optimize_rules/Qwen3Moe-serve.yaml 指定了优化配置
6. 这个YAML文件专门为Qwen3 MoE模型进行了优化配置。它通过一系列优化规则，定义了模型各组件的执行位置（CPU/GPU），它会引用 modeling_qwen3_moe.py 中定义的类和方法，将实现替换为优化版本。
7. 实际执行流程：
  → 解析命令行参数 
  → 加载模型配置(config.json)
  → 使用configuration_qwen3_moe.py解析配置
  → 使用modeling_qwen3_moe.py创建模型结构
  → 加载GGUF格式的权重
  → 应用Qwen3Moe-serve.yaml中的优化规则
  → 启动服务
# 完整启动并启用web服务：
# 参考文档：D:\deepseek_ubuntu本地部署\ktransformers\doc\zh\balance-serve.md
python ktransformers/server/main.py \
  --architectures Qwen3MoeForCausalLM \
  --model_path /root/autodl-tmp/Qwen3-235B-A22B \
  --gguf_path /root/autodl-tmp/Qwen3-235B-A22B-GGUF \
  --optimize_config_path ktransformers/optimize/optimize_rules/Qwen3Moe-serve.yaml \
  --port 10002 \
  --cpu_infer 54 \
  --chunk_size 256 \
  --max_new_tokens 4096 \
  --max_batch_size 4 \
  --cache_lens 32768 \
  --backend_type balance_serve \
  --web True
  --architectures：指定模型架构
  --model_path：指向您在/root/autodl-tmp/Qwen3-235B-A22B的模型配置文件路径
  --gguf_path：指向您在/root/autodl-tmp/Qwen3-235B-A22B-GGUF的GGUF权重文件
  --optimize_config_path：使用Qwen3Moe-serve.yaml配置文件
  --port：服务端口，默认10002
  --cpu_infer 54：设为54,确保内存不会溢出导致崩溃
  --chunk_size：引擎在单次运行中一次性处理的最大token数
  --max_new_tokens：每次请求生成的最大新token数量
  --max_batch_size：引擎在单次运行中能够处理的最大并发请求数
  --cache_lens: 调度器分配的KV缓存总长度，所有并发请求共享此空间，更大的缓存长度支持处理更长的上下文或更多的并发请求，确保cache_lens > max_batch_size * max_new_tokens才能支持满载并发
  --backend_type balance_serve：启用多并发支持，实现高效请求处理
  --web True：启用Web界面，可通过浏览器访问
# 访问web服务：http://127.0.0.1:10002/web/index.html#/chat
测试API
# 获取模型列表
curl http://localhost:10002/v1/models
# 简单测试
# 微调参数参考：https://docs.unsloth.ai/basics/qwen3-how-to-run-and-fine-tune
curl -X POST http://localhost:10002/v1/chat/completions \
  -H "accept: application/json" \
  -H "Content-Type: application/json" \
  -d '{
    "messages": [
      {"role": "user", "content": "你好，请介绍一下自己 /no_think"}
    ],
    "model": "Qwen3-235B-A22B",
    "Min_P": 0.0,
    "temperature": 0.6,
    "top_p": 0.95,
    "top_k": 20
  }'
curl -X POST http://localhost:10002/v1/chat/completions \
  -H "accept: application/json" \
  -H "Content-Type: application/json" \
  -d '{
    "messages": [
      {"role": "user", "content": "你是谁"}
    ],
    "model": "Qwen3-235B-A22B",
    "Min_P": 0.0,
    "temperature": 0.6,
    "top_p": 0.95,
    "top_k": 20
}'
安装 open-webui
# 确保激活Python环境
conda activate kt311
# 进入数据盘目录
cd /root/autodl-tmp
# 安装open-webui
pip install open-webui
# 设置离线模式
export HF_HUB_OFFLINE=1
# 启动open-webui
open-webui serve
# 访问open-webui：http://127.0.0.1:8080/
# 卸载open-webui
pip show open-webui
pip uninstall open-webui -y
# 如果上面的不管用，就根据依赖安装地址手动卸载 rm -rf **/open_webui
# 检查是否有残留数据库
find ~ -name "*.db" | grep -i webui
启动KTransformers服务（AMX版，如果CPU支持且下载了BF16模型权重）
# 确保处于ktransformers目录下
cd /root/autodl-tmp/ktransformers
# 激活Python环境
conda activate kt311
# 检查CPU是否支持AMX指令集
lscpu | grep -i amx
# 如果输出包含amx-bf16, amx-int8, amx-tile说明CPU支持AMX指令集
# 启动KTransformers服务
# 注意：目前AMX版本只能读取BF16 GGUF文件
python ktransformers/server/main.py \
  --architectures Qwen3MoeForCausalLM \
  --model_path /root/autodl-tmp/Qwen3-235B-A22B \
  --gguf_path /root/autodl-tmp/Qwen3-235B-A22B-GGUF-BF16 \
  --optimize_config_path ktransformers/optimize/optimize_rules/Qwen3Moe-serve-amx.yaml \
  --backend_type balance_serve \
  --port 10002 \
  --cpu_infer 56 \
  --chunk_size 256 \
  --max_new_tokens 4096 \
  --max_batch_size 4 \
  --cache_lens 16384 \
  --web True
性能监控和调优
# 1. 内存监控
# 监控系统内存使用情况
watch -n 2 free -h
# 如果内存不足，可以调整以下参数：
# --chunk_size 128  # 降低单次处理的标记数
# --max_batch_size 4  # 降低批处理大小
# --absorb_for_prefill True  # 启用矩阵吸收减少内存使用
# 2. GPU内存监控
watch -n 2 nvidia-smi
# 5个32GB vGPU足够运行DeepSeek-V3，如果GPU内存不足，考虑：
# 1. 使用更低精度量化模型(Q3_K_M或Q2_K)
# 2. 减小batch_size和cache_lens参数
# 3.CPU使用监控
# 监控CPU使用情况
htop
# 优化参数：
# --cpu_infer: 可在50-58之间调整，找到最佳性能点
# 如果观察到NUMA节点间不平衡，可以尝试numactl绑定
# 4.多并发优化
# --max_batch_size: 对于5个32GB GPU，可以设置为6-8
# --chunk_size: 256是平衡速度和内存的好选择
# --cache_lens: 确保 cache_lens > max_batch_size * max_new_tokens
# 确保USE_BALANCE_SERVE=1已启用，以支持高效多并发
# 5. libstdc++问题排查：
# 如果出现version 'GLIBCXX_X.X.XX' not found错误，需重新执行libstdc++升级步骤
# 确保conda环境和系统环境都有最新版本
配置调优建议
以下是一些可以尝试的配置组合，用于不同场景优化：
高吞吐量配置（适合多用户并发）：
--max_batch_size 8 --chunk_size 512 --cache_lens 32768 --max_new_tokens 2048
长上下文配置（适合单用户，需要长文档处理）：
--max_batch_size 2 --chunk_size 256 --cache_lens 32768 --max_new_tokens 8192
平衡配置（通用场景）：
--max_batch_size 4 --chunk_size 256 --cache_lens 32768 --max_new_tokens 4096


Ubuntu22.04系统安装使用Docker
1.安装Docker
  本机系统：
Linux boss-dog 6.8.0-52-generic #53~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Wed Jan 15 19:18:46 UTC 2 x86_64 x86_64 x86_64 GNU/Linux
  Docker 可以安装在 64 位的 x86 平台或 ARM 平台上。Ubuntu 发行版中，LTS（Long-Term-Support）长期支持版本，会获得 5 年的升级维护支持，这样的版本会更稳定，因此在生产环境中推荐使用 LTS 版本。
Docker官方安装文档：https://docs.docker.com/engine/install/ubuntu/
1.1 安装步骤
1.卸载旧版本
旧版本的 Docker 称为 docker 或者 docker-engine，使用以下命令卸载旧版本：
sudo apt-get remove docker docker-engine docker.io
2.由于 apt 源使用 HTTPS 以确保软件下载过程中不被篡改，因此首先需要添加使用 HTTPS 传输的软件包以及 CA 证书
sudo apt-get update
sudo apt-get install apt-transport-https ca-certificates curl gnupg lsb-release
3.为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥
curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
4.向 sources.list 中添加 Docker 软件源
echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
# 以上命令会添加稳定版本的 Docker APT 镜像源，如果需要测试版本的 Docker 请将 stable 改为 test
5.更新 apt 软件包缓存，并安装 docker-ce
sudo apt-get update
sudo apt-get install docker-ce docker-ce-cli containerd.io
6.查看docker是否安装成功，如果是普通用户有些指令可能没有权限，可以将当前用户添加到 Docker 组
docker -v
docker info
# 将当前用户添加到 Docker 组
sudo usermod -aG docker boss-dog
newgrp docker
groups boss-dog
7.配置镜像加速器
# 输入docker run --rm hello-world有时会报超时，需要配置镜像加速器
sudo mkdir -p /etc/docker
echo '{
  "registry-mirrors": [
    "https://docker.m.daocloud.io",
    "https://szmlw1af.mirror.aliyuncs.com",
    "https://docker.mirrors.ustc.edu.cn"
  ]
}' | sudo tee /etc/docker/daemon.json
sudo systemctl restart docker
sudo systemctl restart docker
2.Docker命令
2.1 服务相关命令
启动docker服务
systemctl start docker
停止docker服务
systemctl stop docker
重启docker服务
systemctl restart docker
查看docker服务状态
systemctl status docker
设置开机启动docker服务
systemctl enable docker
2.2 镜像相关命令
查看镜像：查看本地所有的镜像
docker images
docker images -q # 查看所用镜像的id
搜索镜像：从网络中查找需要的镜像
docker search 镜像名称
拉取镜像：从docker仓库下载镜像到本地，镜像名称格式为名称：版本号，如果版本号不指定则是最新的版本。
如果不知道镜像版本，可以去 docker hub搜索对应镜像查看。
docker pull 镜像名称
拉取指定CPU架构并且指定ubuntu版本的docker：
# aarch64 (arm v8) CPU架构：
docker pull --platform=linux/aarch64 ubuntu:22.04
# x86_64 CPU架构：
docker pull --platform=linux/x86_64 ubuntu:22.04
查看镜像的架构：
docker image inspect ubuntu:22.04 | grep Architecture
# "Architecture": "arm64",
查看主机架构：
arch
# x86_64
删除镜像：删除本地镜像
docker rmi 镜像id # 删除指定本地镜像
docker rmi `docker images -q`  # 删除所有本地镜像
2.3 容器相关命令
查看容器
docker ps  #查看正在运行的容器
docker ps -a  #查看所有容器
创建并启动容器
docker run 参数
进入 容器
docker exec 参数 容器名称/容器id bash
docker exec -it test bash
停止容器
docker stop 容器名称/容器id
启动容器
docker start 容器名称/容器id
删除容器：如果容器是运行状态则删除失败，需要停止容器才能删除。
docker rm 容器名称/容器id
查看容器信息
docker inspect 容器名称/容器id
3.Docker容器的数据卷
3.1 数据卷概念
数据卷
数据卷是宿主机中的一个目录或文件
当容器目录和数据卷目录绑定后，对方的修改会立即同步
一个数据卷可以被多个容器同时挂载
一个容器也可以挂在多个数据卷
3.2 数据卷作用
容器数据持久化
外部机器和容器间接通信
容器之间数据交换
3.3 数据卷配置
创建启动容器时，使用-v参数设置数据卷
docker run … -v 宿主机目录（文件）：容器目录（文件）…
注意事项：
目录必须是绝对路径（/开头是绝对，./开头是相对)
如果目录不存在，会自己创建
可以挂载多个数据卷
一个容器挂载多个数据卷：
docker run -it --name=c2 \
 -v ~/data2:/root/data2 \
 -v ~/data3:/root/data3 \
 centos:7
centos:7表示镜像为centor，版本为7
一个数据卷挂载多个容器：
docker run -it --name=c3 -v ~/data:/root/data centos:7
docker run -it --name=c4 -v ~/data:/root/data centos:7
3.4 数据卷容器
多容器进行数据交换：
1.多个容器挂载同一个数据卷
2.数据卷容器
配置数据卷容器
1.创建启动c3数据卷容器，使用-v参数设置数据卷
docker run -it --name=c3 -v /volume centos:7 /bin/bash
​ c3容器的目录是/volume,宿主机目录会自己分配一个，可以使用docker inspect 容器名称/容器id指令进行查看。
2.创建启动c1，c2容器，使用--volumes-from 参数设置数据卷
docker run -it --name=c1 --volumes-from c3 centos:7 /bin/bash
docker run -it --name=c2 --volumes-from c3 centos:7 /bin/bash
​ c1和c2容器的目录也是/volume，宿主机目录和c3是同一个目录。
4.常用指令
docker ps -a
docker stop 603ff4a03cffe2278b2
docker rm 603ff4a03cffe2278b2
# 拷贝本机上的文件到docker环境中
docker cp test.zip 62471a960847:/root/opencv/lib_cmake
# 拷贝docker环境中的文件到本机上
docker cp <容器ID或容器名称>:<容器内路径> <本机路径>
docker cp my_container:/usr/local/myfolder /home/user/myfolder


https://github.com/taisuii/rusda编译
0x1 frida 编译流程
建立一个项目目录并拉下frida源码，并进入项目目录
git clone --recurse-submodules -b 16.2.1 https://github.com/frida/frida
cd frida
此时执行ls ，看到的文件应当是如此
(base) r@ubuntu20:~/Documents/FRIDA/frida$ ls
BSDmakefile      COPYING     frida-gum     frida.sln    Makefile.freebsd.mk  Makefile.toolchain.mk
build            frida-clr   frida-node    frida-swift  Makefile.linux.mk    README.md
config.mk        frida-core  frida-python  frida-tools  Makefile.macos.mk    releng
CONTRIBUTING.md  frida-go    frida-qml     Makefile     Makefile.sdk.mk
一键 安装nodejs22
# 构造下载 URL
NODE_TAR_URL="https://nodejs.org/dist/v22.12.0/node-v22.12.0-linux-x64.tar.xz"
wget $NODE_TAR_URL 
# 解压 Node.js 安装包到用户目录
tar -xf node-v22.12.0-linux-x64.tar.xz -C $HOME/bin
rm -r node-v22.12.0-linux-x64.tar.xz
# 设置 NODE_HOME 和 PATH
export NODE_HOME=$HOME/bin/node-v22.12.0-linux-x64
export PATH=${NODE_HOME}/bin:$PATH
# 打印 Node.js 版本以确认安装成功
node -v
(base) r@ubuntu20:~/Documents/FRIDA/frida$ # 构造下载 URL
(base) r@ubuntu20:~/Documents/FRIDA/frida$ NODE_TAR_URL="https://nodejs.org/dist/v22.12.0/node-v22.12.0-linux-x64.tar.xz"
(base) r@ubuntu20:~/Documents/FRIDA/frida$ wget $NODE_TAR_URL 
--2024-12-09 23:31:18--  https://nodejs.org/dist/v22.12.0/node-v22.12.0-linux-x64.tar.xz
正在解析主机 nodejs.org (nodejs.org)... 198.18.1.205
正在连接 nodejs.org (nodejs.org)|198.18.1.205|:443... 已连接。
已发出 HTTP 请求，正在等待回应... 200 OK
长度： 29734248 (28M) [application/x-xz]
正在保存至: “node-v22.12.0-linux-x64.tar.xz”
node-v22.12.0-linux-x64.tar.xz          100%[============================================================================>]  28.36M  8.89MB/s    用时 3.2s  
2024-12-09 23:31:21 (8.89 MB/s) - 已保存 “node-v22.12.0-linux-x64.tar.xz” [29734248/29734248])
(base) r@ubuntu20:~/Documents/FRIDA/frida$ # 解压 Node.js 安装包到用户目录
(base) r@ubuntu20:~/Documents/FRIDA/frida$ tar -xf node-v22.12.0-linux-x64.tar.xz -C $HOME/bin
(base) r@ubuntu20:~/Documents/FRIDA/frida$ # 设置 NODE_HOME 和 PATH
(base) r@ubuntu20:~/Documents/FRIDA/frida$ export NODE_HOME=$HOME/bin/node-v22.12.0-linux-x64
(base) r@ubuntu20:~/Documents/FRIDA/frida$ export PATH=${NODE_HOME}/bin:$PATH
(base) r@ubuntu20:~/Documents/FRIDA/frida$ # 打印 Node.js 版本以确认安装成功
(base) r@ubuntu20:~/Documents/FRIDA/frida$ node -v
v22.12.0
(base) r@ubuntu20:~/Documents/FRIDA/frida$ ls
BSDmakefile      COPYING     frida-go    frida-python  frida-swift  Makefile.freebsd.mk  Makefile.sdk.mk                 README.md
config.mk        frida-clr   frida-gum   frida-qml     frida-tools  Makefile.linux.mk    Makefile.toolchain.mk           releng
CONTRIBUTING.md  frida-core  frida-node  frida.sln     Makefile     Makefile.macos.mk    node-v22.12.0-linux-x64.tar.xz
(base) r@ubuntu20:~/Documents/FRIDA/frida$ rm -r node-v22.12.0-linux-x64.tar.xz
(base) r@ubuntu20:~/Documents/FRIDA/frida$ 
再make一下
make
安装ndk
执行以下命令，查看所需要的ndk版本，得到以下输出
cat releng/setup-env.sh |grep "ndk_required="
(base) r@ubuntu20:~/Documents/FRIDA/frida$ cat releng/setup-env.sh |grep "ndk_required="
  ndk_required=25
一键安装ndk25
wget https://dl.google.com/android/repository/android-ndk-r25c-linux.zip
unzip android-ndk-r25c-linux.zip $HOME/bin/
rm -r android-ndk-r25c-linux.zip
export ANDROID_NDK_ROOT=$HOME/bin/android-ndk-r25c
export PATH=$ANDROID_NDK_ROOT:$PATH
ndk-build -v
安装依赖
sudo apt update
sudo apt-get install build-essential git lib32stdc++-9-dev libc6-dev-i386
pip3 install lief
编译
查看编译选项
(frida-compile) r@ubuntu20:~/Documents/FRIDA/frida$ make
make[1]: 进入目录“/home/r/Documents/FRIDA/frida”
Usage: make TARGET [VARIABLE=value]
Where TARGET specifies one or more of:
  /* gum */
  gum-linux-x86                     Build for Linux/x86
  gum-linux-x86_64                  Build for Linux/x86-64
  gum-linux-x86-thin                Build for Linux/x86 without cross-arch support
  gum-linux-x86_64-thin             Build for Linux/x86-64 without cross-arch support
  gum-linux-x86_64-gir              Build for Linux/x86-64 with shared GLib and GIR
  gum-linux-arm                     Build for Linux/arm
  gum-linux-armbe8                  Build for Linux/armbe8
  gum-linux-armhf                   Build for Linux/armhf
......等等
编译安卓arm64的frida
make core-android-arm64
编译完成
Installing lib/base/libfrida-base-1.0.a to /home/r/Documents/FRIDA/frida/build/frida-android-arm64/lib
Installing lib/base/frida-base.h to /home/r/Documents/FRIDA/frida/build/frida-android-arm64/include/frida-1.0
Installing lib/base/frida-base-1.0.vapi to /home/r/Documents/FRIDA/frida/build/frida-android-arm64/share/vala/vapi
Installing lib/payload/libfrida-payload-1.0.a to /home/r/Documents/FRIDA/frida/build/frida-android-arm64/lib
Installing lib/payload/frida-payload.h to /home/r/Documents/FRIDA/frida/build/frida-android-arm64/include/frida-1.0
Installing lib/payload/frida-payload-1.0.vapi to /home/r/Documents/FRIDA/frida/build/frida-android-arm64/share/vala/vapi
Installing lib/gadget/frida-gadget.so to /home/r/Documents/FRIDA/frida/build/frida-android-arm64/lib/frida/64
Installing src/api/frida-core.h to /home/r/Documents/FRIDA/frida/build/frida-android-arm64/include/frida-1.0
Installing src/api/frida-core-1.0.vapi to /home/r/Documents/FRIDA/frida/build/frida-android-arm64/share/vala/vapi
Installing src/api/frida-core-1.0.deps to /home/r/Documents/FRIDA/frida/build/frida-android-arm64/share/vala/vapi
Installing src/api/libfrida-core-1.0.a to /home/r/Documents/FRIDA/frida/build/frida-android-arm64/lib
Installing server/frida-server to /home/r/Documents/FRIDA/frida/build/frida-android-arm64/bin
Installing portal/frida-portal to /home/r/Documents/FRIDA/frida/build/frida-android-arm64/bin
Installing inject/frida-inject to /home/r/Documents/FRIDA/frida/build/frida-android-arm64/bin
Installing /home/r/Documents/FRIDA/frida/frida-core/lib/selinux/frida-selinux.h to /home/r/Documents/FRIDA/frida/build/frida-android-arm64/include/frida-1.0
Installing /home/r/Documents/FRIDA/frida/build/tmp-android-arm64/frida-core/meson-private/frida-base-1.0.pc to /home/r/Documents/FRIDA/frida/build/frida-android-arm64/lib/pkgconfig
Installing /home/r/Documents/FRIDA/frida/build/tmp-android-arm64/frida-core/meson-private/frida-payload-1.0.pc to /home/r/Documents/FRIDA/frida/build/frida-android-arm64/lib/pkgconfig
Installing /home/r/Documents/FRIDA/frida/build/tmp-android-arm64/frida-core/meson-private/frida-core-1.0.pc to /home/r/Documents/FRIDA/frida/build/frida-android-arm64/lib/pkgconfig
make[1]: 离开目录“/home/r/Documents/FRIDA/frida”
查看编译后的文件
cd build/frida-android-arm64/bin && ls
(frida-compile) r@ubuntu20:~/Documents/FRIDA/frida$ cd build/frida-android-arm64/bin && ls
frida-inject  frida-portal  frida-server  gum-graft
(frida-compile) r@ubuntu20:~/Documents/FRIDA/frida/build/frida-android-arm64/bin$ 
0x2 修改frida
先把所有的 "frida_agent_main" 换成"main"
然后打上patch, 如果不会打的话其实一个个改也不费事，字符串的话可以直接替换，我这里把frida改成了rusda，你也可以改成其他的
github: GitHub - taisuii/rusda: 对frida 16.2.1的patch
python脚本新建在frida-core/src目录下
如果你提示No module named 'lief' 说明Python模块没有装好 pip3 install lief
然后编译，这里可以过滤日志编译，如果编译成功还是有很多特征大部分原因是python脚本没有打上patch
make core-android-arm64 | grep Patch
(base) r@ubuntu20:~/Documents/FRIDA/frida$ make core-android-arm64 | grep Patch
[*] Patch frida-agent: /home/r/Documents/FRIDA/frida/build/tmp-android-arm64/frida-core/src/frida-agent@emb/frida-agent-64.so
[*] Patch `frida` to `rusda`
[*] Patching section name=.rodata offset=0x1c4a26 orig:FridaScriptEngine new:enignEtpircSadirF
[*] Patching section name=.rodata offset=0x1d24db orig:FridaScriptEngine new:enignEtpircSadirF
[*] Patching section name=.rodata offset=0x1d9472 orig:GLib-GIO new:OIG-biLG
[*] Patching section name=.rodata offset=0x1959df orig:GDBusProxy new:yxorPsuBDG
[*] Patching section name=.rodata offset=0x1c4b31 orig:GDBusProxy new:yxorPsuBDG
[*] Patching section name=.rodata offset=0x1b1746 orig:GumScript new:tpircSmuG
[*] Patching section name=.rodata offset=0x210bed orig:GumScript new:tpircSmuG
[*] Patching section name=.rodata offset=0x238393 orig:GumScript new:tpircSmuG
[*] Patching section name=.rodata offset=0x246184 orig:GumScript new:tpircSmuG
[*] Patch `gum-js-loop` to `russellloop`
[*] Patch `gmain` to `rmain`
[*] Patch `gdbus` to `rubus`
[*] Patch Finish
[*] Patch frida-agent: /home/r/Documents/FRIDA/frida/build/tmp-android-arm64/frida-core/src/frida-agent@emb/frida-agent-32.so
[*] Patch `frida` to `rusda`
[*] Patching section name=.rodata offset=0xcc3a3 orig:FridaScriptEngine new:enignEtpircSadirF
[*] Patching section name=.rodata offset=0xd984c orig:FridaScriptEngine new:enignEtpircSadirF
[*] Patching section name=.rodata offset=0xe066f orig:GLib-GIO new:OIG-biLG
[*] Patching section name=.rodata offset=0x9e15e orig:GDBusProxy new:yxorPsuBDG
[*] Patching section name=.rodata offset=0xcc4ae orig:GDBusProxy new:yxorPsuBDG
[*] Patching section name=.rodata offset=0xb96c5 orig:GumScript new:tpircSmuG
[*] Patching section name=.rodata offset=0x115e26 orig:GumScript new:tpircSmuG
[*] Patching section name=.rodata offset=0x13d0a3 orig:GumScript new:tpircSmuG
[*] Patching section name=.rodata offset=0x14aa2d orig:GumScript new:tpircSmuG
[*] Patch `gum-js-loop` to `russellloop`
[*] Patch `gmain` to `rmain`
[*] Patch `gdbus` to `rubus`
[*] Patch Finish
[*] Patch frida-agent: /home/r/Documents/FRIDA/frida/build/tmp-android-arm64/frida-core/src/frida-agent@emb/frida-agent-arm64.so
[*] Patch `frida` to `rusda`
[*] Patch frida-agent: /home/r/Documents/FRIDA/frida/build/tmp-android-arm64/frida-core/src/frida-agent@emb/frida-agent-arm.so
[*] Patch `frida` to `rusda`
(base) r@ubuntu20:~/Documents/FRIDA/frida$ ls 
0x3 运行测试
这里换个端口，就是全绿
cd build/frida-android-arm64/bin
adb push frida-server /data/local/tmp
adb shell
chmod +x frida-server
./frida-server -l 127.0.0.1:12345
frida -H 127.0.0.1:12345 -f com.yimian.envcheck
0x4 参考
GitHub - Ylarod/Florida: 基础反检测 frida-server / Basic anti-detection frida-server
GitHub - hluwa/Patchs: strongR-frida


GitHub高级搜索技巧
本文参考自GitHub官方文档。
GitHub官方文档：https://docs.github.com/en
在这里插入图片描述
本文第3点总结了目前GitHub搜索最常用的技巧，根据我们平时搜索的内容分为了搜索存储库、搜索主题、搜索代码和搜索用户四个小点，你可以根据自己想要的搜索内容定位到每个小点，同时第2点总结了将你搜索到的结果按照什么排序顺序排序，包括交互排序、反应排序、作者日期排序、提交者日期排序、更新日期排序等。
2. 排序搜索结果
2.1. 按交互排序
语法	例子
org:github sort:interactions	匹配 GitHub 拥有的存储库中的问题，按反应和评论的最高组合数排序
org:github sort:interactions-asc	匹配 GitHub 拥有的存储库中的问题，按最少的反应和评论组合数排序
2.2. 按反应排序
语法	例子
org:github sort:reactions	匹配 GitHub 拥有的存储库中的问题，按最高反应数排序。
org:github sort:reactions-asc	匹配 GitHub 拥有的存储库中的问题，按反应数量升序排序（从最少到最多）
org:github sort:reactions-+1	匹配 GitHub 拥有的存储库中的问题，按最多点赞 (👍) 反应排序
org:github sort:reactions- -1	匹配 GitHub 拥有的存储库中的问题，按最多 (👎) 反应排序
org:github sort:reactions-smile	匹配 GitHub 拥有的存储库中的问题，按最多笑 (😄) 反应排序
org:github sort:reactions-tada	匹配 GitHub 拥有的存储库中的问题，按大多数欢呼 (🎉) 反应排序
org:github sort:reactions-heart	匹配 GitHub 拥有的存储库中的问题，按大多数心脏 (❤️) 反应排序
2.3. 按作者日期排序
语法	例子
org:github sort:author-date feature	匹配 GitHub 拥有的存储库中包含单词“feature”的提交，按作者日期降序排序
org:github sort:author-date-asc feature	匹配 GitHub 拥有的存储库中包含单词“feature”的提交，按作者日期升序排序
2.4. 按提交者日期排序
语法	例子
org:github sort:committer-date	匹配 GitHub 拥有的存储库中包含“功能”一词的提交，按提交者日期降序排序
org:github sort:committer-date-asc	匹配 GitHub 拥有的存储库中包含“功能”一词的提交，按提交者日期升序排序
2.5. 按更新日期排序
语法	例子
sort:updated feature	匹配包含“feature”一词的存储库，按最近更新日期排序
sort:updated-asc feature	匹配包含单词“feature”的存储库，按最近更新日期排序
3. 搜索范围
3.1. 搜索存储库
3.1.1. 按存储库名称、描述或 README 文件的内容搜索
语法	例子
in:name jquery	匹配存储库名称中带有“jquery”的存储库。
in:description jquery	匹配存储库描述中带有“jquery”的存储库。
in:readme jquery	匹配存储库的 README 文件中提到“jquery”的存储库。
3.1.2. 在用户或组织的仓库中搜索
语法	例子
user:defunkt forks:>100	匹配用户名为 defunkt 的具有超过 100 个 fork 的存储库。
3.1.3. 按存储库大小搜索
语法	例子
size:1000	匹配大小为 1 MB 的存储库
size:>=30000	匹配至少 30 MB 的存储库
size:<50	匹配小于 50 KB 的存储库
size:50…120	匹配 50 KB 到 120 KB 之间的存储库
3.1.4. 按分叉数搜索
语法	例子
forks:5	匹配只有五个 fork 的存储库
forks:>=205	匹配至少有 205 个 fork 的仓库
forks:<90	匹配具有少于 90 个 fork 的存储库
forks:10…20	匹配具有 10 到 20 个 fork 的存储库
3.1.5. 按星数搜索
语法	例子
stars:500	匹配恰好有 500 颗星的存储库
stars:10…20	匹配小于 1000 KB 的 10 到 20 星的存储库
stars:>=500 fork:true language:php	匹配至少 500 个星的存储库，包括分叉的，用 PHP 编写的
3.1.6. 按创建或上次更新存储库的时间搜索
语法	例子
webos created:<2011-01-01	匹配 2011 年之前创建的带有“webos”一词的存储库
css push:>2013-02-01	匹配 2013 年 1 月之后推送到的带有“css”一词的存储库
case push:>=2013-03-06 fork:only	匹配 2013 年 3 月 6 日或之后推送到的带有单词“case”的存储库，并且是分叉。
3.1.7. 按语言搜索
语法	例子
rails language:javascript	匹配使用 JavaScript 编写的带有“rails”一词的存储库
3.1.8. 按主题搜索
语法	例子
topic:jekyll	匹配已分类为主题“jekyll”的存储库
3.1.9. 按主题数量搜索
语法	例子
topic:5	匹配具有五个主题的存储库
topic:> 3	匹配具有三个以上主题的存储库
3.1.10. 按许可证搜索
语法	例子
license:apache-2.0	匹配在 Apache License 2.0 下获得许可的存储库
3.1.11. 按存储库可见性搜索
语法	例子
is:public org:github	匹配 GitHub 拥有的公共存储库
is:internal test	匹配您可以访问并包含“test”一词的内部存储库
is:private pages	匹配您可以访问并包含“pages”一词的私有存储库
3.1.12. 根据仓库是否是镜像进行搜索
语法	例子
mirror:true GNOME	匹配作为镜像且包含单词“GNOME”的存储库
mirror:false GNOME	匹配非镜像且包含“GNOME”一词的存储库
3.2. 搜索主题
3.2.1. 使用搜索限定符缩小搜索范围
语法	例子
is:curated javascript	匹配经过策划并包含“javascript”一词的主题
is:featured javascript	匹配https://github.com/topics/上的特色主题并包含“javascript”一词
is:not-curated javascript	匹配没有额外信息（例如描述或徽标）并包含“javascript”一词的主题
is:not-featured javascript	匹配https://github.com/topics/上没有特色且包含“javascript”一词的主题
repositories:>5000	匹配具有超过 5000 个存储库的主题
3.3. 搜索代码
序号	代码搜索的注意事项：由于搜索代码的复杂性，对搜索的执行方式有一些限制
1	必须登录 GitHub 上的用户帐户才能在所有公共存储库中搜索代码
2	只有当分叉的星数多于父存储库时，分叉中的代码才可搜索。星号少于父存储库的分叉不会为代码搜索编制索引。要在搜索结果中包含星数多于父级的分叉，您需要将fork:true或添加fork:only到您的查询中。有关更多信息，请参阅“在分叉中搜索”
3	仅对默认分支进行索引以进行代码搜索
4	只能搜索小于 384 KB 的文。
5	只能搜索少于 500,000 个文件的存储库
6	只有在去年有活动或在搜索结果中返回的存储库才可搜索
7	除了filename搜索之外，在搜索源代码时，您必须始终包含至少一个搜索词。例如，搜索language:javascript无效，而搜索无效amazing language:javascript
8	搜索结果最多可以显示来自同一个文件的两个片段，但文件中可能会有更多的结果
9	您不能在搜索查询中使用以下通配符：. , : ; / \ ` ’ " = * ! ? # $ & + ^
3.3.1. 按文件内容或文件路径搜索
语法	例子
octocat in:file	匹配文件内容中出现“octocat”的代码
octocat in:path	匹配文件路径中出现“octocat”的代码
3.3.2. 在用户或组织的仓库中搜索
语法	例子
user:defunkt extension:rb	匹配来自@defunkt 的以.rb结尾的代码
org:github extension:js	匹配来自 GitHub 的以.js结尾的代码
repo:mozilla/shumway extension:as	匹配@mozilla 的 shumway 项目中以.as结尾的代码
3.3.3. 按语言搜索
语法	例子
element language:xml size:100	匹配带有标记为 XML 且正好有 100 个字节的单词“element”的代码
display language:scss	匹配带有单词“display”的代码，它被标记为 SCSS
org:mozilla language:markdown	匹配所有@mozilla 存储库中标记为 Markdown 的代码


GitHub 高级搜索功能
1、精准搜索仓库标题、仓库描述、README
公式：in关键词限制搜索范围：按照项目名/仓库名搜索（大小写不敏感）
in:name xxx 
项目名包含xxx
in:readme xxx
项目介绍文档里含有xxx
in:description xxx
项目描述包含xxx
2、stars或fork数量去查找
一个项目 star 数的多少，一般代表该项目的受欢迎程度 越受欢迎的项目，star数和fork数一定也不会少。
公式：
stars:>xxx stars
stars数大于xxx
stars:xx..xx
stars数在xx…xx之间
forks:>xxx 
forks数大于xxx
forks:xx..xx
forks数在xx…xx之间
3、按照地区和语言进行搜索
公式：
location：地区
language：语言
4、根据仓库大小搜索
如果你只是想找一些小型的项目进行个人学习和开发，不想找特别复杂的，那么使用size关键字查找简单的 Demo，就成了你的首选。
公式：
size:>= 数字 【注意：100代表100Kb 单位为Kb】
5、根据仓库是否在更新的搜索
寻找项目当然是想要找到最新的项目，而不是好久都没有更新的老项目了。
公式：
pushed:> YYYY-MM-DD 最后上传日期大于YYYY-MM-DD
created:> YYYY-MM-DD 创建日期大于YYYY-MM-DD
6、根据某个人或组织进行搜索
如果你想在GitHub 上找某个大神是不是提交了新的项目，可以对他们进行精准搜索。
公式：
user: name 查找某个用户
org: name 查找某个组织
followers:>=xxx 查找关注者数量超过xxx的开发者
7、 根据仓库的LICENSE搜索
License是很多人容易忽略的一个问题，开源项目的License（项目授权协议） 有的开源项目作者明确禁止商用了，但是你不知情下载了，并且使用了，这就会很麻烦。
“非常友好”的协议，比较出名的有这几种：BSD、MPL（Mozilla）、Apache、MIT。这些协议不但允许项目的使用者使用开源库，有些还允许对开源库进行修改并重新分发。
以下这个网站，详细介绍了各个License的区别。http://choosealicense.com/licenses/
公式：
-license:对应协议
8、awesome加强搜索
Awesome 似乎已经成为不少 GitHub 项目喜爱的命名之一，Awesome 往往整合了大量的同一领域的资料，让大家可以更好的学习。
公式：
awesome 关键字 awesome 系列一般是用来收集学习、工具、书籍类相关的项目
9、热门搜索（GitHub Trend 和 GitHub Topic）
GitHub Trend 页面总结了每天/每周/每月周期的热门 Repositories 和 Developers，你可以看到在某个周期处于热门状态的开发项目和开发者。
网址：https://github.com/trending，
GitHub Topic 展示了最新和最流行的讨论主题，在这里你不仅能够看到开发项目，还能看到更多非开发技术的讨论主题。
网址：https://github.com/topics


Windows下静态编译Skia
要先安装Python，并把Python设置到环境变量里，到安装目录下把Python.exe复制一份，取名Python3.exe
接着下载谷歌的：depot_tools
git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git
下载完成后把depot_tools所在目录手动设置到环境变量中，我设置的是：D:\tool\depot_tools
接着安装LLVM（最新稳定版，我下载的是LLVM-15.0.7-win64.exe，安装过程中配置到环境变量中）：
https://github.com/llvm/llvm-project/releases
​github.com/llvm/llvm-project/releases
必须使用LLVM编译Skia，用VS编译的Skia是有性能问题的
接着下载skia源码（D:\sdk\skia）（use github desktop）
git clone https://skia.googlesource.com/skia.git
skia版本很重要，最新的几个版本几乎都有问题，我用的是chrome/m115
接着下载skia的依赖库的源码
cd skia
python tools/git-sync-deps
如有必要需要设置代理
git config --global https.proxy 127.0.0.1:7890
git config --global http.proxy 127.0.0.1:7890
git config --global http.sslVerify false
接着下载ninja
python bin/fetch-ninja
接着修改一下gn\BUILDCONFIG.gn，把129-150行（左右）的代码改成如下：
if (target_os == "win") {
  # By default we look for 2017 (Enterprise, Pro, and Community), then 2015. If MSVC is installed in a
  # non-default location, you can set win_vc to inform us where it is.
  if (win_vc == "") {
    win_vc = "C:/Program Files/Microsoft Visual Studio/2022/Community/VC"
  }
  assert(win_vc != "")  # Could not find VC installation. Set win_vc to your VC
                        # directory.
}
if (target_os == "win") {
  if (win_toolchain_version == "") {
    win_toolchain_version = "14.36.32532"
  }
  if (win_sdk_version == "") {
    win_sdk_version = "10.0.22621.0"
  }
  if (clang_win != "" && clang_win_version == "") {
    clang_win_version = "16"
  }
}
gn\toolchain\BUILD.gn，45行附近
dlsymutil_pool_depth = 8
接着执行如下指令（这行代码使用powershell执行）
bin/gn gen out/debug --args='clang_win=\"C:\Program Files\LLVM\" cc=\"clang\" cxx=\"clang++\" extra_cflags=[\"/MTd\"] is_official_build=true is_debug=false skia_use_system_expat=false skia_use_system_libjpeg_turbo=false skia_use_system_libpng=false skia_use_system_libwebp=false skia_use_system_zlib=false skia_use_system_harfbuzz=false skia_use_icu=false'
现在开始编译：
ninja -C out/debug
这一步可能要等一会儿
编译完成后，如下目录下应该出现一堆lib文件，这就是你想要的啦
上面的指令是编译debug版本的静态库，如果你要编译release版本的静态库需要用下面的指令
（编译静态库前，记得把BUILD.gn改动的那行代码再改回来）
bin/gn gen out/release --args='clang_win=\"C:\Program Files\LLVM\" cc=\"clang\" cxx=\"clang++\" extra_cflags=[\"/MT\"] is_debug=false is_official_build=true skia_use_system_expat=false skia_use_system_libjpeg_turbo=false skia_use_system_libpng=false skia_use_system_libwebp=false skia_use_system_zlib=false skia_use_system_harfbuzz=false skia_use_icu=false skia_use_angle=true'
ninja -C out/release
如果Skia升级之后，你也想跟着升级，就重新下载，重新编译：
git pull
python tools/git-sync-deps
ninja -C out/Static

那些编译skia跳过的坑
最近在windows上面编译skia，自己属于小白的那种，遇到了种种问题，各种坑快哭了，在前辈的指导下终于搞定了，下面首先就我自己安装过程遇到的问题分享一下，最后介绍一下在vs中编译这一方法（其实也有很多坑），好处就是编译完了直接可以在vs中调试工程下的代码，分析代码进行学习。如果大家编译的过程遇到相似的问题可以改一下，如果只是想编译成功，直接跳过前面看最后面的VS中编译过程即可！
这是skia安装官网https://skia.org/user/download，按照上面来估计会遇到种种挫折，下面来列一下我遇到的问题。
坑1：首先记住如果之前安装的python是3.0以上的最好不要用，要安装2.7版本的最好，我因为之前电脑上装的3.5版本，结果有的库不兼容
坑2：当进行到bin/gn gen out/Static --args='is_official_build=true'时，会报错'bin' 不是内部或外部命令，也不是可运行的程序
或批处理文件。于是老老实实的按照官网运行了python tools/git-sync-deps 结果还是会报同样的错误，纳尼？什么鬼！！还是，呵呵此时你应该
改为bin\gn gen out/Static --args='is_official_build=true'对你没有看错，将/改为\，我去，神坑！！！
坑3：好了现在总应该没错了吧，呵呵，天真了，再次运行你会发现，它又报错了，巴拉巴拉一堆，此时你需要将 --args='is_official_build=true'
改为 --args="is_official_build=true"就是将单引号改为双引号。是不是感觉萌萌哒！！
坑4：当编译的时候，它有时会报错，说什么缺少XXXX.h(以.h结尾的头文件)，这时候其实已经步入一个神坑了哭哈哈哈，按理说它是会自动获取这些头文件的
这时候怎么办呢?可以到如下目录下找到相应的头文件：如果你没有externals目录，要运行python tools/git-sync-deps（其实这个步骤在之前就
应该运行了的）
也可以直接谷歌这个头文件，一般是有的，然后自己将代码拷贝，文件名就以报错提示缺少的文件名命名，最后放到目录下：
坑7：运行的时候会报C2220的错误如下：
什么意思呢？意思就是它将警告视为错误了，这个好解决找到这个文件如下：
在代码中找到，原来这里是没有“-”的，加上就好了
坑6：git克隆下来的代码skia好像有问题（我也不是很清楚），大家可以试一下用Sourcetree下载skia源代码。
好了从新编译一下吧，看看是不是OK了？也许可以吧，但其实说实话我的还是报错(天理在哪里？)，说什么头文件中在#前缺少;我去我去！！！！代码本身有错误？
这个时候其实就可以放弃了，你可以试一试下面这种编译方式（当然可以根据提示一步步去改动，不过我此时心态已奔）
好了最后说一下vs编译的方法，
首先下载 depot_tools 这个没什么说的，然后就是下载skia了，官网上使用git下的，建议用Sourcetree下载skia源代码（这个影响不大）。Sourcetree
很好用，有ui界面。
然后先在cmd中切换到你自己skia文件夹所在位置例如我的是e盘
然后运行python tools/git-sync-deps
不出意料的话就是下面结果：
接着输入bin\gn.exe gen out/vs2015x64d --sln="skia" --ide="vs2015"
两点说明：(一)我这里生产的Debug版本，方便我们看代码时调试(二)我的vs版本是2015的
不错意料会出现：
然后去skia目录下会有一个叫做out目录的东西，点开会发现如下图这么个skia用vs打开即可（切记vs要用管理员身份打开，不要编译的时候又会报错
说什么没有访问权限）
点击build下面第一个选项进行编译
当编译的时候有时又会报错，报错不能打开某个文件，不好意思又进入另一个坑了，此时在vs中选中相关的不能打开的文件左键，选中最后一个即propertes
会弹出一个窗口
可以看到windows的sdk是10.0.15063，然后去自己电脑上看居然没有10.0.15063版本
呵呵，无语了吧，我的安装之路就是这么艰辛哭，好了去下载一个吧
官网https://developer.microsoft.com/en-us/windows/downloads/sdk-archive
点击相应版本如下：
下载好了以后，再次在vs中build(按F7就可以)，
说明：在编译的时候有时会报错，根据错误索引到对应的工程，就是在这里拷贝一下报错的文件，回车就可以索引到该工程了
然后右键单独编译这个工程，在此会看到具体的错误提示，进而可以做进一步的措施！但更多的是，没有报错！！！编译通过，此时再整体编译一下整个工程（就是按F7）可以发现这个错误又没了，呵呵笑哭偷笑，这是什么原因呢？应该是在整体编译的时候，编译顺序不对引起的，那我们就单独编译报错的某个工程，哈哈哈是不是很心累！！！但愿大家不会碰到这个问题（我记得好像有什么访问受限之类的，记住直接找到对应的工程单独给它编译，简单粗暴我就是单独编译了好几个单独工程才解决了的）
好了到此应该是编译好了，我们测试一下；找到out工程下的HelloWorld.exe然后运行一下，结果如下：
苍天呀，上帝呀！终于成功了。
总结一下：大家可以下载vs2017版本，估计会友好一些！一路下来还是蛮累的，希望大家不要遇到这些种种琐碎的错误！

在windows上编译skia
0、准备好VPN
准备好VPN，这是第一步。
1、下载depot_tools
skia使用git管理源码。所以，要先安装git。
但是不能直接使用git获得skia源码。因为编译skia需要一些依赖库。要使用google提供的depot_tools来
获得源码。depot_tools使用python包装了git。根本上还是使用git获得源码。
可直接下载depot_tools工具。
2、下载源码
安装好depot_tools工具后。进入命令行，新建一个目录，切换到此目录下。
以后下载的源码就会下载到这个目录下。
执行如下命令
gclient config --name=src https://skia.googlesource.com/skia.git
执行此命令后会创建.gclient文件。文件内容为：
solutions = [
  { "name"        : "src",
    "url"         : "https://skia.googlesource.com/skia.git",
    "deps_file"   : "DEPS",
    "managed"     : True,
    "custom_deps" : {
    },
    "safesync_url": "",
  },
]
cache_dir = None
再执行如下命令：
gclient sync
此命令用来获取源码。慢慢等吧。
3、下载某一版本
获取源码完成后，会发现此源码的版本为master。使用如下git命令会看到此skia的版本
$ git branch
* (HEAD detached at origin/master)
  master
如果我们为了使用skia，而不是开发skia，最好不要使用master版本。要获得skia已经定型的版本。
查看skia的版本
$ git branch -r
  origin/HEAD -> origin/master
  origin/chrome/m39
  origin/chrome/m40
  origin/chrome/m41
  origin/chrome/m42
  origin/chrome/m43
  origin/chrome/m44
  origin/chrome/m45
  origin/chrome/m46
  origin/chrome/m47
  origin/chrome/m48
  origin/chrome/m49
  origin/chrome/m50
  origin/chrome/m51
  origin/chrome/m52
  origin/chrome/m53
  origin/chrome/m54
  origin/chrome/m55
  origin/infra/config
  origin/master
 下载某一个版本，这里以m55为例
 git checkout -b chrome_55 origin/chrome/m55
 稍等一会，就会获取完此版本。
4、生成VS2015工程
skia中使用了一些C++11的特性。VS2013不能很好的支持C++11。所以要使用VS2015。
在命令行中执行如下三条命令
SET "GYP_MSVS_VERSION=2015"
SET "GYP_GENERATORS=msvs"
python gyp_skia
会生成vs2015的工程。
5、编译Skia
在执行python gyp_skia的过程中，我们会发现程序输出了如下内容：
gyp: Missing input files:
E:\svn\skiasrc\src\out\gyp\..\..\third_party\externals\giflib\gifalloc.c
E:\svn\skiasrc\src\out\gyp\..\..\third_party\externals\giflib\gif_err.c
E:\svn\skiasrc\src\out\gyp\..\..\third_party\externals\giflib\dgif_lib.c
解决方法
下载giflib。将对应文件放到在对应的位置中。稍稍修改代码即可。
之后，就可编译skia了。

https://blog.csdn.net/superyu1992/article/details/105841465[#Android反编译#零基础脱掉360加固包的“外衣”]
利用Frida给加固过的App脱壳
1、frida简介
frida的原理在我理解就是，通过在PC上安装Frida，手机上运行frida-server，实现PC对手机的控制，同时通过js注入的方式，将dex从“壳”里“钩”出来。（如果只是想实现结果，可以不在意这些原理，直接用大神们提供的工具就好~）
它是一款基于Python的hook（钩子）工具，因此在安装它之前我们需要先配置Py环境，现在的frida仅支持3.7以下的环境，3.8以上的暂不支持，这一点需要注意，我就因为PC上的py版本太高，不得不重新安装py。
2、pc上安装frida和frida-server
我们通过pip3 install 安装frida、frida-server，这里也有一个注意点：如果你的测试设备是5.1.1的话，需要指定frida为12.1.0（pip3 frida install == 12.1.0）frida-tools为1.2.0，至于原因，后面再说。
在安装之前，还需要手动下载与你py版本对应的egg文件，否则在安装frida的过程中，会报一个找不到对应egg文件的错误。
下载链接：https://github.com/frida/frida/releases
整个安装过程会比较慢，会卡在Running setup.py install for frida ... – 这里很久，一定要有耐心。如果在下载过程中出现超时，可以重新下载或者安装时添加参数 pip3 --default-timeout=100 install -U xxx 。
安装完成后可以通过在python中，import frida来检测，如果没有报错，则代表安装成功。
3、在手机上运行frida-server
frida-server版本的选择由设备的内核版本与frida的版本决定，frida的版本已经确定，我们还需要确定设备的内核版本。在shell中，执行命令:cat /proc/cpuinfo查看系统内核。我的frida版本为12.1.0，设备内核版本为arm32位，因此选择:
下载地址：https://github.com/frida/frida/releases
下载完成后将文件解压，通过adb push导入到/data/local文件夹中,然后：
adb shell进入手机系统；
通过su切换刀root；
cd到/data/local；
赋予froda-server 777 权限：chmod 777 frida-server；
运行frida-server:./frida-server；还记得之前强调的frida版本问题吗？如果你在5.1.1的设备上，安装了高于12.1.0的frida-server上的话，这里执行就会报错：unused DT entry: type 0x6ffffef5 arg 0x1ddc，那么你又得重新安装frida、frida-tools、frida-server，那又将是一个漫长的过程了...
启动成功以后，新建一个终端窗口，输入：frida-ps -U，如果可以看到当前设备的进程和名称，则证明pc和手机通过frida联通了：
4、关键一步，利用“钩子”将dex脱出来：
以上所做的都是准备工作，下面就是真正的脱壳操作了，这里感谢“看雪”论坛里的大神，提供了可以直接脱壳的js，使得我们直接调用就可以了，献上原文链接：[原创]Frida-Apk-Unpack 脱壳工具-Android安全-看雪论坛-安全社区|安全招聘|bbs.pediy.com
按照大神的做法：frida -U -f {包名} -l dexDump.js --no-pause，就可以dump出dex了！包名可以从前面所说的apktool中反编译出的manifest中得到。而dex文件会生成在/data/data/应用包名/目录下：
接下来我们退出shell，通过adb pull将dex文件拉出，再通过jd-gui-osx查看：
当当，源码全都脱出来了！

360加固脱壳实战
下载frida
打开app
进入手机目录并启动frida sargo:/data/local/tmp # ./frida-server-15.1.27-android-arm64
端口转发 adb forward tcp:27042 tcp:27042
确定包名
使用frida -U -f com.xxx.xxx.xxx -l dupDex.js --no-pause<br> 命令 或者使用frida-hexdump -U -f com.inmo.inmolife命令
在com.xxx.xxx.xxx 中寻找dex文件 或者在输出的日志中有输出路径
使用dex2jar工具把dex文件转为jar文件 d2j-dex2jar.sh *.dex -d --skip-exceptions -f,也可以直接用jadx打开

模拟来电的实现
模拟来电这个功能其实Android原生就有实现，想想Android模拟器是可以来电或者拨号的吧。这个功能对于手机厂商的程序员来说，节省了大量调整UI的时间，不用去真的打电话来呈现UI。实现有两种方式：
实现虚拟的BaseCommands
这种方式也是Android5.0之前预留的方式。
frameworks/opt/telephony/src/java/com/android/internal/telephony/test/SimulatedCommands.java
public final class SimulatedCommands extends BaseCommands implements CommandsInterface, SimulatedRadioControl
正常流程中BaseCommands的实现类是RIL.Java， 用这个SimulatedCommands替换掉Phone对象中的BaseCommands对象，然后framework中相关的数据源就成了虚拟的了，使用SimulatedRadioControl接口中的方法即可触发各种操作。
frameworks/opt/telephony/src/java/com/android/internal/telephony/test/SimulatedRadioControl.java
public interface SimulatedRadioControl
{
    public void triggerRing(String number); //模拟来电
    public void progressConnectingCallState();
    public void progressConnectingToActive();  //拨号转接通
    ...
    public void triggerHangupForeground(); //挂断前台通话
    public void triggerHangupBackground();
    public void triggerHangupAll();
    ...
    /** Generates an incoming USSD message. */
    public void triggerIncomingUssd(String statusCode, String message);
     ...
}
这种方式要对framework中的相关代码稍作修改，非手机厂商的同学使用这种方式比较麻烦。
实现虚拟的ConnectionService
Android5.0通讯架构大调整后，实现虚拟来电其实更方便了。这次不用修改framework层代码了，只要实现虚拟的ConnectionService。正常流程中这个是Telephony包下TelephonyConnectionService实现的，现在实现虚拟用的ConnectionService即可。
原生代码中Telecomm包下就有相关的实现，在testapps包下，这个是测试Telecomm包的测试程序，稍加修改即可实现虚拟来电。在testapps包中，不仅有TestConnectionService，还有TestInCallServiceImpl，虚拟来电是要使用真正的InCallUI的，所以在AndroidManifest.xml中要把相应的类注释掉
 <!-- <service android:name="com.android.server.telecom.testapps.TestInCallServiceImpl"
		 android:process="com.android.server.telecom.testapps.TestInCallService"
		 android:permission="android.permission.BIND_INCALL_SERVICE" >
	<intent-filter>
		<action android:name="android.telecom.InCallService"/>
	</intent-filter>
</service> -->
我这里手头上只有mtk的代码，还需要删除一些视频通话相关的代码程序才能跑起来，如果使用原生代码应该只要做上述一处修改就可以实现虚拟来电了。


解决: 您目前无法访问 因为此网站使用了 HSTS。网络错误和攻击通常是暂时的，因此，此网页稍后可能会恢复正常
HSTS：HSTS 是 HTTP 严格传输安全（HTTP Strict Transport Security） 的缩写。 这是一种网站用来声明他们只能使用安全连接（HTTPS）访问的方法。 如果一个网站声明了 HSTS 策略，浏览器必须拒绝所有的 HTTP 连接并阻止用户接受不安全的 SSL 证书。 目前大多数主流浏览器都支持 HSTS (只有一些移动浏览器无法使用它)。
实际上简单理解就是如果浏览器接收到使用 HTTP 加载资源的请求，则必须尝试使用 HTTPS 请求替代。 如果 HTTPS 不可用，则必须直接终止连接。
如何解决
调整键盘为英文输入状态，点击页面内的刷新按钮，刷新一下页面，然后用鼠标点击一下当前页面任意位置，紧接着在当前页面使用键盘直接输入：thisisunsafe 即可（不是在地址栏输入，就直接敲键盘就行了）。按完上面的按键，页面会自动刷新，然后就可以正常访问了。
其他解决方案：(来源于网络)
方案一：
在Chrome的地址栏中输入：chrome://flags/#show-cert-link，选择"启用"，重启Chrome浏览器。
打开问题网页，点击地址栏左侧的"不安全"图标，选择"证书"下面的"无效"链接，打开查看问题证书。
如果对该网站足够信任，可以不用理会证书的问题，直接点击下面的"高级"链接，点击"继续前往…(不安全)"链接就可以忽略证书问题，进入到证书有问题的网站。
方案二：
打开chrome://flags
找到“Show in-form warnings for sensitive fields when the top-level page is not HTTPS”设置为 disabled
找到 “Allow invalid certificates for resources loaded from localhost”设置为 “enabled”
点启用，然后重启浏览器

window系统
分割压缩包
1、安装好 WinRAR 之后，用鼠标右键点击要创建分割压缩包的目标文件。选择‘’添加到压缩文件＂
2、 在弹出的窗口里的“压缩分卷大小，字节”里面选择要分割的尺寸，例如100m。
完成以上设置后，等待自动压缩文件即可。使用时只要将这分割出来的压缩包放在一起，也就是放在同一个文件夹中，然后随便打开一个就会自动解压。
合并
1、把要合并的文件filename1.rar,filename2.rar放到同一个文件夹下面；
2、快捷键“Win+R”弹出运行命令框，输入：cmd，打开命令行窗口。
3、输入copy /b filename* filename.rar，回车。然后，就能看到友好的压缩包格式，可用压缩软件解压打开。
linux系统
//split 重命名 -b 分割大小 -d 原始压缩包 split xxx.tar.gz -b 10240m -d test.tar.gz //合并压缩包 cat xxx.tar.gz*>> test.tar.gz
tar zxvf 压缩包
实例
split -b 1G -d -a 1 原始test.tar 目标test.tar.
split -b 1G -d -a 1 test.tar.gz test.tar.gz.
-b 1G 表示设置每个分割包的大小，单位还是可以k
-d "参数指定生成的分割包后缀为数字的形式
-a x来设定序列的长度(默认值是2)，这里设定序列的长度为1
合并分割后的压缩包：
cat test.tar.* >>new_test.tar
tar-xvf new_test.tar

Mingw32右键
mingw64.reg后缀文件：
Windows Registry Editor Version 5.00
[HKEY_CLASSES_ROOT\Directory\Background\shell\mingw64]
@="MinGW64 Here"
"icon"="C:\\msys64\\mingw64.exe"
[HKEY_CLASSES_ROOT\Directory\Background\shell\mingw64\command]
@="C:\\msys64\\msys2_shell.cmd -mingw64 -here"

Windows Terminal右键
wt.reg后缀文件：
Windows Registry Editor Version 5.00
[HKEY_CLASSES_ROOT\Directory\Background\shell\wt]
@="Windows Terminal Here"
[HKEY_CLASSES_ROOT\Directory\Background\shell\wt\command]
@="C:\\Users\\你的用户名\\AppData\\Local\\Microsoft\\WindowsApps\\wt.exe"

Windows 禁用路径长度限制
Windows Registry Editor Version 5.00
[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control]
@="FileSystem"
"LongPathsEnabled"="1"

Windows 禁用下载文件夹默认分组
Windows Registry Editor Version 5.00
[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\FolderTypes\{885a186e-a440-4ada-812b-db871b942259}\TopViews\{00000000-0000-0000-0000-000000000000}]
"GroupBy"="System.Null"
"SortByList"="prop:System.ItemNameDisplay"
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\FolderTypes\{885a186e-a440-4ada-812b-db871b942259}\TopViews\{00000000-0000-0000-0000-000000000000}
GroupBy:从 System.DateModified 改为 System.Null 这个就可以关闭自动分组了
SortByList:从 prop:System.DateModified 改为 prop:System.ItemNameDisplay 这个
如果修改提示 写入值的新内容时出错，右键 {00000000-0000-0000-0000-000000000000} 项，选择 权限，弹出窗口中点击 高级，然后弹出窗口的左上角的 所有者，点击 更改。弹出的“选择用户或组”窗口中点击 高级，然后点击 立即找查，在搜索结果的选项中选择“Administrators”，确定。之后再次回到权限界面，选择“Administrators”用户勾选完全控制权限就可以正常修改了。
上述修改之前的默认用户是SYSTEM，“Administrators”默认权限是读取，改完之后可以还原回去。

Windows explorer.exe 无法访问指定设备路径或文件。你可能没有适当的权限访问该项目。
win10 [HKEY_CLASSES_ROOT\PackagedCom\ClassIndex]  win11  [HKEY_CLASSES_ROOT\PackagedCom\TreatAsClassIndex] 
右键[ClassIndex/TreatAsClassIndex]文件夹，点击权限->添加->输入对象[Users]->检查名称->确认->选择Users勾选[读取]权限


Cmake
# 最低版本要求
cmake_minimum_required(VERSION 3.10)
# 添加项目信息
project(test_account)
# 添加可执行文件目标
add_executable(test_account main.cpp)
# 为目标添加头文件目录
target_include_directories(test_account PUBLIC "../account_dir")
# 为目标添加库文件目录
target_link_directories(test_account PUBLIC "../account_dir/build")
# 链接,为目标添加库libAccount.a,这里不需要写全称
target_link_libraries(test_account Account)
# 设置自定义路径
set(CUSTOM_ROOT /XXX/mylib)
# 指定库和包含路径
include_directories(${CUSTOM_ROOT}/include)
link_directories(${CUSTOM_ROOT}/lib)
# 查找并链接MyLib库
find_library(MYLIB_LIB NAMES mylib PATHS ${CUSTOM_ROOT}/lib)
# 链接MyLib库
target_link_libraries(MyExecutable ${MYLIB_LIB})


cmake 引入第三方库（头文件目录、库目录、库文件）
一、手动引入
1、include_directories（引入头文件目录）
2、link_directories（引入库目录）
3、link_libraries (引入库文件)
4、target_link_libraries（引入库文件到子工程）
5、target_include_directories（引入头文件目录到子工程）
二、批量引入
1、find_package（查找 .cmake ）
2、pkg_check_modules（查找 .pc ）
一、手动引入
手动引入需要自己获取到所有头文件路径以及库文件路径，然后再调用函数接口引入。
1、include_directories（引入头文件目录）
include_directories表示引入头文件搜索路径，当工程要用到某个头文件的时候，就会去该路径下搜索。一般都是在顶层的CmakeList文件中添加搜索路径。
include_directories(完整路径)
# 绝对路径引入
include_directories("D:\\ProgramFiles\\Qt\\qt5_7_lib_shared_64\\include")
# 普通变量引入(可以理解为把D:\\ProgramFiles\\Qt\\qt5_7_lib_shared_64放入一个集合INCLUDE_PATH)
# ${变量名} 可以获取集合内容，允许拼接
set (INCLUDE_PATH D:\\ProgramFiles\\Qt\\qt5_7_lib_shared_64)
include_directories(${INCLUDE_PATH}/include)       
# 环境变量引入
# 假设环境变量是INCLUDE_PATH = D:\\ProgramFiles\\Qt\\qt5_7_lib_shared_64
# #ENV{环境变量名} 可以获取环境变量的内容，允许拼接
include_directories($ENV{INCLUDE_PATH}/include)
一个cmake总工程可以包含多个子工程，总工程引入的头文件，并不代表子工程就可以用，就好比幼儿园老师（总工程）买来一箱苹果，小朋友（子工程）根据需求拿苹果。
2、link_directories（引入库目录）
link_libraries 表示添加第三方 lib 库文件的搜索路径。若工程在编译的时候会需要用到某个第三方库的 lib 文件，此时就可以使用 link_libraries 来添加搜索路径。
link_libraries(完整路径)
# 绝对引入
link_libraries("D:\ProgramFiles\Qt\qt5_7_lib_shared_64\lib")
# 预定义变量引入
# PROJECT_SOURCE_DIR 是cmake的预定义变量，表示顶层CmakeList文件所在路径
link_libraries(${PROJECT_SOURCE_DIR}/ExtLib/ffmpeg/win64/lib)
# 环境变量引入
# 环境变量 QT_LIB = D:\\ProgramFiles\\Qt\\qt5_7_lib_shared_64
link_libraries($ENV{QT_LIB}/lib)
3、link_libraries (引入库文件)
link_libraries 表示将具体的库文件引入到当前工程中，所填入的路径必须是全路径。
# 全路径引入
LINK_LIBRARIES("/opt/MATLAB/R2012a/bin/glnxa64/libeng.so")
4、target_link_libraries（引入库文件到子工程）
target_link_libraries 表示添加第三方 lib 库文件到目标子工程，上面 link_directories 是引入库目录到当前工程，link_libraries 是引入库文件到当前工程，具体是哪个工程并没有指明。就好比，货车把满载的货物运到幼儿园里，但是没分配。
target_link_libraries 起的作用就是分发工作，分发xx库给指定工程，注意xx库必须是当前工程中有的或者 搜索路径里有的。
target_link_libraries(子工程名 库文件1 库文件2 ...)     # 注意子工程名和库文件名之间以空格隔开
add_executable(qt_test ${ALL_SRCS})    # 子工程名是 qt_test 
# 绝对路径引入
target_link_libraries(qt_test 
    D:\\ProgramFiles\\Qt\\qt5_7_lib_shared_64\\lib\\Qt5Core.lib
    D:\\ProgramFiles\\Qt\\qt5_7_lib_shared_64\\lib\\Qt5Gui.lib
)
# 普通变量引入（被打包的lib文件，必须能在搜索路径下找到）
set (LIB_FFMPEG "avcodec.lib" "avdevice.lib" "avfilter.lib")
target_link_libraries(qt_test 
    ${LIB_FFMPEG}
)
# 预定义变量引入
# PROJECT_SOURCE_DIR 是cmake的预定义变量，表示顶层CmakeList文件所在路径
target_link_libraries(qt_test 
    ${PROJECT_SOURCE_DIR}/ExtLib/ffmpeg/win64/lib/avcodec.lib
)
5、target_include_directories（引入头文件目录到子工程）
target_include_directories 达到的效果和 target_link_libraries 是类似的，需要注意的是
include_directories：将头文件目录引入到当前工程
target_include_directories：将头文件目录针对性的引入到目标子工程（当前工程一般可以包含多个子工程）
二、批量引入
一键引入只需提供 .cmake 文件或 .pc 文件的完整搜索路径，若 cmake 生成器能找到对应的库，便会自动将所有的头文件路径和库文件路径分别装填到对应的变量。
头文件路径装填到变量 XXX_INCLUDE_DIRS
库文件路径装填到 XXX_LIBRARY_DIRS
库文件名装填到变量 XXX_LIBRARIES 或 XXX_LIBS （可能包含了全路径）
注意：这里的 XXX 表示库名，不同库的变量会略微有所不同
1、find_package（查找 .cmake ）
find_package 主要用于查找 .cmake 文件（详细使用可以参考：find_package 的详细使用 ）find_package 需要通过 .cmake 为后缀的文件引入，将 .cmake 包含的库和头文件全部引入工程。不同的库的达到的效果不同。有时需要搭配关键字使用：
REQUIRED：必须找到该库，找不到就报错
COMPONENTS：从库中找子库（模块）xx，比如COMPONENTS Widget表示找到子模块Widget
以OpenCV库为例，OpenCV库提供的是 OpenCVConfig.cmake文件，只需引入一次，便可以将OpenCV所有的库文件和头文件引入到当前工程。OpenCVConfig.cmake 也给出了详细的说明。
find_package(OpenCV REQUIRED)
# OpenCV_INCLUDE_DIRS 是预定义变量，代表OpenCV库的头文件路径
include_directories(${OpenCV_INCLUDE_DIRS}) 
# OpenCV_LIBS 是预定义变量，代表OpenCV库的lib库文件
target_link_libraries(MY_TARGET_NAME ${OpenCV_LIBS})
以QT库为例，QT库是一个大型库，内部还包含了许多子库，在引入的时候最好按需引入
# 含义：必须找到Qt5库的子模块Core，找不到就报错
find_package(Qt5 COMPONENTS Core REQUIRED)
# 链接时需要加上前缀Qt::(这里是Qt5的库)
target_link_libraries(qt_test
    Qt5::Core
)
注意：无论是上面的Widget，还是Core，都是去掉了前缀Qt5。实际上，Qt的子库名字都是有前缀 "Qt5" 的！只不过在引入的时候，要去掉。
2、pkg_check_modules（查找 .pc ）
pkg_check_modules 主要通过 .pc 文件引入整个库，该命令会解析指定的 .pc 文件，并将所需的编译和链接信息提取到 CMake 变量中，以便后续使用。
pkg_check_modules：pkg_check_modules 使用详解


Makefile与CMake
一、Makefile 核心内容
1. Makefile 基础结构与工作原理
三要素：
目标（Target）：要生成的文件或执行的操作（如可执行文件、清理操作）。
依赖（Dependency）：生成目标所需的文件或其他目标。
命令（Command）：生成目标的具体指令（需以Tab 键开头）。
工作原理：
Make 通过检查依赖文件的修改时间，仅重新编译更新过的文件，提高编译效率。例如：
simple: main.o foo.o    # 目标：simple，依赖：main.o和foo.o
    gcc -o simple main.o foo.o  # 命令
main.o: main.c          # 子目标：main.o依赖main.c
    gcc -c main.c -o main.o
2. 关键特性与语法
伪对象（.PHONY）：
避免 Make 将目标视为同名文件，强制执行命令。例如：
.PHONY: clean
clean:
    rm simple main.o foo.o
若不声明.PHONY，当目录存在clean文件时，make clean会认为目标已更新，不执行删除命令。
变量与自动变量：
自定义变量：用于存储重复内容（如编译器、文件列表），例：
CC = gcc
SRCS = main.c foo.c
OBJS = $(SRCS:.c=.o)  # 将.c替换为.o
自动变量：
$@：当前目标名（如simple）。
$^：所有依赖文件（如main.o foo.o）。
$<：第一个依赖文件（如main.c）。
$(EXE): $(OBJS)
    $(CC) -o $@ $^  # 等价于gcc -o simple main.o foo.o
函数与第三方库依赖：
wildcard：获取指定模式的文件列表，例：SRCS = $(wildcard *.c)。
patsubst：字符串替换，例：OBJS = $(patsubst %.c, %.o, $(SRCS))。
第三方库链接：通过-I指定头文件路径，-L指定库路径，-l指定库名，例：
makefile
CFLAGS += -I./include
LDFLAGS += -L./lib -lpthread
3. 实战范例
简单示例：
all: test
    @echo "hello all"
test:
    @echo "hello test"
make默认执行第一个目标（all），依赖test，因此先执行test再执行all。
复杂编译流程：
通过变量和自动变量简化多文件编译，例：
CC = gcc
SRCS = main.c foo.c
OBJS = $(SRCS:.c=.o)
EXE = simple
$(EXE): $(OBJS)
    $(CC) -o $@ $^
%.o: %.c
    $(CC) -c $< -o $@
二、CMake 核心内容
1. CMake 概述
定位：跨平台构建工具，通过编写CMakeLists.txt生成 Makefile 或其他项目文件（如 VS 工程），简化多平台编译配置。
优势：相比 Makefile，语法更简洁，支持模块化设计，适合大型项目。
2. 基础语法与流程
核心命令：
cmake_minimum_required：指定 CMake 最低版本。
project：定义项目名称和语言（如C、CXX）。
add_executable：添加可执行文件，关联源文件。
add_library：生成库文件（SHARED动态库，STATIC静态库）。
target_link_libraries：链接库文件到可执行文件。
编译流程：
在项目根目录创建CMakeLists.txt。
创建build目录，进入后执行cmake ..生成 Makefile。
执行make编译。
3. 实战场景
单文件编译：
cmake_minimum_required(VERSION 2.8)
project(0voice)
set(SRC_LIST main.c)
add_executable(0voice ${SRC_LIST})
多目录与库管理：
子目录编译为库：
# 根目录CMakeLists.txt
add_subdirectory(src/dir1)  # 添加子目录
add_subdirectory(src/dir2)
add_executable(main main.c)
target_link_libraries(main dir1 dir2)  # 链接库
# src/dir1/CMakeLists.txt
add_library(dir1 SHARED dir1.c)  # 生成动态库
强制使用静态库：
target_link_libraries(main libdir1.a)  # 指定静态库文件名
安装与编译选项：
指定安装路径：
cmake -DCMAKE_INSTALL_PREFIX=/usr/local ..  # 安装到/usr/local
make install  # 安装库、头文件等到目标路径
Debug/Release 模式：
if(${CMAKE_BUILD_TYPE} MATCHES "Release")
    set(CMAKE_CXX_FLAGS "-O3 -Wall")  #  Release优化
else()
    set(CMAKE_CXX_FLAGS "-O0 -g")     # Debug调试符号
endif()
特性	Makefile	CMake
学习难度	较高（语法灵活但复杂）	较低（模块化命令，易上手）
跨平台支持	依赖平台特定语法（如 GNU Make）	原生支持多平台（生成对应平台构建文件）
大型项目管理	手动维护依赖关系，易出错	支持子目录、库管理，自动处理依赖
适用场景	简单项目或需要精细控制编译流程的场景	复杂多模块项目、跨平台开发
建议：
小型项目或需要深入理解编译原理时，使用 Makefile。
中大型项目或跨平台开发时，优先选择 CMake，搭配make执行编译。
三、Makefile和CMake的具体案例
案例 1：Makefile 跨目录编译
项目结构
project_make/
├── include/           # 头文件目录
│   └── utils.h
├── src/               # 源文件目录
│   ├── main.c
│   └── utils/
│       └── util.c
├── build/             # 输出目录（存放目标文件和可执行文件）
└── Makefile
代码文件内容
include/utils.h（头文件）
#ifndef UTILS_H
#define UTILS_H
int add(int a, int b);
#endif
src/utils/util.c（功能实现）
#include "utils.h"
int add(int a, int b) {
    return a + b;
}
src/main.c（主函数）
#include <stdio.h>
#include "utils.h"
int main() {
    int sum = add(3, 5);
    printf("3 + 5 = %d\n", sum);
    return 0;
}
Makefile 实现
# 变量定义
CC = gcc
CFLAGS = -Wall -I./include  # -I 指定头文件路径
SRCS = $(wildcard src/*.c src/utils/*.c)  # 匹配所有源文件
OBJS = $(patsubst %.c, build/%.o, $(SRCS))  # 目标文件路径（build目录下保持原目录结构）
EXE = build/app  # 最终可执行文件路径
# 生成可执行文件（默认目标）
all: $(EXE)
# 链接目标文件生成可执行文件
$(EXE): $(OBJS)
    @mkdir -p $(dir $@)  # 创建输出目录（若不存在）
    $(CC) $^ -o $@
# 模式规则：编译 .c 文件为 .o（保持目录结构）
build/%.o: %.c
    @mkdir -p $(dir $@)  # 创建目标文件所在目录（如 build/src/utils/）
    $(CC) $(CFLAGS) -c $< -o $@
# 清理生成文件
.PHONY: clean
clean:
    rm -rf build/
操作说明
执行 make，会自动：
在 build 目录下生成 src/main.o、src/utils/util.o 目标文件。
链接生成可执行文件 build/app。
运行 ./build/app，输出 3 + 5 = 8。
案例 2：CMake 跨目录编译
项目结构
project_cmake/
├── include/           # 头文件目录
│   └── utils.h
├── src/               # 源文件目录
│   ├── main.c
│   └── utils/
│       ├── util.c
│       └── CMakeLists.txt  # 子目录 CMake 配置
├── build/             # 编译目录（手动创建）
└── CMakeLists.txt     # 根目录 CMake 配置
代码文件内容
头文件 include/utils.h、src/utils/util.c、src/main.c 与 Makefile 案例完全相同。
CMake 配置文件
根目录 CMakeLists.txt：
cmake_minimum_required(VERSION 3.10)
project(MyProject)
# 指定 C 标准（可选）
set(CMAKE_C_STANDARD 11)
set(CMAKE_C_STANDARD_REQUIRED ON)
# 包含头文件目录（全局生效）
include_directories(include)
# 添加子目录（会执行 src/utils/CMakeLists.txt）
add_subdirectory(src/utils)
# 定义主程序源文件（仅主函数）
set(MAIN_SRC src/main.c)
# 生成可执行文件（链接子目录生成的库）
add_executable(app ${MAIN_SRC})
target_link_libraries(app utils)  # 链接子目录生成的库
子目录 src/utils/CMakeLists.txt：
# 定义当前目录的源文件（仅功能实现）
set(UTIL_SRC util.c)
# 生成静态库（库名：utils）
add_library(utils STATIC ${UTIL_SRC})
# 可选：设置库的输出目录（例如放到 build/lib）
set_target_properties(utils PROPERTIES ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
操作说明
进入 build 目录（需手动创建）：
mkdir build && cd build
执行 cmake .. 生成构建文件（会自动处理跨目录依赖）。
执行 make 编译，生成：
静态库 build/lib/libutils.a（子目录生成）。
可执行文件 build/app（根目录生成）。
运行 ./app，输出 3 + 5 = 8。


Chocolatey
CMD：set http_proxy=http://127.0.0.1:7890
CMD：set http_proxy=socks5://127.0.0.1:7890
CMD：@"%SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe" -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command "[System.Net.ServicePointManager]::SecurityProtocol = 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))" && SET "PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin"
PowerShell：$env:HTTP_PROXY="http://127.0.0.1:7890"
PowerShell：$env:HTTP_PROXY="socks5://127.0.0.1:7890"
PowerShell：Remove-Item C:\ProgramData\chocolatey -Recurse
PowerShell：Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))

解决flutter下载dartsdk慢的办法
CMD：set FLUTTER_STORAGE_BASE_URL=https://mirrors.sjtug.sjtu.edu.cn/ 
CMD：set PUB_HOSTED_URL=https://dart-pub.mirrors.sjtug.sjtu.edu.cn/
上海交通大学
FLUTTER_STORAGE_BASE_URL: https://mirrors.sjtug.sjtu.edu.cn/
PUB_HOSTED_URL: https://dart-pub.mirrors.sjtug.sjtu.edu.cn/
**Flutter 社区**
FLUTTER_STORAGE_BASE_URL: https://storage.flutter-io.cn
PUB_HOSTED_URL: https://pub.flutter-io.cn
**清华大学 TUNA 协会**
FLUTTER_STORAGE_BASE_URL: https://mirrors.tuna.tsinghua.edu.cn/flutter
PUB_HOSTED_URL: https://mirrors.tuna.tsinghua.edu.cn/dart-pub
**上海交通大学**
FLUTTER_STORAGE_BASE_URL: https://mirrors.sjtug.sjtu.edu.cn/ 
PUB_HOSTED_URL: https://dart-pub.mirrors.sjtug.sjtu.edu.cn/

Windows环境下安装pkg-config
安装choco
Set-ExecutionPolicy AllSigned 策略全是A
Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
安装pkg-config
choco install pkgconfiglite

Gradle全局配置修改(http://repo.maven.apache.org/maven) 在 ${USER_HOME}/.gradle/ 目录下创建 init.gradle 文件，添加以下内容：
allprojects{
    repositories {
        def ALIYUN_REPOSITORY_URL = 'https://maven.aliyun.com/repository/public'
        def ALIYUN_JCENTER_URL = 'https://maven.aliyun.com/repository/public'
        def ALIYUN_GOOGLE_URL = 'https://maven.aliyun.com/repository/google'
        def ALIYUN_GRADLE_PLUGIN_URL = 'https://maven.aliyun.com/repository/gradle-plugin'
        all { ArtifactRepository repo ->
            if(repo instanceof MavenArtifactRepository){
                def url = repo.url.toString()
                if (url.startsWith('https://repo.maven.apache.org/maven2/')) {
                    project.logger.lifecycle "Repository ${repo.url} replaced by $ALIYUN_REPOSITORY_URL."
                    remove repo
                }
                if (url.startsWith('https://repo1.maven.org/maven2/')) {
                    project.logger.lifecycle "Repository ${repo.url} replaced by $ALIYUN_REPOSITORY_URL."
                    remove repo
                }
                if (url.startsWith('https://jcenter.bintray.com/')) {
                    project.logger.lifecycle "Repository ${repo.url} replaced by $ALIYUN_JCENTER_URL."
                    remove repo
                }
                if (url.startsWith('https://dl.google.com/dl/android/maven2/')) {
                    project.logger.lifecycle "Repository ${repo.url} replaced by $ALIYUN_GOOGLE_URL."
                    remove repo
                }
                if (url.startsWith('https://plugins.gradle.org/m2/')) {
                    project.logger.lifecycle "Repository ${repo.url} replaced by $ALIYUN_GRADLE_PLUGIN_URL."
                    remove repo
                }
            }
        }
        maven { url ALIYUN_REPOSITORY_URL }
        maven { url ALIYUN_JCENTER_URL }
        maven { url ALIYUN_GOOGLE_URL }
        maven { url ALIYUN_GRADLE_PLUGIN_URL }
    }
}

https://support.github.com/request/landing
github  Suspended或者Your account has been flagged.申诉解决办法
https://support.github.com/contact/reinstatement
Would you like to provide any additional information or context that would be helpful for our review of your reinstatement request?
Dear sir or madam:
I am writing to seek your help. My GitHub account has been flagged and my profile is hidden from public. It brings me a whole lot of trouble because my friends on GitHub cannot see my open source project in my GitHub warehouse. I doubt whether this problem has something to do with my recent network fluctuation. I would appreciate your help if you unlock the hidden profile as soon as possible. Thank you so much!

git clone git://github.com/gittup/tup.git
cd tup
./bootstrap.sh
man ./tup.1

set Env=env #临时变量
setx Env env #用户变量
setx /m Env env #系统变量

python -m pip install -i https://mirrors.bfsu.edu.cn/pypi/web/simple --upgrade pip
pip3 install torch torchvision torchaudio -i https://mirrors.bfsu.edu.cn/pypi/web/simple
pip3 install tensorflow -i https://mirrors.bfsu.edu.cn/pypi/web/simple
pip3 install modelscope -i https://mirrors.bfsu.edu.cn/pypi/web/simple
pip3 install  -i https://mirrors.bfsu.edu.cn/pypi/web/simple --upgrade urllib3
pip3 install  -i https://mirrors.bfsu.edu.cn/pypi/web/simple --upgrade requests
pip3 install transformers -i https://mirrors.bfsu.edu.cn/pypi/web/simple
modelscope download --model=OpenBMB/MiniCPM3-4B --local_dir ./MiniCPM3-4B
modelscope download --model=OpenBMB/MiniCPM3-4B-GPTQ-Int4 --local_dir ./MiniCPM3-4B-GPTQ-Int4
https://modelscope.cn/organization/OpenBMB
https://modelscope.cn/models/OpenBMB/MiniCPM-V-2_6-gguf

一、清华源 https://pypi.tuna.tsinghua.edu.cn/simple/
pip install xxx -i https://pypi.tuna.tsinghua.edu.cn/simple/
二、阿里源 https://mirrors.aliyun.com/pypi/simple
pip install xxx -i https://mirrors.aliyun.com/pypi/simple
三、中科大源 https://pypi.mirrors.ustc.edu.cn/simple/
pip install xxx -i https://pypi.mirrors.ustc.edu.cn/simple/
四、豆瓣源 http://pypi.douban.com/simple/
pip install xxx -i http://pypi.douban.com/simple/
pip config set global.index-url http://mirrors.aliyun.com/pypi/simple/ 
pip config set install.trusted-host mirrors.aliyun.com
python -m pip install --upgrade pip
pip install -U huggingface_hub hf_transfer
setx HF_ENDPOINT https://hf-mirror.com
setx HF_HOME D:/VscodiumZone/.cache/huggingface 
setx TRANSFORMERS_CACHE D:/VscodiumZone/.cache   
huggingface-cli download --resume-download runfuture/MiniCPM-2B-dpo-q4km-gguf --local-dir MiniCPM-2B-dpo-q4km-gguf
huggingface-cli download --resume-download --local-dir-use-symlinks False runfuture/MiniCPM-2B-dpo-q4km-gguf--local-dir  MiniCPM-2B-dpo-q4km-gguf  --cache-dir  MiniCPM-2B-dpo-q4km-gguf

pip config set global.index-url https://mirror.baidu.com/pypi/simple
pip config set install.trusted-host mirror.baidu.com
pip config set global.index-url https://mirrors.aliyun.com/pypi/simple
pip config set install.trusted-host mirrors.aliyun.com
python -m pip install --upgrade pip //更新pip
pip install uv //pip替代

修复：无法终止进程。操作无法完成，访问被拒绝。
cmd：tskill pid
powershell：Stop-Process -ID pid
powershell：Stop-Process -Name "java"

del /s /f /q xx.xx
del /s /f /q *.txt *.png *.jpg
rmdir /s /q  xx

setx GRADLE_USER_HOME "D:/.gradle" /m
set X_VCPKG_ASSET_SOURCES="x-azurl,http://106.15.181.5/" /m
set VCPKG_DEFAULT_TRIPLET="x86-windows" /m
setx X_VCPKG_ASSET_SOURCES "x-azurl,http://106.15.181.5/" /m
setx VCPKG_DEFAULT_TRIPLET "x86-windows" /m

VCPKG全套教程
1.下载安装： git clone https://github.com/microsoft/vcpkg
2.运行bootstrap-vcpkg.bat下载vcpkg.exe
、运行验证：在当前页面下 按住shift打开powershell终端
然后输入 ./vcpkg（也可以直接vcpkg）(如果是cmd就是输入vcpkg cmd不要./)
4、进行测试 是否成功安装（安装OPENSSL测试）
./vcpkg install openssl:x64-windows 或者是
./vcpkg install openssl --triplet=x64-windows 两者等价一样
配置变量名称 VCPKG_DEFAULT_TRIPLET  值是 x64-windows
用了这个之后 我们写代码就是直接可以 vcpkg install zlib 不需要：x64-windows
易错点
我写这样的代码 是不可以运行的 需要对所有以后的代码进行修改
vcpkg install zlib：x64-windows # 不可以
vcpkg install zlib --triplet=x64-windows # 可以
补充知识：
①Vcpkg可以用国内源，但是我没用，我有vpn，不过不连接网络似乎也可以下载包，只要网速快就行。
②用“vcpkg install name（包名）”默认下载的是x86包，在x64系统上不能运行，因此需要三元指定--triplet=x64-windows
③查看已经下载的库 vcpkg list
④搜索网上的这个库 这样还可以看看版本号 比如下面的vcpkg search opencv
那么怎么指定呢 这个详细见vcpkg.json 这里告诉了我们怎么操作
⑤删除已经下载的库 vcpkg remove xx --triplet=x64-windows （还得加上三元，要不然又报错，但是假如系统重指定了x64-windows的，可以不用加上--triple=x64-windows或者是：x64-windows）然后这个命令删除的时候 由于很多库之间有依赖 因此这样的话其实会报错不让你删掉，报错如下：
因此我们需要改为 vcpkg remove zlib --triplet=x64-windows --recurse
加上 --recurse 选项来递归删除这些库及其依赖项,但实际上我们可能是只想删这个，因此其他的我还要下载回来，比如opencv4，所以删除了包之后，我需要再下回来
vcpkg install libpng opencv4 tiff --triplet=x64-windows
这种方法可以让你删除 zlib，而不会影响其他已安装的库（remove的移除也只是移除了二进制程序库而已，源码包和解压缩的源码并没有删除 因此上图重新安装非常快）
1、首先建议每次使用vcpkg都先初始化一下（作为更新）：
./bootstrap-vcpkg.bat或者双击两下
2、查看opencv版本 选择安装
3、安装opencv4
vcpkg install opencv4
（这里非常值得注意:由于opencv4或者opencv3 他的结构目录是opencv4/opencv2/opencv.hpp）
因此我们需要看一下他的地址，这是因为后续使用这个vcpkg的包的时候，我们应用的头文件路径是vcpkg-master\installed\x64-windows\include，因此这个opencv4反倒是累赘，在代码里只会使引用路径为#include <opencv2/opencv.hpp> 所以我们需要将其opencv2整个文件目录复制到include文件目录下，然后后续代码引用就没问题（opencv4就不删了，也许以后用opencv3呢对吧，到时候再把3的拿出来，直接把opencv2的删掉，用3里的cv2代替
4、关联vcpkg安装好的OpenCV到Visual Studio
方法1：针对个体，不常用
vcpkg integrate project # 生成配置
此时会在“D:\appset\vcpkg\vcpkg-master\vcpkg.D.appset.vcpkg.vcpkgmaster.1.0.0.nupkg”下，生成nuget配置文件
打开Visual Studio，点击菜单“工具->NuGet包管理器->程序包管理器设置”，进入设置界面，点击“程序包源”。
这个地址是对应的那个nuget包生成的地址使用的，所以是在vcpkg下，有的说是在buildsystem中是不对的，得具体分析。
工程配置：打开Visual Studio 后右键点击需要设置的工程，选择“管理NuGet程序包”。
这个版本是1.0.0 这个就是我们生成的，然后就可以用代码进行测试了
#include <iostream>
#include <opencv2/opencv.hpp>
using namespace std; // 常规名称空间
using namespace cv; // 应用Opencv名称空间
int main() // 主函数
{
Mat img; //
img = imread("1.jpg"); // 以绝对地址导入图片，图片路径是自己设置的
if (img.empty()) // 判断是否导入图片
{
cout << "请确认图片正确位置！" << endl;
return -1; // 返回-1
}
namedWindow("test", WINDOW_NORMAL); // 创建一个常规窗口
resizeWindow("test", 1080, 960); // 设置窗口大小
imshow("test", img); // 展示图片
waitKey(100000);
auto key = waitKey(0); // 获取键盘按键响应
if (key == 'q') // 判断案件是否为q
{
cout << "\n销毁窗口。\n";
destroyAllWindows(); // 销毁所有窗口
}
return 0; // 主函数结束
}
然后可能识别慢，重新生成就好了！（build ctrl+b的生成，也可以关闭vs再打开）
如果此时新加了库 那么我们需要重新生成一下nuget的包 但是VS中不需要重新安装了，介绍的时候说了，只是给路径依赖，不包含包的
方法2：针对整个环境，可以搭配vcpkg.json,cmake，常用
使用 vcpkg integrate install #这样不会生成nuget文件 也无需使用nuget，直接就可以将目前vcpkg下载的所有包链接到了当前的工程下，可以随意#include库的头文件，编译时dll也会自动拷贝到目标目录。这里的头文件和目录是在下图所示文件夹下：
然后我们直接打开vs就可以运行了，前提是比如opencv的路径是对的，否则会是这样：
但是此种方法要是库进行了修改，比如增添些新的头文件，那么就需要把当前集成的这个删去： vcpkg integrate remove # 取消全局集成
但是这并没有结束，针对方法2的做法，我们会接下来做更多的讲解，阐述vcpkg.json和cmakelists在这里的使用方法。
3：详细Vcpkg和VS与VSCODE的集成（vcpkg.json与cmake）
常规情况下，我们需要设置include目录、lib目录等。Vcpkg提供了一套机制，可以全自动的适配目录，而开发者不需要关心已安装的库的目录在哪里，也不需要设置。这是Vcpkg的一大优势。
3.1 集成到工程
上面已经可以集成到全局，为什么还要“集成到工程”呢？因为在大部分情况下，我们不希望集成到全局，毕竟有很多第三方库我们希望自定义处理一下，或者干脆不想集成第三方库。那么集成到工程是最灵活的处理方式。也是工程级项目推荐的处理方式
1：windows下vs使用：
方法1：第二章的方法2，vcpkg integrate install
方法2：在其方法1基础上使用manifest（原因是这样可以方便第三者使用）（也叫使用MSBuild安装和管理包，manifest叫启用清单模式）
manifest配置需要我们使用vcpkg.json文件，他实际上是已经开启了vcpkg integrate install 或者vcpkg integrate project+安装了nuget，因此才会有这个界面可供我们选择开启是否使用manifest。
vcpkg.json的目的是什么，这个其实就跟github中的environments.txt文件夹一模一样，指定了当前项目需要什么依赖，然后我们根据这个依赖，下载需要的头文件，就和pip install environments.txt一样。通常是有了这个明确规定，我们指定了需要哪些库，因此给别人用的时候别人也知道到底需要哪个，而不是全部下载了。此外，vcpkg.json的权限高于全局的vcpkg integrate install 的权限，因此，假如在vcpkg.json中指定了一个版本，但电脑上有这个库单不是这个版本的，也会将其vcpkg install下载，然后使用他，具体操作为：
首先测试的代码为：filename.cpp
#include <iostream>
#include <fstream>
#include <sstream>
#include <json/json.h>
#define JSON_PATH "./" // 这里值的注意，如果filename.cpp和vcpkg.json 同级目录，那么这样是对的
using namespace std;
int main()
{
ifstream fs;
string jsonPath = JSON_PATH;
jsonPath.append("vcpkg.json");
fs.open(jsonPath);
if (!fs.is_open())
return -1;
ostringstream ss;
ss << fs.rdbuf();
fs.close();
string rawJson = ss.str();
JSONCPP_STRING err;
Json::CharReaderBuilder builder;
const std::unique_ptr<Json::CharReader> reader(builder.newCharReader());
Json::Value root;
if (!reader->parse(rawJson.c_str(), rawJson.c_str() + static_cast<int>(rawJson.length()), &root, &err))
{
return -1;
}
if (root["name"].isString())
cout << "project name: " << root["name"].asString() << endl;
return 0;
}
在sln同级目录下创建清单文件vcpkg.json并填入以下代码：
{
"name": "test1",
"version-string": "0.0.1",
"dependencies": [
"jsoncpp"
]
}
其中test1是随便起的名字，和sln以及cpp命名均无关，唯一有关的就是dependencies，这里存放着依赖的库
然后启用manifest功能
生成项目
此时我会发现，他下面会自动下载
然后在当前工程下，也会有相应的vcpkg专门存储（这个不是存储到系统当中的那个vcpkg，所以这个还是有点优势的，存在当前项目下的）
然后我又测试了opencv的代码，同样，也会有下载了opencv4的问题，opencv4/opencv2/opencv.hpp，解决方法是，先让他下载opencv4，然后将里面的opencv2复制到同样的路径下，就可以。
#include <iostream>
#include <opencv2/opencv.hpp>
using namespace std; // 常规名称空间
using namespace cv; // 应用Opencv名称空间
int main() // 主函数
{
Mat img; //
img = imread("1.jpg"); // 以绝对地址导入图片，图片路径是自己设置的
if (img.empty()) // 判断是否导入图片
{
cout << "请确认图片正确位置！" << endl;
return -1; // 返回-1
}
namedWindow("test", WINDOW_NORMAL); // 创建一个常规窗口
resizeWindow("test", 1080, 960); // 设置窗口大小
imshow("test", img); // 展示图片
waitKey(100000);
auto key = waitKey(0); // 获取键盘按键响应
if (key == 'q') // 判断案件是否为q
{
cout << "\n销毁窗口。\n";
destroyAllWindows(); // 销毁所有窗口
}
return 0; // 主函数结束
}
但是这里还有一个问题，也是manifest的缺点，我们此时ctrl+点击opencv是进不去的，但是他能找到路径，因此manifest是我们做完这个项目，给别人交付的时候写的，要不然自己进入不了其中的头文件，有些东西看起来非常麻烦（怎么看头文件呢，去vcpkg设置那里使用manifest改为否就行
）
附表修改vcpkg中的参数：
方法2的官方做法：https://learn.microsoft.com/zh-cn/vcpkg/get_started/get-started-msbuild?pivots=shell-powershell
稍微有点区别的就是，官方文档中生成vcpkg.json不是这么生成的，而是使用代码如下：
创建vcpkg清单文件 (vcpkg.json)：
vcpkg new --application
生成一个一个vcpkg.json文件和一个vcpkg-configuration.json文件
添加jsoncpp包作为依赖项：
vcpkg add port jsoncpp
此时vcpkg.json文件包含：
这是清单文件。vcpkg 读取清单文件，以了解要安装和与MSBuild集成的依赖项，从而提供项目所需的依赖项。
生成的vcpkg-configuration.json文件引入了一个基线，用于对项目的依赖项设置最低版本约束。修改此文件超出了本教程的范围。虽然在本教程中不适用，但建议将vcpkg-configuration.json文件保留在源代码管理之下，以确保不同开发环境中的版本一致性。
方法3：vcpkg.json+cmake+vs2022 这里库并没有提前下载好，是现场下载，这就是vcpkg.json的作用：vcpkg会自动检测您的项目中是否包含vcpkg.json（与最顶级的CMakeLists.txt同级目录）从而自动激活manifest模式。vcpkg将在您的项目配置时自动将所有依赖库编译并安装至您的本地编译目录下(${CMAKE_BINARY_DIR}/vcpkg_installed)
第一步：
cmake.exe -G "Visual Studio 17 2022" -T v143 -A x64 -DVCPKG_TARGET_TRIPLET=x64-windows -DVCPKG_BUILD_TYPE=debug -DCMAKE_TOOLCHAIN_FILE:STRING="D:/appset/vcpkg/vcpkg-master/scripts/buildsystems/vcpkg.cmake" .
这里面-T v143是指定msvc版本 但其实假如使用的VS版本对应的上msvc的，不用写这句话，这是为了不同版本准备的。Cmake
注意，这里结尾有一个点，意思是告诉源代码目录：CMake需要知道项目的源代码位置，主要是包含CMakeLists.txt文件的路径。当然，也可以不加，因为就在当前目录下，所以无所谓。
因此精简修改版本是：cmake -G "Visual Studio 17 2022" -A x64 -DVCPKG_TARGET_TRIPLET=x64-windows -DVCPKG_BUILD_TYPE=debug -DCMAKE_TOOLCHAIN_FILE:STRING="D:/appset/vcpkg/vcpkg-master/scripts/buildsystems/vcpkg.cmake" -B build
-B build这样会非常好看，将结果存在build文件中
第二步：
cmake.exe --build .
用来构建项目的命令，告诉CMake使用当前目录（.）下的构建系统文件（如Makefile或.sln文件）来进行编译、链接，生成目标文件，我们也对其进行修改
cmake --build build
这样就指定了刚才修剪过的build文件夹作为编译的地方。
第三步：
此时进入到Debug下，运行最后生成的项目
这里的代码为：
Cmakelists：
cmake_minimum_required(VERSION 3.10)
project(HelloWorld)
add_executable (test "test.cpp")
find_package(jsoncpp CONFIG REQUIRED)
target_link_libraries(test PRIVATE jsoncpp_lib)
target_compile_definitions(test PRIVATE -DJSON_PATH="${CMAKE_CURRENT_LIST_DIR}/")
Test.Cpp：
// 打印清单文件中的项目名称
#include <iostream>
#include <fstream>
#include <sstream>
#include <json/json.h>
#ifndef JSON_PATH
#define JSON_PATH
#endif
using namespace std;
int main()
{
ifstream fs;
string jsonPath = JSON_PATH;
jsonPath.append("vcpkg.json");
fs.open(jsonPath);
if (!fs.is_open())
return -1;
ostringstream ss;
ss << fs.rdbuf();
fs.close();
string rawJson = ss.str();
JSONCPP_STRING err;
Json::CharReaderBuilder builder;
const std::unique_ptr<Json::CharReader> reader(builder.newCharReader());
Json::Value root;
if (!reader->parse(rawJson.c_str(), rawJson.c_str() + static_cast<int>(rawJson.length()), &root, &err))
{
return -1;
}
if (root["name"].isString())
cout << "project name: " << root["name"].asString() << endl;
return 0;
}
Vcpkg.Json：
{
"name": "test",
"dependencies": [
"jsoncpp"
]
}
方法4：cmake界面版本（不用vcpkj.json 但是需要的库提前安装好）
首先在helloword文件夹下写好cmakelists和.cpp
cmake_minimum_required(VERSION 3.10)
project(HelloWorld)
find_package(fmt CONFIG REQUIRED)
add_executable(HelloWorld helloworld.cpp)
target_link_libraries(HelloWorld PRIVATE fmt::fmt)
#include <fmt/core.h>
int main()
{
fmt::print("Hello World!\n");
return 0;
}
然后再③这里改变量为：
然后点击④（注意，点击前建议清空cache，防止上个项目干扰，我之间命令行出错很大原因就是因为这个cache残留导致我出错）
然后再点击⑤和⑥，就自动帮我们打开vs2022，此时我们打开之后，应该怎么操作呢：
方法5：使用vs2022创建cmake工程，但是这个我没成功，详细链接在这，我始终找不到CMakeSettings.json
https://www.cnblogs.com/vcpkg/p/14550478.html
2：windows下vscode使用：
类似于上面的方法3一样：vcpkg.json+cmake+vscode
首先有这三个文件，代码和方法3一模一样
打开settings.json文件，进行文本添加
添加的代码为：
"cmake.configureSettings": {"CMAKE_TOOLCHAIN_FILE":"D:\\appset\\vcpkg\\vcpkg-master\\scripts\\buildsystems\\vcpkg.cmake"}
然后生成，接着运行代码：
拓展：如何指定使用版本
在vcpkg.json文件中 我们加入这两行代码，
"builtin-baseline":"dbdc9b3b8253dc9ba82df547c431eb52e5e3dafc",
"overrides":[{"name":"jsoncpp","version":"1.9.1"}]
·其中 dbdc9b3b8253dc9ba82df547c431eb52e5e3dafc指的是vcpkg仓库中的一个commit版本，而不是jsoncpp的commit版本。
builtin-baseline设定了vcpkg使用的基准commit版本。这意味着vcpkg会从这个版本开始处理包的版本控制。
overrides字段则用于手动覆盖某些包的版本，比如jsoncpp，允许你指定一个不同的版本（如1.9.1）（不用担心版本找不到，如果写错版本，他会提示错误说明没有这个版本）
这里的commit是指如下操作：
但是如果要使用这个功能，我们vcpkg是要用git clone 下载的，而不是zip，否则管理不了包，没有.git文件，然后报错如下：
解决方法就是用git clone下载vcpkg才行，但是我下不下来，算了以后碰到再说。
PS:额外参数详细介绍：
0：我们如何知道在cmakelists中怎样用find_package和traget_link_libraries来指定库呢：
当我们下载这个包的时候，他有使用提示的，照这个改就行了。
1、在cmake文件中加入下面这句话即可集成动态库
cmake -DCMAKE_TOOLCHAIN_FILE=<vcpkg_dir>/scripts/buildsystems/vcpkg.cmake
其中<vcpkg_dir>是指vcpkg实际所在目录,要自己动手改
在 CMake 中集成静态库，需要额外指令：
cmake .. -DCMAKE_TOOLCHAIN_FILE=<vcpkg_dir>/scripts/buildsystems/vcpkg.cmake -DVCPKG_TARGET_TRIPLET=x64-windows-static
这个我还没试过，不知道怎么操作
https://blog.csdn.net/qq_58515541/article/details/139921345
4:添加 vcpkg 路径（正常按照操作不会来到这一步）
如果 vcpkg 没有被正确识别，可以手动添加 vcpkg 的库路径。在 Visual Studio 中：
1）右键点击你的项目，选择 Properties。
2）在左侧菜单中，找到 VC++ Directories，在 Include Directories 和 Library Directories 中添加 vcpkg 的路径，通常是在 vcpkg\installed\x64-windows\include 和 vcpkg\installed\x64-windows\lib。
5:使用 VS 内置的命令提示符
打开 Visual Studio 2022。
在菜单栏中，选择 Tools（工具）。
然后选择 Command Line（命令行），你可以看到几个选项：
）Developer Command Prompt：用于执行与 Visual Studio 相关的命令。
）PowerShell：打开 Windows PowerShell。
或者是：
5.1 更新已经安装的开源库
一般有两种更新方式。一个是update指令，可以显示可以升级的开源库的列表。另一个是upgrade的指令，会重新编译所有需要更新的包。
5.2 导出已经安装的开源库
有的时候，一个项目组中有很多人，不需要每个人都参与编译。一个人编译好所有开源库后到处给别人即可。有的时候也是出于备份的目的，也会导出已经安装的开源库。导出可以执行export指令。例如，我要导出opencv4 库，那么执行：
vcpkg export opencv4 --7zip --triplet=x64-windows (加不加triple都行)
如果不加--7zip 那么就是生成文件夹
注意，导出时必须指定导出的包格式。vcpkg支持5种导出包格式，有
默认情况下只会导出x86-windows的包（我已经改成默认64），如果要导出所有包，那需要制定相应的triplet。比如，如果同时导出x86和x64版本的opencv4 ，那执行命令：
vcpkg export opencv4 opencv4 :x64-windows --7zip
这个命令等价于：
vcpkg export opencv4 :x86-windows opencv4 :x64-windows --7zip
如果要指定输出目录和特定文件名，需使用"–-output="参数
vcpkg export opencv4 --7zip --triplet=x64-windows --output=/path/to/your/folder
各种依赖都在这里
5.3 导入备份的开源库（尚未尝试）
导入比较简单，执行import指令即可。例如：
vcpkg import xxx.7z
5.4 vcpkg本地组成
：下载工具和下载的源代码包
：所有vcpkg支持的库的配置，假如想知道自己的库是否被vcpkg支持，来到这个目录里看看有没有相应的目录即可。
：源码被展开编译的地方，存着部分编译的中间结果，debug版本的库在调试的时候，用的是这里的PDB文件和代码
6:未来实现：
https://blog.csdn.net/tanmx219/article/details/123938447 如何真正卸载掉坏包，安装新包而不走缓存


vcpkg 配置clang编译
在使用vcpkg配置并使用clang编译器进行编译时，你需要确保你的环境配置正确，并正确设置vcpkg以使用clang。以下是一些步骤和提示，帮助你完成这一过程：
1. 安装必要的工具
确保你的系统中安装了clang编译器。在大多数Linux发行版中，你可以通过包管理器安装clang。例如，在Ubuntu上，你可以使用以下命令：
sudo apt update
sudo apt install clang
对于Windows，你可能需要安装LLVM，可以从LLVM官网下载预编译的二进制文件，或者使用如Chocolatey的包管理器：
choco install llvm
2. 配置vcpkg以使用Clang
在配置vcpkg时，你需要指定编译器。你可以通过设置VCPKG_CXX_COMPILER环境变量来指定使用clang++作为C++编译器。例如，在Unix-like系统（包括MacOS和Linux）上，你可以在终端中这样设置：
export VCPKG_CXX_COMPILER=clang++
在Windows上，你可以在命令提示符中使用：
set VCPKG_CXX_COMPILER=clang++
3. 安装库并指定生成器
当你使用vcpkg install命令安装库时，可以通过--triplet参数指定一个生成器（通常是针对特定编译器的预设配置）。例如，如果你想为使用clang的x64平台安装一个库，你可以使用：
vcpkg install <library-name>:x64-clang
如果你没有特定的生成器需求，也可以直接使用：
vcpkg install <library-name> --triplet x64-windows-static-md
确保你的项目配置文件（如CMake的CMakeLists.txt）正确设置了编译器路径。对于CMake，你可以在CMake缓存中设置：
set(CMAKE_C_COMPILER clang)
set(CMAKE_CXX_COMPILER clang++)
4. 编译项目
一旦库被安装并且项目配置正确，你就可以使用CMake或其他构建系统来编译你的项目了。例如，使用CMake时：
cmake .. -B build -DCMAKE_TOOLCHAIN_FILE=<path-to-vcpkg>/scripts/buildsystems/vcpkg.cmake
cmake --build build --config Release
确保替换<path-to-vcpkg>为你的vcpkg实际路径。
5. 测试和调试
最后，确保运行和测试你的应用程序以验证一切是否正常工作。如果遇到任何链接错误或编译问题，检查编译器和链接器的路径设置是否正确，以及是否所有依赖都已正确安装。
通过以上步骤，你应该能够成功配置vcpkg以使用clang编译器进行编译。如果遇到具体问题，检查错误信息并根据需要进行调整。
Built-in Triplets:
  arm-neon-android
  arm64-android
  arm64-osx
  arm64-uwp
  arm64-windows-static-md
  arm64-windows
  x64-android
  x64-linux
  x64-osx
  x64-uwp
  x64-windows-release
  x64-windows-static-md
  x64-windows-static
  x64-windows
  x86-windows
Community Triplets:
  arm-android
  arm-ios
  arm-linux-release
  arm-linux
  arm-mingw-dynamic
  arm-mingw-static
  arm-uwp-static-md
  arm-uwp
  arm-windows-static
  arm-windows
  arm64-ios-release
  arm64-ios-simulator-release
  arm64-ios-simulator
  arm64-ios
  arm64-linux-dynamic
  arm64-linux-release
  arm64-linux
  arm64-mingw-dynamic
  arm64-mingw-static
  arm64-osx-dynamic
  arm64-osx-release
  arm64-uwp-static-md
  arm64-visionos
  arm64-windows-static-release
  arm64-windows-static
  arm64ec-windows
  armv6-android
  loongarch32-linux-release
  loongarch32-linux
  loongarch64-linux-release
  loongarch64-linux
  mips64-linux
  ppc64le-linux-release
  ppc64le-linux
  riscv32-linux-release
  riscv32-linux
  riscv64-linux-release
  riscv64-linux
  s390x-linux-release
  s390x-linux
  wasm32-emscripten
  x64-freebsd
  x64-ios
  x64-linux-dynamic
  x64-linux-release
  x64-mingw-dynamic
  x64-mingw-static
  x64-openbsd
  x64-osx-dynamic
  x64-osx-release
  x64-uwp-static-md
  x64-windows-static-md-release
  x64-windows-static-release
  x64-xbox-scarlett-static
  x64-xbox-scarlett
  x64-xbox-xboxone-static
  x64-xbox-xboxone
  x86-android
  x86-freebsd
  x86-ios
  x86-linux
  x86-mingw-dynamic
  x86-mingw-static
  x86-uwp-static-md
  x86-uwp
  x86-windows-static-md
  x86-windows-static
  x86-windows-v120
  

npm config set registry https://registry.npmmirror.com  切换淘宝NPM镜像站
npm config get registry 查看镜像状态
npm config set registry https://registry.npmjs.org  恢复官方镜像源

安装cnpm 
npm install -g cnpm --registry=https://registry.npmmirror.com
安装pnpm
npm install -g pnpm --registry=https://registry.npmmirror.com
# 注册模块镜像
npm set registry https://registry.npmmirror.com  
// node-gyp 编译依赖的 node 源码镜像  
npm config set disturl https://npmmirror.com/dist 
npm set disturl https://npmmirror.com/dist 
// 清空缓存  
npm cache clean --force  
# mirror config
sharp_binary_host = https://npmmirror.com/mirrors/sharp
sharp_libvips_binary_host = https://npmmirror.com/mirrors/sharp-libvips
profiler_binary_host_mirror = https://npmmirror.com/mirrors/node-inspector/
fse_binary_host_mirror = https://npmmirror.com/mirrors/fsevents
node_sqlite3_binary_host_mirror = https://npmmirror.com/mirrors
sqlite3_binary_host_mirror = https://npmmirror.com/mirrors
sqlite3_binary_site = https://npmmirror.com/mirrors/sqlite3
sass_binary_site = https://npmmirror.com/mirrors/node-sass
electron_mirror = https://npmmirror.com/mirrors/electron/
puppeteer_download_host = https://npmmirror.com/mirrors
chromedriver_cdnurl = https://npmmirror.com/mirrors/chromedriver
operadriver_cdnurl = https://npmmirror.com/mirrors/operadriver
phantomjs_cdnurl = https://npmmirror.com/mirrors/phantomjs
python_mirror = https://npmmirror.com/mirrors/python
registry = https://registry.npmmirror.com
disturl = https://npmmirror.com/dist

本地连github出错“ssh: connect to host github.com port 22: Connection timed out”，如何解决？
当你尝试连接到 GitHub 时遇到 “ssh: connect to host github.com port 22: Connection timed out” 这个错误，这通常意味着有些东西阻止了你的连接。下面是一些建议的解决步骤：
网络连接：确保你的网络连接是稳定的。
端口阻塞：某些网络或ISP可能会阻塞SSH的默认端口（22）。尝试使用443端口连接到GitHub：
ssh -T -p 443 git@ssh.github.com
如果这成功了，你可以考虑永久地更改你的SSH配置以使用443端口。在 ~/.ssh/config 文件中添加以下内容：
Host github.com Hostname ssh.github.com Port 443
代理设置：如果你在使用代理，确保你的SSH配置正确地设置了代理。
SSH密钥：确保你的公钥已经添加到GitHub的SSH keys列表中，并且你的私钥存在于你的机器上。
防火墙设置：确保你的防火墙或安全软件没有阻止SSH连接。
DNS问题：尝试使用IP地址代替域名进行连接，以检查是否是DNS问题。但是注意，长期使用IP地址不是一个好办法，因为GitHub的IP地址可能会变化。
ping测试：尝试使用 ping github.com 来检查你的机器是否可以达到GitHub。
网络工具：使用 traceroute github.com 或 mtr github.com 来检查网络路径中可能存在的问题。
GitHub状态：虽然较少见，但有可能GitHub正在遇到问题。
重新启动：有时简单地重新启动你的计算机和路由器可能会解决问题。
#Host github.com *.github.com
#User git
#Port 22
#Hostname %h
#PreferredAuthentications publickey
#IdentityFile id_rsa
# 设置代理, 127.0.0.1:10808 换成你自己代理软件监听的本地地址
# HTTPS使用-H，SOCKS使用-S   使用gotoh/ssh-connect进行代理
#ProxyCommand connect -S 127.0.0.1:7890 %h %p

//代理github.com ssh
#Host github.com
#User git
#Port 22
#Hostname github.com
#IdentityFile "C:\Users\Administrator\.ssh\id_rsa"
#TCPKeepAlive yes

//代理ssh.github.com ssh
#Host ssh.github.com
#User git
#Port 443
#Hostname ssh.github.com
#IdentityFile "C:\Users\Administrator\.ssh\id_rsa"
#TCPKeepAlive yes

#代理github.com ssh切换到ssh.github.com
Host github.com
User git
# SSH默认端口22， HTTPS默认端口443
Port 443
Hostname ssh.github.com
# SSH私钥位置
IdentityFile "C:\Users\Administrator\.ssh\id_rsa"
TCPKeepAlive yes


Makefile过滤
filter函数：用于从文件列表中选择符合条件的文件。语法为$(filter pattern, text)，其中pattern为匹配模式，text为文件列表。返回符合条件的文件列表。
filter-out函数：用于从文件列表中排除符合条件的文件。语法为$(filter-out pattern, text)，其中pattern为匹配模式，text为文件列表。返回不符合条件的文件列表。
sort函数：用于对文件列表进行排序。语法为$(sort list)，其中list为文件列表。返回排序后的文件列表。
wildcard函数：用于匹配文件名。语法为$(wildcard pattern)，其中pattern为匹配模式。返回符合条件的文件列表
SRC_FOLDER := $(shell find . -maxdepth 2 -type d)
FIND_FOLDER:= $(patsubst ./%,%,$(filter %/$(UNITNAME), $(SRC_FOLDER)))

Makefile/C&Cpp Windows编译脚本
## SHELL=powershell
SHELL=cmd
CXX = g++
CXX = g++
CC = gcc
WINDRES = windres
ASMFLAGS	:=               
RCFLAGS		:= -O coff
CXXFLAGS	:= -std=c++14 -w -O3 -g -static -DWIN32 -D_WIN32 -D__WIN32__ -D_WINDOWS -DWINDOWS -D__WINDOWS__ -D_GLFW_WIN32 -DNANOVG_GLEW -DGLEW_STATIC -D_CRT_SECURE_NO_DEPRECATE -D_CRT_NONSTDC_NO_DEPRECATE -D_CRT_SECURE_NO_WARNINGS -DLUA_COMPAT -DLUA_COMPAT_ALL -DLUA_COMPAT_5_3 -DLUA_COMPAT_5_2  -DFT2_BUILD_LIBRARY -DFT_CONFIG_OPTION_SYSTEM_ZLIB -DBUILDING_LIBCURL -DCURL_HIDDEN_SYMBOLS -DHAVE_CURL_CONFIG_H -DCURL_STATICLIB -DSFML_STATIC -DAL_BUILD_LIBRARY -DAL_LIBTYPE_STATIC -DAL_ALEXT_PROTOTYPES -DFLAC__CPU_X86_64 -DFLAC__HAS_X86INTRIN -DFLAC__ALIGN_MALLOC_DATA -DFLAC__NO_DLL -DFLAC__OVERFLOW_DETECT -DFLAC__HAS_OGG -DFLAC__ENABLE_64_BIT_WORDS  -DLOAD_PNG -DLOAD_JPG -DLOAD_WEBP -DLOAD_GIF -DOGG_MUSIC -DMUSIC_MID_TIMIDITY -DMUSIC_MID_NATIVE -DMUSIC_OGG -DMUSIC_OPUS -DMUSIC_FLAC -DOPUS_CUSTOM_NOSTATIC -DOPUS_BUILD -DVAR_ARRAYS -DFPM_DEFAULT -DFIXED_POINT -DWIN32_LEAN_AND_MEAN             
CCFLAGS		:= -std=c11 -w -O3 -g -static -DWIN32 -D_WIN32 -D__WIN32__ -D_WINDOWS -DWINDOWS -D__WINDOWS__ -D_GLFW_WIN32 -DNANOVG_GLEW -DGLEW_STATIC -D_CRT_SECURE_NO_DEPRECATE -D_CRT_NONSTDC_NO_DEPRECATE -D_CRT_SECURE_NO_WARNINGS -DLUA_COMPAT -DLUA_COMPAT_ALL -DLUA_COMPAT_5_3 -DLUA_COMPAT_5_2  -DFT2_BUILD_LIBRARY -DFT_CONFIG_OPTION_SYSTEM_ZLIB -DBUILDING_LIBCURL -DCURL_HIDDEN_SYMBOLS -DHAVE_CURL_CONFIG_H -DCURL_STATICLIB -DSFML_STATIC -DAL_BUILD_LIBRARY -DAL_LIBTYPE_STATIC -DAL_ALEXT_PROTOTYPES -DFLAC__CPU_X86_64 -DFLAC__HAS_X86INTRIN -DFLAC__ALIGN_MALLOC_DATA -DFLAC__NO_DLL -DFLAC__OVERFLOW_DETECT -DFLAC__HAS_OGG -DFLAC__ENABLE_64_BIT_WORDS  -DLOAD_PNG -DLOAD_JPG -DLOAD_WEBP -DLOAD_GIF -DOGG_MUSIC -DMUSIC_MID_TIMIDITY -DMUSIC_MID_NATIVE -DMUSIC_OGG -DMUSIC_OPUS -DMUSIC_FLAC -DOPUS_CUSTOM_NOSTATIC -DOPUS_BUILD -DVAR_ARRAYS -DFPM_DEFAULT -DFIXED_POINT -DWIN32_LEAN_AND_MEAN               
## FLAG		:= -std=c++11 -m32 -w -O3 -g -static -fprofile-arcs -ftest-coverage -D_WIN32 -DWIN32 -D_DEBUG -DDEBUG -D_WINDOWS -DWINDOWS -D_UNICODE -DUNICODE -DNANOVG_GLEW -DGLEW_STATIC -D_CRT_SECURE_NO_DEPRECATE -D_CRT_NONSTDC_NO_DEPRECATE -D_CRT_SECURE_NO_WARNINGS -DLUA_COMPAT -DLUA_COMPAT_ALL -DSK_IGNORE_ETC1_SUPPORT                   
LFLAGS = -lkernel32 -limm32 -lversion -luser32 -lwinspool -lodbc32 -lodbccp32 -lcomdlg32 -ladvapi32 -lshell32 -lole32 -loleaut32 -luuid  -lwinmm -lmingw32 -lMsimg32 -lopengl32 -lglu32 -lgdi32 -lgdiplus -ld3d9 -ldxguid -ld3d11 -lxinput -ldinput8 -ld2d1 -ldwrite -lwindowscodecs -lshlwapi -lWs2_32 -lIphlpapi -lcomctl32 -lpthread -ldsound -lddraw -lm -lbcrypt -lsetupapi -lsecur32 -lcrypt32  -lpsapi -luserenv
## LFLAGS = -municode -mwindows -fexec-charset=utf-8 -finput-charset=utf-8 -lkernel32 -limm32 -lversion -luser32 -lwinspool -lodbc32 -lodbccp32 -lcomdlg32 -ladvapi32 -lshell32 -lole32 -loleaut32 -luuid  -lwinmm -lmingw32 -lMsimg32 -lopengl32 -lglu32 -lgdi32 -lgdiplus -ld3d9 -ddxguid -dd3d11 -lshlwapi -lWs2_32 -lIphlpapi -lcomctl32 
## LFLAGS = -municode -mwindows -fexec-charset=utf-8 -finput-charset=utf-8 -lkernel32 -limm32 -lversion -luser32 -lwinspool -lodbc32 -lodbccp32 -lcomdlg32 -ladvapi32 -lshell32 -lole32 -loleaut32 -luuid  -lwinmm -lmingw32 -lMsimg32 -lopengl32 -lglu32 -lgdi32 -lgdiplus -ld3d9 -ddxguid -dd3d11 -lshlwapi -lWs2_32 -lIphlpapi -lcomctl32 
## LFLAGS = -Wl,--subsystem,console -municode -mconsole -fexec-charset=gbk -finput-charset=gbk -lkernel32 -limm32 -lversion -luser32 -lwinspool -lodbc32 -lodbccp32 -lcomdlg32 -ladvapi32 -lshell32 -lole32 -loleaut32 -luuid  -lwinmm -lmingw32 -lMsimg32 -lopengl32 -lglu32 -lgdi32 -lgdiplus -ld3d9 -ddxguid -dd3d11 -lshlwapi -lWs2_32 -lIphlpapi 
## LFLAGS = -Wl,--subsystem,windows -municode -mwindows -lkernel32 -limm32 -lversion -luser32 -lwinspool -lodbc32 -lodbccp32 -lcomdlg32 -ladvapi32 -lshell32 -lole32 -loleaut32 -luuid  -lwinmm -lmingw32 -lMsimg32 -lopengl32 -lglu32 -lgdi32 -lgdiplus -ld3d9 -ddxguid -dd3d11 -lshlwapi -lWs2_32 -lIphlpapi
## LFLAGS = -Wl,--subsystem,console -municode -mconsole -lkernel32 -limm32 -lversion -luser32 -lwinspool -lodbc32 -lodbccp32 -lcomdlg32 -ladvapi32 -lshell32 -lole32 -loleaut32 -luuid  -lwinmm -lmingw32 -lMsimg32 -lopengl32 -lglu32 -lgdi32 -lgdiplus -ld3d9 -ddxguid -dd3d11 -lshlwapi -lWs2_32 -lIphlpapi
OUTPUT	:= output
SRC		:= src
INCLUDE	:= include
LIB		:= lib


ifeq ($(OS),Windows_NT)
MAIN	:= main.exe
SOURCEDIRS	:= $(SRC)
INCLUDEDIRS	:= $(INCLUDE)
LIBDIRS		:= $(LIB)
FIXPATH = $(subst /,\,$1)
RM			:= del
TARGET 		:=  /s /q /f
## RM			:= rm 
## TARGET 		:= -f
MD	:= mkdir
else
MAIN	:= main
SOURCEDIRS	:= $(shell find $(SRC) -type d)
INCLUDEDIRS	:= $(shell find $(INCLUDE) -type d)
LIBDIRS		:= $(shell find $(LIB) -type d)
FIXPATH = $1
RM = rm 
TARGET 		:= -f
MD	:= mkdir -p
endif

INCLUDES	:= $(patsubst %,-I%, $(INCLUDEDIRS:%/=%))
LIBS		:= $(patsubst %,-L%, $(LIBDIRS:%/=%))
ASMSOURCES		:= $(wildcard $(patsubst %,%/*.s, $(SOURCEDIRS)))
ASMOBJECTS		:= $(ASMSOURCES:.s=.o)

CXXSOURCES		:= $(wildcard $(patsubst %,%/*.cxx, $(SOURCEDIRS)))
CXXOBJECTS		:= $(CXXSOURCES:.cxx=.o)

CPPSOURCES		:= $(wildcard $(patsubst %,%/*.cpp, $(SOURCEDIRS)))
CPPOBJECTS		:= $(CPPSOURCES:.cpp=.o)

CCSOURCES		:= $(wildcard $(patsubst %,%/*.cc, $(SOURCEDIRS)))
CCOBJECTS		:= $(CCSOURCES:.cc=.o)

CSOURCES		:= $(wildcard $(patsubst %,%/*.c, $(SOURCEDIRS)))
COBJECTS		:= $(CSOURCES:.c=.o)

RCSOURCE 		:= $(wildcard $(patsubst %,%/*.rc, $(SOURCEDIRS)))
RCOBJECTS		:= $(RCSOURCE:.rc=.o)

ASMDEPS		:= $(ASMOBJECTS:.o=.d)
CXXDEPS		:= $(CXXOBJECTS:.o=.d)
CPPDEPS		:= $(CPPOBJECTS:.o=.d)
CCDEPS		:= $(CCOBJECTS:.o=.d)
CDEPS		:= $(COBJECTS:.o=.d)
RCDEPS		:= $(RCOBJECTS:.o=.d)

OUTPUTMAIN	:= $(call FIXPATH,$(OUTPUT)/$(MAIN))

all: $(OUTPUT) $(MAIN)
	@echo Executing 'all' complete!

$(OUTPUT):
	$(MD) $(OUTPUT)

$(MAIN): $(ASMOBJECTS)  $(CPPOBJECTS) $(CXXOBJECTS) $(CCOBJECTS) $(COBJECTS) $(RCOBJECTS)
	$(CXX) $(CXXFLAGS) $(INCLUDES) -o $(OUTPUTMAIN) $(CPPOBJECTS) $(ASMOBJECTS) $(CXXOBJECTS) $(CCOBJECTS) $(COBJECTS) $(RCOBJECTS) $(LFLAGS) $(LIBS)
-include   $(CPPDEPS) $(CXXDEPS) $(CCDEPS) $(CDEPS) $(RCDEPS)
.s.o:
	$(CXX) $(ASMFLAGS) $(INCLUDES) -c -MMD $<  -o $@
.rc.o:
	$(WINDRES) $(RCFLAGS) $(INCLUDES) $<  -o $@ --use-temp-file
.cxx.o:
	$(CXX) $(CXXFLAGS) $(INCLUDES) -c -MMD $<  -o $@
.cpp.o:
	$(CXX) $(CXXFLAGS) $(INCLUDES) -c -MMD $<  -o $@
.cc.o:
	$(CXX) $(CXXFLAGS) $(INCLUDES) -c -MMD $<  -o $@
.c.o:
	$(CC) $(CCFLAGS) $(INCLUDES) -c -MMD $<  -o $@ 
.PHONY: clean
clean:
	del $(call FIXPATH,src/*.o)
	del $(call FIXPATH,src/*.d)
	del $(OUTPUTMAIN)
	@echo Cleanup complete!
run: all
	./$(OUTPUTMAIN)
	@echo Executing 'run: all' complete!

Makefile/Golang编译脚本
.PHONY: all build clean run check cover lint docker help
BIN_FILE=hello
all: check build
build:
    @go build -o "${BIN_FILE}"
clean:
    @go clean
    rm --force "xx.out"
test:
    @go test
check:
    @go fmt ./
    @go vet ./
cover:
    @go test -coverprofile xx.out
    @go tool cover -html=xx.out
run:
    ./"${BIN_FILE}"
lint:
    golangci-lint run --enable-all
docker:
    @docker build -t leo/hello:latest .
help:
    @echo "make 格式化go代码 并编译生成二进制文件"
    @echo "make build 编译go代码生成二进制文件"
    @echo "make clean 清理中间目标文件"
    @echo "make test 执行测试case"
    @echo "make check 格式化go代码"
    @echo "make cover 检查测试覆盖率"
    @echo "make run 直接运行程序"
    @echo "make lint 执行代码检查"
    @echo "make docker 构建docker镜像"
    
Makefile常用函数汇总
 一、名称处理函数
1、wildcard —— 获取指定格式的文件列表
原型（不同格式之间使用空格隔开）
$(wildcard <pattern...>)
示例：获取当前目录下所有的 .cpp 文件和 test目录下所有的 .cpp 文件
$(wildcard *.cpp test/*.cpp)
2、dir —— 获取文件所在目录
获取文件所在目录，本质是获取最后一个反斜杠 '/' 以前的内容。如果没有反斜杠 '/' ，返回 ./
$(dir <names...>)    # 不同文件名之间以空格隔开
$(dir src/foo.c sum.txt)
3、notdir —— 获取文件路径非目录部分
获取一个文件路径的非目录部分，也可以理解为获取文件名（含后缀），本质是获取最后一个反斜杠 '/' 之后的内容。如果没有反斜杠，直接返回本身。
$(notdir <names...>)
$(notdir src/foo.c sum.txt)
4、suffix —— 获取文件后缀
取出文件名的后缀，如果文件无后缀，返回空字符。注意其本质并非是单纯获取到最后一个点符号 '.' 之后的内容。
$(suffix <names…>)
$(suffix src/foo.c src-1.0/bar.c hacks)
5、basename —— 去除文件后缀
$(basename  <names...>)
$(basename src/foo.c src-1.0/bar.c hacks)
二、字符串替换与分析函数
1、subst —— 直接替换字符
subst 直接将 <text> 中的字符 <src> 替换为字符 <dst>。
$(subst <src>,<dst>,<text>)
 示例：注意逗号两边不要有空格
$(subst aa,AA,aabbaa aAfd)
2、patsubst —— 按格式替换字符
patsubs 函数的作用是使用目标字符（格式）替换源字符（格式），函数返回替换以后的结果，常常搭配通配符 % 使用，% 表示任意长度的字串，如果 <src_pattern> 和  <dst_pattern> 都包含 % ，那么此时 % 表示的字符内容是一样的。
函数调用原型如下：
# 将 <text> 中的 源格式 <src_pattern> 替换成目标格式 <dst_pattern>
ret = $(patsubst <src_pattern>,<dst_pattern>,<text>)
示例：将所有满足后缀为 .cpp 格式的字符串替换为 后缀为 .o 格式
$(patsubst %.cpp,%.o,add.cpp bar.cpp)
3、$(C_SOURCES:.c=.o) —— 按指定格式替换后缀
和上面 patsubst  达到的效果是一样的，只不过这里的写法更加简单，通常用于替换文件后缀，这里所表达的意思是：将 C_SOURCES 变量中所有 .c 后缀替换成 .o 。
比如 C_SOURCES 中包含的是
file1.c file2.c file3.c
那么最后会被替换成  
file1.o file2.o file3.o
4、strip —— 去掉开头和结尾的空白字符
这里所说的空白字符可以是 空格键 或者 Tab 产生的
$(strip <string>)
$(strip, add.cpp bar.cpp )
5、findstring —— 在某个字串中查找指定字符串
在字符串 <src> 中查找目标字符或者字符串 <dst>，如果找到了就返回对应字符，如果没有找到返回空字符。
$(findstring <dst>,<src>) 
$(findstring a,a b c) 
6、filter —— 保留指定格式的字符串
保留指定格式的字符串，指定的格式可以有多个，返回保留的字符串 
$(filter <pattern...>,<text>)
sources := foo.c bar.c baz.s ugh.h
result := $(filter %.c %.s,${sources})
7、filter-out —— 去除指定格式的字符串
去除指定格式的字符串，指定的格式可以有多个，返回去除以后的结果
$(filter-out <pattern...>,<text>)
示例： 去掉所有的 .h 文件
sources := foo.c bar.c baz.s ugh.h
result := $(filter %.h,${sources})
8、addprefix —— 为字符串添加前缀
该函数用于向字符串列表中的每个字符串添加指定的前缀。可以是添加路径前缀，也可以添加字符前缀。比如我们要在 所有文件名之前添加路径前缀。
OBJ_FILES = main.o util.o helper.o  
PREFIXED_OBJ_FILES = $(addprefix obj/,$(OBJ_FILES))  
此时 PREFIXED_OBJ_FILES 的输出如下：
obj/main.o obj/util.o obj/helper.o
三、控制函数（信息打印函数）
1、info —— 打印提示信息
向标准输出打印文本 <text> ，用于输出调试信息，make继续执行
$(info <text>)
$(info some debug info)
2、warning —— 打印报警信息
向标准输出打印文本 <text> ，用于输出警告信息。make继续执行
$(warning <text>)
$(warning some warning info)
3、errror —— 打印错误信息
向标准错误输出打印文本 <text> ，用于输出指明错误信息。make停止执行。
$(error <text>)
$(error some error info)
四、其他函数
1、foreach —— 循环函数
将 <list> 中的参数逐一取出放到 <var> 变量中，然后再执行 <expression> 中的表达式。
循环执行中：每执行一次循环都会返回一个字符串，foreach循环会将返回的字符串汇总，不同字符串通过空格分隔
循环执行结束：当整个循环结束的时候，返回汇总的字符串（不同字串以空格分隔）
$(foreach <var>,<list>,<text>)
names := a b c d
files := $(foreach n,${names},$(n).o)
2、call —— 调用函数
makefile中可以自定义函数，call 的作用就是调用自定义的函数或者表达式，也可以传参调用，关于函数的自定义和调用，可以参考：
$(call <expression>,<parm1>,<parm2>,<parm3>,...)
3、shell —— 执行命令行命令
shell 可以执行操作系统的shell命令，返回的是命令行命令的执行结果
shell <commands>
$(shell ps ajx | grep test)
4、eval 
eval 可以将 <text> 中的内容作为makefile的一部分，然后按照makefile的语法解析这些内容，无返回值。该函数在执行时会对参数展开两次，可以理解为第一次是eval函数检查<text>语法，第二次是解析 <text>内容。
$(eval <text>)   
    
Makefile常用函数总结
1、realpath  返回一个绝对路径
例：ROOT  = $(realpath ./)  返回当前路径的绝对地址，赋值给ROOT
2、wildcard 通配符函数,类似于linux中的 “*”
命令格式：
$(wildcard pattern)
例子 ：SRCS = $(wildcard *.c)  得到当前目录下的所有.c文件
3、patsubst 字符串替换函数，是pattern substitute的缩写
命令格式
$(patsubst pattern, replacement, text)
例： OBJS = $(patsubst %.o %.c SRCS) SRCS是上面的当前目录的.c文件，将当前目录的.c文件替换为.o文件，赋值给OBJS
4、addprefix 加前缀函数
命令格式
$(addprefix prefix, name..)
例子：
file = a.c b.c 
dir_file = $(addprefix src/,$(file))
在a.c b.c文件前面加入文件夹名称src/
5、filter函数
命令格式：
$(filter patern...,text)
例子：
SOURCE = foo.c foo.o foo.h main.c main.o boot.s
SOURCE :=$(filter %.c %.s,$(SOURCE) )
从SOURCE当中抽取.c .s文件
6、filter-out函数
剔除某些字符串
$(filter-out patern...,text)
例子：
SOURCE = foo.c foo.o foo.h main.c main.o boot.s
SOURCE :=$(filter %.c %.s,$(SOURCE) )
从SOURCE当中剔除.c .s文件

修复COULD NOT FIND PKGCONFIG错误
Linux可以直接apt-get即可：
sudo apt-get install pkg-config
下面详细说一下Windows如何手动安装：
转到http://ftp.gnome.org/pub/gnome/binaries/win32/dependencies/
下载文件pkg-config_0.26-1_win32.zip
将文件bin / pkg-config.exe解压缩到your_directory/mysy64/ucrt64/bin
下载文件gettext-runtime_0.18.1.1-2_win32.zip
将文件bin / intl.dll提取到your_directory/mysy64/ucrt64/bin
转到http://ftp.gnome.org/pub/gnome/binaries/win32/glib/2.28
下载文件glib_2.28.8-1_win32.zip
将文件bin / libglib-2.0-0.dll解压缩到your_directory/mysy64/ucrt64/bin
至此，问题解决，打开cmd测试一下：
 可以识别pkg-config指令
接下来说两个其他思路：
网上有一种思路是让pkg-config单独成目录，我没有尝试，但是要记得添加进Path
还有一种说法可以用choco指令安装：
choco install pkgconfiglite
这个我也没试，大家可以尝试
最后粘三个参考：
https://www.codenong.com/1710922/
https://blog.csdn.net/a1341398182/article/details/124321875
https://www.bilibili.com/video/av601004734/?vd_source=46b92c037ea112837e3a69b8d9125abb

CMake中使用PkgConfig
首先让CMake找到PkgConfig模块：

set(PKG_CONFIG_EXECUTABLE "D:/pkg-config/bin/pkg-config.exe")
find_package(PkgConfig)
然后通过PkgConfig模块找到你想要找到的第三方库，这里我找一下SDL2：
pkg_check_modules(REQUIRED SDL2 SDL2_image SDL2_ttf SDL2_mixer)
pkg_search_module(SDL2 REQUIRED sdl2)
pkg_search_module(SDL2_image REQUIRED sdl2_image)
pkg_search_module(SDL2_mixer REQUIRED sdl2_mixer)
pkg_search_module(SDL2_ttf REQUIRED sdl2_ttf)
pkg_check_modules可以一次性检查所给的所有模块是否存在。
接下来再使用pkg_search_module找到对应的模块。第一个参数是prefix，第二个参数我填了REQUIRED表示找不到就报错，第三个参数就是模块名字。
找到之后，我们可以使用如下变量来得到模块信息：
<prefix>_FOUND：如果找到模块，此变量为1
<prefix>_LIBRARIES：模块的链接库名称（不包含-l）
<prefix>_LINK_LIBRARIES：模块的链接库名称（包含绝对路径）
<prefix>_LIBRARY_DIRS：模块的链接库路径（不包含-L）
<prefix>_INCLUDE_DIRS：模块的头文件路径（不包含-I）
<prefix>_LDFLAGS：链接flags
<prefix>_LDFLAGS_OTHER：额外的链接flags
<prefix>_CFLAGS：所有的编译器cflags
<prefix>_CFLAGS_OTHER：其他的编译器cflags
这里我这样写，以让我的工程得以编译：
aux_source_directory(src SRC)
set(SRC ${SRC} main.cpp)
include_directories(include ${SDL2_INCLUDE_DIRS} ${SDL2_image_INCLUDE_DIRS} ${SDL2_mixer_INCLUDE_DIRS} ${SDL2_ttf_INCLUDE_DIRS})
link_directories(${SDL2_LIBRARY_DIRS} ${SDL2_mixer_LIBRARY_DIRS} ${SDL2_ttf_LIBRARY_DIRS} ${SDL2_image_LIBRARY_DIRS})
link_libraries(${SDL2_LIBRARIES} ${SDL2_image_LIBRARIES} ${SDL2_mixer_LIBRARIES} ${SDL2_ttf_LIBRARIES})

安装 Go Mobile
首先，确保你已经安装了 Go 语言。然后，使用以下命令安装 Go Mobile 工具：
go get golang.org/x/mobile/cmd/gomobile // go get -u -v golang.org/x/mobile/cmd/gomobile
gomobile init
创建一个简单的移动应用
以下是一个简单的示例，展示如何使用 Go Mobile 创建一个 Android 应用：
创建一个新的 Go 文件 hello.go：
package main
import (
	"golang.org/x/mobile/app"
	"golang.org/x/mobile/event/lifecycle"
	"golang.org/x/mobile/event/paint"
	"golang.org/x/mobile/gl"
)
func main() {
	app.Main(func(a app.App) {
		for e := range a.Events() {
			switch e := a.Filter(e).(type) {
			case lifecycle.Event:
				// 处理生命周期事件
			case paint.Event:
				// 处理绘制事件
				gl.ClearColor(1, 0, 0, 1)
				gl.Clear(gl.COLOR_BUFFER_BIT)
				a.Publish()
			}
		}
	})
}
使用以下命令构建 Android 应用：
gomobile build -target=android .
将生成的 APK 文件安装到 Android 设备上：
adb install hello.apk

解决golang：cannot find module providing package
这主要是由于不能找到我们某些依赖的模块。如果遇到这种问题。我们可以尝试使用go get来安装这些模块。
如果使用go get安装模块依然不能生效。返回网络错误码404或者410.很有可能是我们无法连接golang.org的GOSUBDB去验证包的有效性。
这个时候可以设置GOSUBDB为off。绕过验证
go env -w set GOSUBDB = off
同时可以设置https://goproxy.io/zh/ 的代理让我们可以正常的安装使用的包。
go env -w GO111MODULE=on
go env -w GOPROXY=https://goproxy.io,direct
# 设置不走 proxy 的私有仓库，多个用逗号相隔（可选）
go env -w GOPRIVATE=*.corp.example.com
# 设置不走 proxy 的私有组织（可选）
go env -w GOPRIVATE=example.com/org_name
# 阿里云
go env -w GOPROXY=https://mirrors.aliyun.com/goproxy/,direct
# 七牛云
go env -w GOPROXY=https://goproxy.cn,direct
# 官方代理（通常全球范围可用）
go env -w GOPROXY=https://proxy.golang.org,direct
#检查代理
go env | grep GOPROXY
#取消代理
go env -w GOPROXY=direct

gomobile 在windows电脑上android环境搭建
安装go
安装gomobile
go install golang.org/x/mobile/cmd/gomobile@latest
gomobile init
可以通过git clone下载也可以手动下载,这里我采用的是手动下载
gomobile github地址 https://github.com/golang/mobile.git
下载完成之后,把gomobile-master.zip解压到当前目录, 文件夹名字修改为mobile
在Go安装根目录下的src=>新建golang.org目录=>新建x目录 src\golang.org\x
然后将刚才的mobile文件夹拷贝当x目录下,目录结构如图所示
go/src/golang.org/x/mobile/cmd/gomobile
生成gomobile可执行程序
在bin目录下执行命令
go build golang.org/x/mobile/cmd/gomobile
执行这个命令可能为报错,提示xxx package在GOROOT或者GOPATH下都找不到,在https://github.com/golang
上找到对应的 mod、tools、xerrors，同样的下载,解压修改文件夹名字拷贝到golang.org/x目录下 重新运行即可
image.png
运行demo测试
尝试编译第一个Android apk安装包cmd命令：
gomobile build -target=android golang.org/x/mobile/example/basic
配置ndk-bundle
如若提示没有配置ANDROID_HOME或者ANDRID_NDK_HOME,配置环境变量即可
GOROOT与GOPATH环境变量 、ANDROID_HOME
image.png
重新运行cmd命令
gomobile build -target=android golang.org/x/mobile/example/basic
可以当前目录发现生成一个base.apk
image.png
gomobile install golang.org/x/mobile/example/basic
此命令将安装apk包到已连接的android设备
image.png
GOPATH
在 go1.12 之前，安装 golang 之后，需要配置两个环境变量----GOROOT 和GOPATH。前者是 go 安装后的所在的路径，后者是开发中自己配置的，用于存放go 源代码的地方。在 GOPATH 路径内，有三个文件夹，分别是
bin: go 编译后的可执行文件所在的文件夹
pkg: 编译非 main 包的中间连接文件
src: go 项目源代码
开发的程序源码则放在src里，可以在src里创建多个项目。每一个项目同时也是一个文件夹。
go1.12 之后，淡化了 GOPATH，因此也可以忽略这部分内容。
    
从源码(编译)安装golang
通常情况下，安装go只需要在官网(https://golang.org/dl/)下载适合系统的二进制发布包，按照安装说明进行安装即可。
对于Linux, Mac OS X和FreeBSD系统下的安装，三步即可完成：
1.下载tarballs文件go$VERSION.$OS-$ARCH.tar.gz，例如1.8.3
    wget https://storage.googleapis.com/golang/go1.8.3.linux-amd64.tar.gz）
2.执行tar -C /usr/local -xzf go$VERSION.$OS-$ARCH.tar.gz提取到 /usr/local
3.设置环境变量，将/usr/local/go/bin 加入到PATH环境变量。可以通过将
export PATH=$PATH:/usr/local/go/bin 添加到/etc/profile或$HOME/.profile文件的最后一行。
对于windows系统下的安装，可以下载msi安装包，安装程序自动将go发布拷贝到c:\go目录下，并且将c:\go\bin目录加入到PATH环境变量。
如果安装位置不是/usr/local/go或者c:\go目录，则需要设置GOROOT环境变量，将GOROOT/bin加入到PATH环境变量。
Go的一大特征是简单，通过下载二进制发布包安装go环境就充分体现了简单性。
某些时候，可能要使用特殊版本的go，从源码安装，这同样很简单。从源码安装，首先要进行编译。Go 1.5实现了bootstrapping，所以编译1.5以后的版本和编译1.5以前的版本会略有不同。bootstrapping是编译器领域的一个术语，中文翻译为自举或自展，通俗地讲“用要编译的目标语言编写其编译器（汇编器）”。Go1.5开始编译器和运行时完全用Go语言编写（还有少量汇编）；go1.4是最后一个用C编写工具链的发布。
编译go1.4，ubuntu 16.04.2系统：
cd ~
wget https://storage.googleapis.com/golang/go1.4-bootstrap-20170531.tar.gz
tar zxvf go1.4-bootstrap-20170531.tar.gz
cd go/src/
./all.bash
编译完成后，可以看到如下输出:
ALL TESTS PASSED
---
Installed Go for linux/amd64 in /home/dell/go
Installed commands in /home/dell/go/bin
*** You need to add /home/dell/go/bin to your PATH.
成功编译后，将~/go/bin加入到PATH环境变量
sudo gedit /etc/profile
在最后一行加入  export PATH=/home/dell/go/bin:$PATH  保存
source /etc/profile
执行go version，检查安装
dell@dell-VirtualBox:~/go/src$ go version
go version go1.4-bootstrap-20170531 linux/amd64
编译Go1.5及以上版本：
Go 1.5开始编译器和运行时用go自身编写，要编译它们，首先要安装go编译器。all.bash 编译脚本会在$GOROOT_BOOTSTRAP环境变量中查找一个已经存在的go tool chain，实际上就是要有一个编译好的bin/go程序，$GOROOT_BOOTSTRAP/bin/go应该是go二进制命令。有很多选择，可以在官网(https://golang.org/dl/)下载go发布包；也可以用go1.4源码编译，也就是按照上面的步骤编译go1.4，然后再去编译更高版本的go。
用官方下载的go1.7编译go 1.8，ubuntu 16.04.2 举例:
cd ~
wget https://storage.googleapis.com/golang/go1.7.6.linux-amd64.tar.gz
wget https://github.com/golang/go/archive/go1.8.3.tar.gz
tar zxvf go1.7.6.linux-amd64.tar.gz
tar zxvf go1.8.3.tar.gz
export GOROOT_BOOTSTRAP=/home/dell/go
cd go-go1.8.3/src
./all.bash
编译成功后，有如下输出：
##### API check
Go version is "go1.8.3", ignoring -next /home/dell/go-go1.8.3/api/next.txt
ALL TESTS PASSED
---
Installed Go for linux/amd64 in /home/dell/go-go1.8.3
Installed commands in /home/dell/go-go1.8.3/bin
*** You need to add /home/dell/go-go1.8.3/bin to your PATH.
sudo gedit /etc/profile 将export PATH=/home/dell/go-go1.8.3/bin:$PATH 加入到文件最后一行
执行go version 检查安装
dell@dell-VirtualBox:~/go-go1.8.3/src$ go version
go version go1.8.3 linux/amd64

windows 批处理脚本定时删除指定文件夹、文件
1.删除文件夹：rd /S /Q （rd /? 可以查看命令参数）
@echo off
rem 删除文件夹
set logPath=D:\tool\DelHisKLineData\log
set dateSuffix=%DATE:~0,4%%DATE:~5,2%%DATE:~8,2%
rem FCT_INDEX_2
rem sh
set klinepath=D:\Server\FCT_INDEX_2\hqservice\data\sh
rd /S /Q %klinepath%\min1kline >> %logPath%\DelHisKLine_%dateSuffix%.txt
rd /S /Q %klinepath%\min5kline >> %logPath%\DelHisKLine_%dateSuffix%.txt
rd /S /Q %klinepath%\min15kline >> %logPath%\DelHisKLine_%dateSuffix%.txt
rd /S /Q %klinepath%\min30kline >> %logPath%\DelHisKLine_%dateSuffix%.txt
rd /S /Q %klinepath%\min60kline >> %logPath%\DelHisKLine_%dateSuffix%.txt
rem sz
set klinepath=D:\Server\FCT_INDEX_2\hqservice\data\sz
rd /S /Q %klinepath%\min1kline >> %logPath%\DelHisKLine_%dateSuffix%.txt
rd /S /Q %klinepath%\min5kline >> %logPath%\DelHisKLine_%dateSuffix%.txt
rd /S /Q %klinepath%\min15kline >> %logPath%\DelHisKLine_%dateSuffix%.txt
rd /S /Q %klinepath%\min30kline >> %logPath%\DelHisKLine_%dateSuffix%.txt
rd /S /Q %klinepath%\min60kline >> %logPath%\DelHisKLine_%dateSuffix%.txt
rem 删除文件夹
rem FCT_INDEX
rem sh
set klinepath=D:\Server\FCT_INDEX\hqservice\data\sh
rd /S /Q %klinepath%\min1kline >> %logPath%\DelHisKLine_%dateSuffix%.txt
rd /S /Q %klinepath%\min5kline >> %logPath%\DelHisKLine_%dateSuffix%.txt
rd /S /Q %klinepath%\min15kline >> %logPath%\DelHisKLine_%dateSuffix%.txt
rd /S /Q %klinepath%\min30kline >> %logPath%\DelHisKLine_%dateSuffix%.txt
rd /S /Q %klinepath%\min60kline >> %logPath%\DelHisKLine_%dateSuffix%.txt
rem sz
set klinepath=D:\Server\FCT_INDEX\hqservice\data\sz
rd /S /Q %klinepath%\min1kline >> %logPath%\DelHisKLine_%dateSuffix%.txt
rd /S /Q %klinepath%\min5kline >> %logPath%\DelHisKLine_%dateSuffix%.txt
rd /S /Q %klinepath%\min15kline >> %logPath%\DelHisKLine_%dateSuffix%.txt
rd /S /Q %klinepath%\min30kline >> %logPath%\DelHisKLine_%dateSuffix%.txt
rd /S /Q %klinepath%\min60kline >> %logPath%\DelHisKLine_%dateSuffix%.txt
2.删除指定文件：del /F /S /Q
rem 删除文件
rem 查看del命令的参数:del /?
@echo off
setlocal enabledelayedexpansion
rem 变量延迟
set logPath=D:\tool\DelLog\log
set path=D:\app\taf\app_log\IndicatorSys\FormulaCalcServer
set dateSuffix=%DATE:~0,4%%DATE:~5,2%%DATE:~8,2%
for /r %path% %%i in (*.*) do (
    rem echo 完整路径: %%i
    rem echo 无后缀路径： %%~dpni
    rem echo 所在目录： %%~dpi
    rem echo 完整文件名： %%~nxi
    rem echo 不带后缀文件名： %%~ni
    rem echo 文件后缀： %%~xi
    set filename=%%~nxi
    set filetmp=%%~ni
    echo 文件日期后缀： !filetmp:~-8,8!
    set datetmp=!filetmp:~-8,8!
    if /I !datetmp! LSS %dateSuffix% (
        echo !datetmp!
        echo:
        del /F /S /Q %path%\!filename! >> %logPath%\delLog_%dateSuffix%.txt
    ) else (
        echo GEQ
        echo:
    )
)
rem 右括号和左括号要和else在同行，else两边需要有空格


//windows分割大文件
::复制到txt改成， 【zzz-文件夹分割.bat】，然后双击运行。
::D:\300 存放30万个txt的原始文件夹，就是准备进行分割成小文件夹的大文件夹目录;
::说明：将该文件放到D:\300文件夹;
::1、对D:\300文件夹文件排序;
::3、重命名该bat文件，保证排序后该bat文件是文件夹的最后一个文件;
::4、这样防止文件夹分割过程中这个文件混入原始文件中，这样就可以保证分割后该bat文
::件存在于最后一个小文件夹中。
::为了保证文件夹区分，小文件夹命名前缀是【zz+数字】
@echo off
echo "亲准备好了就按下回车键"
setlocal enabledelayedexpansion
set mydir=D:\300
set /a n+=1
md zz"!n!"
echo zz"!n!"
pause
for /f "delims=" %%i in ('dir /a-d /b %mydir%') do (
        set /a m+=1
        xcopy "%%~fi" .\zz"!n!"\
        echo "%%~fi" "<<<复制到>>>"  ".\zz"!n!"\"
        if "!m!"=="1" (    :1000表示每1000个文件存放在一个文件夹，该数字表示每个文件夹中的文件个数
        set /a n+=1,m=0
        md zz"!n!"
        echo "完成<<" "!m!" ">>个啦" 
        echo "创建" "zz!n!" "稍等3秒"
        color 0A
                for /L %%a in ( 3,-1,0) do (
                 echo ">>>>>>>>>>" %%a "秒后继续>>>>>"
                 ping -n 2 127.0.0.1 > nul
                if "%%a"=="1" color 0F
                )
        color 00
        )
)
echo "ok"
pause
::以上内容复制到txt，并重命名成【zzzz文件夹分割.bat】
//windows下合并压缩包
copy /b skia_source.tar.gz* skia_source.tar.gz
//linux分割压缩包
split 重命名 -b 分割大小 -d 原始压缩包 split skia_source.tar.gz -b 10240m -d test.tar.gz 
//linu下合并压缩包
 cat skia_source.tar.gz*>> test.tar.gz
 split -b 1G -d -a 1 原始test.tar 目标test.tar.
 -b 1G 表示设置每个分割包的大小，单位还是可以k
-d "参数指定生成的分割包后缀为数字的形式
-a x来设定序列的长度(默认值是2)，这里设定序列的长度为1
//linux下解压压缩包
tar -zxvf skia_source.tar.gz

批量修改文件后缀
ren *.jpg *.png
批量修改文件后
-----------------------------------------------------
@echo off
REM 将字符集设置为 UTF-8
chcp 65001
setlocal enabledelayedexpansion
rem 设置要查找和替换的字符串
set "search=aaa"
set "replace=bbb"
rem 设置文件名匹配模式，例如*.txt表示修改.txt文件，*.*表示修改所有文件
set "filePattern=*.txt"
rem 设置目标文件夹的路径
set "folderPath=C:\YourFolderPath"
rem 切换到目标文件夹
cd /d "%folderPath%"
rem 遍历文件并重命名
for %%f in (%filePattern%) do (
    set "filename=%%~nf"
    set "newFilename=!filename:%search%=%replace%!"
    ren "%%f" "!newFilename!%%~xf"
)
echo 文件名修改完成。
pause
-----------------------------------------------------
-----------------------------------------------------
@echo off
chcp 65001
setlocal enabledelayedexpansion
rem 获取批处理文件所在的文件夹路径
for %%I in ("%~dp0.") do set "folderPath=%%~fI"
rem 设置要查找和替换的字符串
set "search=aaa"
set "replace=bbb"
rem 设置文件名匹配模式，例如*.txt表示修改.txt文件，*.*表示修改所有文件
set "filePattern=*.txt"
rem 切换到目标文件夹
cd /d "%folderPath%"
rem 遍历文件并重命名
for %%f in (%filePattern%) do (
    set "filename=%%~nf"
    set "newFilename=!filename:%search%=%replace%!"
    ren "%%f" "!newFilename!%%~xf"
)
echo 文件名修改完成。
pause
-----------------------------------------------------

#、##和__VA_ARGS__
1.#
假如希望在字符串中包含宏参数，ANSI C允许这样做，在类函数宏的替换部分，#符号用作一个预处理运算符，它可以把语言符号转化成字符串。例如，如果x是一个宏参量，那么#x可以把参数名转化成相应的字符串。该过程称为字符串化（stringizing）.
#incldue <stdio.h>
#define PSQR(x) printf("the square of" #x "is %d.\n",(x)*(x))
int main(void)
{
    int y =4;
    PSQR(y);
    PSQR(2+4);
    return 0;
}
输出结果：
the square of y is 16.
the square of 2+4 is 36.
第一次调用宏时使用"y"代替#x；第二次调用时用"2+4"代#x。
2.##
##运算符可以用于类函数宏的替换部分。另外，##还可以用于类对象宏的替换部分。这个运算符把两个语言符号组合成单个语言符号。例如：#define XNAME(n) x##n
这样宏调用：
XNAME(4)
展开后：
x4
程序：
#include <stdio.h>
#define XNAME(n) x##n
#define PXN(n) printf("x"#n" = %d\n",x##n)
int main(void)
{
    int XNAME(1)=12;//int x1=12;
    PXN(1);//printf("x1 = %d\n", x1);
    return 0;
}
输出结果：x1=12
关于#和##补充一点，来自《C语言高级编程》
当宏参数是另一个宏的时候
需要注意的是凡宏定义里有用'#'或'##'的地方宏参数是不会再展开.
1, 非'#'和'##'的情况
#define TOW(2)
#define MUL(a,b) (a*b)
printf("%d*%d=%d\n", TOW, TOW, MUL(TOW,TOW));
这行的宏会被展开为：
printf("%d*%d=%d\n", (2), (2), ((2)*(2)));
MUL里的参数TOW会被展开为(2).
2, 当有'#'或'##'的时候
#define A(2)
#define CONS(a,b)int(a##e##b)
这行会被展开为：
printf(“%s\n”, CONS(A, A));// compile error
这一行则是：printf("%s\n", int(AeA));
INT_MAX和A都不会再被展开, 然而解决这个问题的方法很简单. 加多一层中间转换宏. 加这层宏的用意是把所有宏的参数在这层里全部展开, 那么在转换宏里的那一个宏(_STR)就能得到正确的宏参数.
#define A(2)
#define _CONS(a,b)int(a##e##b)
#define CONS(a,b)_CONS(a,b)// 转换宏
printf("%d\n", CONS(A, A));
输出为：200
CONS(A, A)-->_CONS((2), (2))--> int((2)e(2))
3.可变参数宏 ...和__VA_ARGS__
__VA_ARGS__ 是一个可变参数的宏，很少人知道这个宏，这个可变参数的宏是新的C99规范中新增的，目前似乎只有gcc支持（VC6.0的编译器不支持）(我用的vc2008也可以)。
实现思想就是宏定义中参数列表的最后一个参数为省略号（也就是三个点）。这样预定义宏__VA_ARGS__就可以被用在替换部分中，替换省略号所代表的字符串。比如：
#define PR(...) printf(__VA_ARGS__)
int main()
{
    int wt=1,sp=2;
    PR("hello\n");
    PR("weight = %d, shipping = %d",wt,sp);
    return 0;
}
(我的注释：__VA_ARGS__这个宏的头尾是两个下划线，包括后面提到的另外的一些编译器内置宏，不要搞错了哦。)
输出结果：
hello
weight = 1, shipping = 2
省略号只能代替最后面的宏参数。
#define W(x,...,y)错误！
(可变宏的另外一个在调试过程中很给力的用途，这篇文章里有个例子：http://blog.csdn.net/hinyunsin/article/details/6546670，现在整理如下，感谢原作者！)
编译器内置宏：
先介绍几个编译器内置的宏定义，这些宏定义不仅可以帮助我们完成跨平台的源码编写，灵活使用也可以巧妙地帮我们输出非常有用的调试信息。
ANSI C标准中有几个标准预定义宏（也是常用的）：
__LINE__：在源代码中插入当前源代码行号；
__FILE__：在源文件中插入当前源文件名；
__DATE__：在源文件中插入当前的编译日期
__TIME__：在源文件中插入当前编译时间；
__STDC__：当要求程序严格遵循ANSI C标准时该标识被赋值为1；
__cplusplus：当编写C++程序时该标识符被定义。
编译器在进行源码编译的时候，会自动将这些宏替换为相应内容。
看到这里，你的眼睛应该一亮了吧，嗯，是的，__FILE__和__LINE__正是我们前面想要的输出的，于是，我们的每一条语句都变成了：
DEBUG("FILE: %s, LINE: %d…",__FILE__,__LINE__,…)
其实没有必要，__FILE__本身就会被编译器置换为字符常量，于是乎我们的语句又变成了这样：
DEBUG("FILE:"__FILE__", LINE: %d…",__LINE__,…)
但是，我们还是不满足，依然发现，还是很讨厌，为什么每条语句都要写"FILE:"__FILE__", LINE: %d 以及,__LINE,这两个部分呢？这不是浪费我们时间么？
哈哈，是的，这就是本次大结局，把DEBUG写成这样：
DEBUG(format,...) printf("FILE: "__FILE__", LINE: %d: "format"/n", __LINE__, ##__VA_ARGS__)
没错，就是这样！下面，所有的DEBUG信息都会按照这样的方式输出：
FILE: xxx, LINE: xxx, …….
最后，老规矩，coding测试。
#include <stdio.h>
#define __DEBUG__
#ifdef __DEBUG__
#define DEBUG(format,...) printf("File: "__FILE__", Line: %05d: "format"\n", __LINE__, ##__VA_ARGS__)
#else
#define DEBUG(format,...)
#endif
int main(int argc, char **argv) {
    char str[]="Hello World";
    DEBUG("A ha, check me: %s",str);
    return 0;
}
输出结果：
(关于上面的DEBUG宏里面的__FILE__,__LINE__，我本以为可以这样改：
#define DEBUG(format,...) printf("File: "__FILE__", Line: "__LINE__", "format"\n", ##__VA_ARGS__)
即让编译器自动置换__LINE__宏，但是编译错误，我想可能是编译器不会像__FILE__宏一样，自己主动置换这个宏,而是需要你去格式化输出，所以这样也许会报错：
printf("File: "__FILE__", Line: "__LINE__"\n");
果然报错：error C2064: 项不会计算为接受 1 个参数的函数。所以用的时候还是老老实实按照格式化输出的形式写吧，呵呵，这个小问题在这里备注一下。
另外代码中的这种形式：#define CCLOG(format, ...)      cocos2d::CCLog(format, ##__VA_ARGS__)，' ## '的意思是，如果可变参数被忽略或为空，将使预处理器（ preprocessor ）去除掉它前面的那个逗号
关于#和##，还可以看看这篇博客：http://www.cnblogs.com/morewindows/archive/2011/08/18/2144112.html，讲的比较详细)
4 计算结构体中成员变量的偏移
#define offset(s,m) (size_t)&(((s*)0)->m)
二：C++中有用的一些宏定义
1,命名空间使用的宏定义
最近在看cocos2d-x的代码，有些地方写的很有意思(我自己以前代码写的很少，可能少见多怪了)，所以记录下来。其实这也不算技巧了，对于做事讲究省布料的人，可以这么做：
#define NS_CC_BEGIN                     namespace cocos2d {
#define NS_CC_END                       }
#define USING_NS_CC                     using namespace cocos2d
用的时候，可以这样写：
/****custom head file***/
//**.h
NS_CC_BEGIN
//add your code here
NS_CC_END
//**.cpp
#include "**.h"
USING_NS_CC;
//add your code here
2，成员变量和函数的定义
#define CC_PROPERTY_READONLY(varType, varName, funName)\
protected: varType varName;\
public: virtual varType get##funName(void);
#define CC_PROPERTY_READONLY_PASS_BY_REF(varType, varName, funName)\
protected: varType varName;\
public: virtual const varType& get##funName(void);
再看一个：
#define CC_PROPERTY(varType, varName, funName)\
protected: varType varName;\
public: virtual varType get##funName(void);\
public: virtual void set##funName(varType var);
#define CC_PROPERTY_PASS_BY_REF(varType, varName, funName)\
protected: varType varName;\
public: virtual const varType& get##funName(void);\
public: virtual void set##funName(const varType& var);
这样的宏定义是不是很奇葩？但很好懂，而且比较节省体力，方便为类声明一些成员，同时提供外部读或写接口。写在这里借鉴下。

三：常用宏
这个也是来自cocos2d-x的代码，在头文件"CCPlatformMacros.h"中。
#define CC_SAFE_DELETE(p)            if(p) { delete (p); (p) = 0; }
#define CC_SAFE_DELETE_ARRAY(p)    if(p) { delete[] (p); (p) = 0; }
#define CC_SAFE_FREE(p)            if(p) { free(p); (p) = 0; }
#define CC_SAFE_RELEASE(p)            if(p) { (p)->release(); }
#define CC_SAFE_RELEASE_NULL(p)    if(p) { (p)->release(); (p) = 0; }
#define CC_SAFE_RETAIN(p)            if(p) { (p)->retain(); }
#define CC_BREAK_IF(cond)            if(cond) break;
总结：宏这个玩意是把双刃剑，因为编译器不会提供类型安全检查，只是进行替换，所以很容易将一些错误隐藏起来，总之，要在能把控的情况下玩弄，否则磨刀出鞘，会嗜血的！

Linux网络配置
重置网络
service network-manager stop 
rm /var/lib/NetworkManager/NetworkManager.state 
service network-manager start
配置网络
ifconfig -a //查看所有网卡信息
ifconfig eth0 192.168.1.11 netmask 255.255.255.0  //配置ip地址 和 子网掩码
route add default gw 192.168.1.1  //设置网关
紧急模式恢复root密码
内核上按↑↓键，选择第一项按下 e键，然后编辑选项
按↑↓键找到ro，将ro改成 ：rw init=/sysroot/bin/sh
改完之后，按下 Ctrl+X 进入紧急求援模式，依次输入以下的命令
chroot /sysroot   //进入系统的根目录
passwd            //重置密码
touch /.autorelabel     //创建文件,让系统重新启动时能够识别修改
exit              //退出chroot模式
reboot            //重启系统

------C语言中写文件------
//获取文件指针
FILE *pFile = fopen("1.txt", //打开文件的名称
                    "w"); // 文件打开方式 如果原来有内容也会销毁
//向文件写数据
fwrite ("hello", //要输入的文字
         1,//文字每一项的大小 以为这里是字符型的 就设置为1 如果是汉字就设置为4
         strlog("hello"), //单元个数 我们也可以直接写5
         pFile //我们刚刚获得到的地址
         );
//fclose(pFile); //告诉系统我们文件写完了数据更新，但是我们要要重新打开才能在写
fflush(pFile); //数据刷新 数据立即更新
------C语言中读文件------
FILE *pFile=fopen("1.txt","r"); //获取文件的指针
char *pBuf;  //定义文件指针
fseek(pFile,0,SEEK_END); //把指针移动到文件的结尾 ，获取文件长度
int len=ftell(pFile); //获取文件长度
pBuf=new char[len+1]; //定义数组长度
rewind(pFile); //把指针移动到文件开头 因为我们一开始把指针移动到结尾，如果不移动回来 会出错
fread(pBuf,1,len,pFile); //读文件
pBuf[len]=0; //把读到的文件最后一位 写为0 要不然系统会一直寻找到0后才结束
MessageBox(pBuf);  //显示读到的数据
fclose(pFile); // 关闭文件

make步骤编译SDL_windows_gaming_input.c，报错信息如下：
make: *** [makefile:730: build/sdl_windows_gaming_input.lo] error 1
需要修改下 SDL_windows_gaming_input.c（$MSYS2/home/source/SDL2-2.0.18/src/joystick/windows）文件，增加新的宏（此处是参考SDL issue解决，路径贴在末尾）。修改内容如下：
//增加宏
#ifdef __MINGW32__
#define __FIReference_1_int __FIReference_1_INT32
#define __FIReference_1_int_get_Value __FIReference_1_INT32_get_Value
#define __FIReference_1_int_Release __FIReference_1_INT32_Release
#endif
//源代码
struct joystick_hwdata
{
    __x_ABI_CWindows_CGaming_CInput_CIRawGameController *controller;
    __x_ABI_CWindows_CGaming_CInput_CIGameController *gamecontroller;
    __x_ABI_CWindows_CGaming_CInput_CIGameControllerBatteryInfo *battery;
    __x_ABI_CWindows_CGaming_CInput_CIGamepad *gamepad;
    __x_ABI_CWindows_CGaming_CInput_CGamepadVibration vibration;
    UINT64 timestamp;
};

TeamTalk部署详细教程（最全最新TeamTalk部署教程助你一次部署成功）
TeamTalk是一款蘑菇街开源的企业内部即时通讯软件，目前支持pc、安卓、IOS、Mac和web多个终端。这是各个版本的代码和部署脚本。
最近在部署TeamTalk服务端的过程中，绕了很多弯路。尝试过使用官网提供的默认的一件配置，尝试过所谓的TeamTalk安装部署手册，后面遇到了各种各样的问题导致部署失败。
现在将最后实践有效的部署过程，结合网友的资料，在此记录与分享一下。
文章中已经替换了原文中已经失效的源，修改了之前网友整理该文档时的一些命令的排版问题，同时修改了部署过程中遇到的一些其他问题。
文章的核心内容来源于http://www.bluefoxah.org/teamtalk/new_tt_deploy.html（由于打不开该文档，所以只能参考别人转发的文章，在此还是贴出原文地址，以表感谢）
安装环境：腾讯云服务器 1核 2GB 1Mbps
操作系统：centos7.8
源码下载：https://github.com/mogujie/TeamTalk
1、更新操作系统
更新操作系统:
CentOS 使用如下命令: yum update
Ubuntu 使用如下命令: apt-get update
2、删除已经安装的软件
为了减少一些不必要的麻烦，我们需要先卸载系统自带的一些软件，譬如mysql，nginx，php，执行以下命令:
CentOS 执行如下命令: yum -y remove httpd* php* mysql-server mysql mysql-libs php-mysql
Ubuntu 使用如下命令: apt-get remove -y apache2 apache2-doc apache2-utils apache2.2-common apache2.2-bin apache2-mpm-prefork apache2-doc apache2-mpm-worker mysql-client mysql-server mysql-common php5 php5-common php5-cgi php5-mysql php5-curl php5-gdkillall apache2dpkg -l |grep mysqldpkg -P libmysqlclient15off libmysqlclient15-dev mysql-commondpkg -l |grep apachedpkg -P apache2 apache2-doc apache2-mpm-prefork apache2-utils apache2.2-commondpkg -l |grep phpdpkg -P php5 php5-common php5-cgi php5-mysql php5-curl php5-gdapt-get purge `dpkg -l | grep php| awk '{print $2}'`
3、安装必要的依赖软件
如果CentOS是最小化安装，系统中很多软件是没有安装的，需要进行手动安装。
执行如下命令安装一些依赖软件:
CentOS 使用如下命令: yum -y install wget vim git texinfo patch make cmake gcc gcc-c++ gcc-g77 flex bison file libtool libtool-libs autoconf kernel-devel libjpeg libjpeg-devel libpng libpng-devel libpng10 libpng10-devel gd gd-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel glib2 glib2-devel bzip2 bzip2-devel libevent libevent-devel ncurses ncurses-devel curl curl-devel e2fsprogs e2fsprogs-devel krb5 krb5-devel libidn libidn-devel openssl openssl-devel vim-minimal nano fonts-chinese gettext gettext-devel ncurses-devel gmp-devel pspell-devel unzip libcap diffutils
ubuntu 使用如下命令: apt-get autoremove -yapt-get -fy installapt-get install -y build-essential gcc g++ makeapt-get install -y --force-yes wget vim git texinfo patch build-essential gcc g++ make cmake automake autoconf re2c wget cron bzip2 libzip-dev libc6-dev file rcconf flex vim nano bison m4 gawk less make cpp binutils diffutils unzip tar bzip2 libbz2-dev unrar p7zip libncurses5-dev libncurses5 libncurses5-dev libncurses5-dev libtool libevent-dev libpcre3 libpcre3-dev libpcrecpp0  libssl-dev zlibc openssl libsasl2-dev libltdl3-dev libltdl-dev libmcrypt-dev zlib1g zlib1g-dev libbz2-1.0 libbz2-dev libglib2.0-0 libglib2.0-dev libpng3 libjpeg62 libjpeg62-dev libjpeg-dev libpng-dev libpng12-0 libpng12-dev curl libcurl3 libmhash2 libmhash-dev libpq-dev libpq5 gettext libncurses5-dev libcurl4-gnutls-dev libjpeg-dev libpng12-dev libxml2-dev zlib1g-dev libfreetype6 libfreetype6-dev libssl-dev libcurl3 libcurl4-openssl-dev libcurl4-gnutls-dev mcrypt libcap-dev diffutils ca-certificates debian-keyring debian-archive-keyring;apt-get -fy installapt-get -y autoremove
4、安装mysql
4.1 下载
wget http://mirrors.sohu.com/mysql/MySQL-5.6/mysql-5.6.45.tar.gz
4.2 解压编译
执行如下命令:
tar -zxvf mysql-5.6.45.tar.gz 
cd mysql-5.6.45 
cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DEXTRA_CHARSETS=all -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci -DWITH_READLINE=1 -DWITH_SSL=system -DWITH_ZLIB=system -DWITH_EMBEDDED_SERVER=1 -DENABLED_LOCAL_INFILE=1
make -j 2 && make install
编译将是一个漫长得过程。。。不同的机器性能等待时间不同。
make的-j参数可以使make进行并行编译编译。cpu的个数是2，所以指定为2.
4.3 添加mysql用户
groupadd mysql
useradd -s /sbin/nologin -M -g mysql mysql
4.4 修改配置文件
vim /etc/my.cnf
下面给出一份参考配置(只是测试用，如果要用于生产环境，请根据需求自行调配):
# Example MySQL config file for medium systems.
# The following options will be passed to all MySQL clients
[client]
#password   = your_password
port        = 3306
socket      = /tmp/mysql.sock
default-character-set=utf8mb4
# Here follows entries for some specific programs
# The MySQL server
[mysqld]
bind-address=127.0.0.1
port        = 3306
socket      = /tmp/mysql.sock
datadir = /usr/local/mysql/var
collation-server     = utf8mb4_general_ci
character-set-server = utf8mb4
skip-external-locking
key_buffer_size = 16M
max_allowed_packet = 1M
table_open_cache = 64
sort_buffer_size = 512K
net_buffer_length = 8K
read_buffer_size = 256K
read_rnd_buffer_size = 512K
myisam_sort_buffer_size = 8M
# Replication Master Server (default)
# binary logging is required for replication
log-bin=mysql-bin
# binary logging format - mixed recommended
binlog_format=mixed
# required unique id between 1 and 2^32 - 1
# defaults to 1 if master-host is not set
# but will not function as a master if omittedserver-id   = 1
# Uncomment the following if you are using InnoDB tablesinnodb_data_home_dir = /usr/local/mysql/varinnodb_data_file_path = ibdata1:10M:autoextendinnodb_log_group_home_dir = /usr/local/mysql/var
# You can set .._buffer_pool_size up to 50 - 80 %
# of RAM but beware of setting memory usage too highinnodb_buffer_pool_size = 16Minnodb_additional_mem_pool_size = 2M
# Set .._log_file_size to 25 % of buffer pool sizeinnodb_log_file_size = 5Minnodb_log_buffer_size = 8Minnodb_flush_log_at_trx_commit = 1
innodb_lock_wait_timeout = 50
[mysqldump]
quickmax_allowed_packet = 16M
[mysql]
no-auto-rehash
# Remove the next comment character if you are not familiar with SQL
#safe-updatesdefault-character-set=utf8mb4
[myisamchk]
key_buffer_size = 20Ms
ort_buffer_size = 20M
read_buffer = 2M
write_buffer = 2M
[mysqlhotcopy]
interactive-timeout
4.5 初始化mysql
/usr/local/mysql/scripts/mysql_install_db --defaults-file=/etc/my.cnf --basedir=/usr/local/mysql --datadir=/usr/local/mysql/var --user=mysql
chown -R mysql /usr/local/mysql/var
chgrp -R mysql /usr/local/mysql/.
cp support-files/mysql.server /etc/init.d/mysql
chmod 755 /etc/init.d/mysql

vim /etc/ld.so.conf.d/mysql.conf
在该文件中输入如下内容：
/usr/local/mysql/lib
/usr/local/lib
ldconfig
4.6 启动mysql
/etc/init.d/mysql start
4.7 查看到mysql进程，安装成功
ps -ef|grep mysql
4.8 后期配置
ln -s /usr/local/mysql/lib/mysql /usr/lib/mysql
ln -s /usr/local/mysql/include/mysql /usr/include/mysql
ln -s /usr/local/mysql/bin/mysql /usr/bin/mysql
ln -s /usr/local/mysql/bin/mysqldump /usr/bin/mysqldump
ln -s /usr/local/mysql/bin/myisamchk /usr/bin/myisamchk
ln -s /usr/local/mysql/bin/mysqld_safe /usr/bin/mysqld_safe
登陆mysql:
mysql -uroot -p
修改密码(假定密码为:test123，这里根据需要自己设置，但是后面还会用到这个密码，自己记一下):
下面指令中的mysqlrootpwd改为自己的密码再执行。
use mysql;
update user set password=password('$mysqlrootpwd') where user='root';
flush privileges;
退出，重新登陆:
mysql -uroot -p
4.9 结束
至此，mysql 已经安装结束。退出到上一层目录
cd ../
5、安装PHP
本次安装的PHP是php 5.3.28，选择从搜狐源下载。
5.1 下载PHP
wget http://mirrors.sohu.com/php/php-5.3.28.tar.gz
5.2 安装依赖
5.2.1 libiconv
wget http://ftp.gnu.org/pub/gnu/libiconv/libiconv-1.14.tar.gz
tar -zxvf libiconv-1.14.tar.gz
cd libiconv-1.14
./configure
make -j 2&& make install
cd ..
5.2.2 libmcrypt
wget https://sourceforge.net/projects/mcrypt/files/Libmcrypt/2.5.8/libmcrypt-2.5.8.tar.gz
tar zxvf libmcrypt-2.5.8.tar.gz
cd libmcrypt-2.5.8/
./configure
make
make install
/sbin/ldconfig
cd libltdl/
./configure --enable-ltdl-install
make
make install
cd ../../
5.2.3 mhash
wget https://sourceforge.net/projects/mhash/files/latest/download/mhash-0.9.9.9.tar.gz
tar -zxvf mhash-0.9.9.9.tar.gz
cd mhash-0.9.9.9
./configure
make -j 2 && make install
cd ../
5.3 解压编译
tar -zxvf php-5.3.28.tar.gz
cd php-5.3.28
./configure --prefix=/usr/local/php --with-config-file-path=/usr/local/php/etc --enable-fpm --with-fpm-user=www --with-fpm-group=www --with-mysql=mysqlnd --with-mysqli=mysqlnd --with-pdo-mysql=mysqlnd --with-iconv-dir --with-freetype-dir --with-jpeg-dir --with-png-dir --with-zlib --with-libxml-dir=/usr --enable-xml --disable-rpath --enable-magic-quotes --enable-safe-mode --enable-bcmath --enable-shmop --enable-sysvsem --enable-inline-optimization --with-curl --enable-mbregex --enable-mbstring --with-mcrypt --enable-ftp --with-gd --enable-gd-native-ttf --with-openssl --with-mhash --enable-pcntl --enable-sockets --with-xmlrpc --enable-zip --enable-soap --without-pear --with-gettext --disable-fileinfo
make -j 2 ZEND_EXTRA_LIBS='-liconv' && make install
5.4 配置php
cp php.ini-production /usr/local/php/etc/php.ini
sed -i 's/post_max_size = 8M/post_max_size = 50M/g' /usr/local/php/etc/php.ini
sed -i 's/upload_max_filesize = 2M/upload_max_filesize = 50M/g' /usr/local/php/etc/php.ini
sed -i 's/;date.timezone =/date.timezone = PRC/g' /usr/local/php/etc/php.ini
sed -i 's/short_open_tag = Off/short_open_tag = On/g' /usr/local/php/etc/php.ini
sed -i 's/; cgi.fix_pathinfo=1/cgi.fix_pathinfo=0/g' /usr/local/php/etc/php.ini
sed -i 's/; cgi.fix_pathinfo=0/cgi.fix_pathinfo=0/g' /usr/local/php/etc/php.ini
sed -i 's/;cgi.fix_pathinfo=1/cgi.fix_pathinfo=0/g' /usr/local/php/etc/php.ini
sed -i 's/max_execution_time = 30/max_execution_time = 300/g' /usr/local/php/etc/php.ini
sed -i 's/register_long_arrays = On/;register_long_arrays = On/g' /usr/local/php/etc/php.ini
sed -i 's/magic_quotes_gpc = On/;magic_quotes_gpc = On/g' /usr/local/php/etc/php.ini
sed -i 's/disable_functions =.*/disable_functions = passthru,exec,system,chroot,scandir,chgrp,chown,shell_exec,proc_open,proc_get_status,ini_alter,ini_restore,dl,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server/g' /usr/local/php/etc/php.ini
5.5 后期配置
ln -s /usr/local/php/bin/php /usr/bin/php
ln -s /usr/local/php/bin/phpize /usr/bin/phpize
ln -s /usr/local/php/sbin/php-fpm /usr/bin/php-fpm
cd ..
5.6 安装ZendGuardLoader
mkdir -p /usr/local/zend/
wget http://downloads.zend.com/guard/5.5.0/ZendGuardLoader-php-5.3-linux-glibc23-x86_64.tar.gz
tar -zxvf ZendGuardLoader-php-5.3-linux-glibc23-x86_64.tar.gz
cp ZendGuardLoader-php-5.3-linux-glibc23-x86_64/php-5.3.x/ZendGuardLoader.so /usr/local/zend/

vi  /usr/local/php/etc/php.ini
;eaccelerator;ionCube[Zend Optimizer]
zend_extension=/usr/local/zend/ZendGuardLoader.so
zend_loader.enable=1
zend_loader.disable_licensing=0
zend_loader.obfuscation_level_support=3
zend_loader.license_path=
EOF

5.7 修改php-fpm配置文件
vim /usr/local/php/etc/php-fpm.conf
[global]
pid = /usr/local/php/var/run/php-fpm.pid
error_log = /usr/local/php/var/log/php-fpm.log
log_level = notice

[www]
listen = /tmp/php-cgi.sock
listen.backlog = -1
listen.allowed_clients = 127.0.0.1
listen.owner = www
listen.group = www
listen.mode = 0666user = www
group = www
pm = dynamic
pm.max_children = 10
pm.start_servers = 2
pm.min_spare_servers = 1
pm.max_spare_servers = 6
request_terminate_timeout = 100
request_slowlog_timeout = 0
slowlog = var/log/slow.log
5.8 创建php-fpm启动脚本
vim /etc/init.d/php-fpm
chmod +x /etc/init.d/php-fpm
以下是一份参考:
#! /bin/sh
### BEGIN INIT INFO
# Provides:          php-fpm
# Required-Start:    $remote_fs $network
# Required-Stop:     $remote_fs $network
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: starts php-fpm
# Description:       starts the PHP FastCGI Process Manager daemon
### END INIT INFO
prefix=/usr/local/php
exec_prefix=${prefix}
php_fpm_BIN=${exec_prefix}/sbin/php-fpm
php_fpm_CONF=${prefix}/etc/php-fpm.conf
php_fpm_PID=${prefix}/var/run/php-fpm.pid
php_opts="--fpm-config $php_fpm_CONF --pid $php_fpm_PID"
wait_for_pid () {
        try=0
        while test $try -lt 35 ; do
                case "$1" in
                        'created')
                        if [ -f "$2" ] ; then
                                try=''
                                break
                        fi
                        ;;
                        'removed')
                        if [ ! -f "$2" ] ; then
                                try=''
                                break
                        fi
                        ;;
                esac
                echo -n .
                try=`expr $try + 1`
                sleep 1
        done
}
case "$1" in
        start)
                echo -n "Starting php-fpm "
                $php_fpm_BIN --daemonize $php_opts
                if [ "$?" != 0 ] ; then
                        echo " failed"
                        exit 1
                fi
                wait_for_pid created $php_fpm_PID

                if [ -n "$try" ] ; then
                        echo " failed"
                        exit 1
                else
                        echo " done"
                fi
        ;;
        stop)
                echo -n "Gracefully shutting down php-fpm "

                if [ ! -r $php_fpm_PID ] ; then
                        echo "warning, no pid file found - php-fpm is not running ?"
                        exit 1
                fi
                kill -QUIT `cat $php_fpm_PID`
                wait_for_pid removed $php_fpm_PID
                if [ -n "$try" ] ; then
                        echo " failed. Use force-quit"
                        exit 1
                else
                        echo " done"
                fi
        ;;
        force-quit)
                echo -n "Terminating php-fpm "
                if [ ! -r $php_fpm_PID ] ; then
                        echo "warning, no pid file found - php-fpm is not running ?"
                        exit 1
                fi
                kill -TERM `cat $php_fpm_PID`
                wait_for_pid removed $php_fpm_PID
                if [ -n "$try" ] ; then
                        echo " failed"
                        exit 1
                else
                        echo " done"
                fi
        ;;
        restart)
                $0 stop
                $0 start
        ;;
        reload)
                echo -n "Reload service php-fpm "
                if [ ! -r $php_fpm_PID ] ; then
                        echo "warning, no pid file found - php-fpm is not running ?"
                        exit 1
                fi
                kill -USR2 `cat $php_fpm_PID`
                echo " done"
        ;;
        *)
                echo "Usage: $0 {start|stop|force-quit|restart|reload}"
                exit 1
        ;;
esac

5.9 启动php-fpm
groupadd www
useradd -s /sbin/nologin -g www www
/etc/init.d/php-fpm start
6、 安装nginx
6.1 下载nginx
wget http://mirrors.sohu.com/nginx/nginx-1.6.0.tar.gz
6.2 安装依赖
6.2.1 pcre
wget https://sourceforge.net/projects/pcre/files/pcre/8.39/pcre-8.39.tar.bz2
tar -jxvf pcre-8.39.tar.bz2
cd pcre-8.39
./configure
make -j 2 && make install 
cd ..
6.3 解压编译nginx
tar -zxvf nginx-1.6.0.tar.gz
cd nginx-1.6.0./configure --user=www --group=www --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module --with-ipv6
make -j 2 && make install
cd ..
ln -s /usr/local/nginx/sbin/nginx /usr/bin/nginx
6.4 配置nginx
/usr/local/nginx/conf/nginx.conf
user  www www;
worker_processes auto;
error_log  /home/wwwlogs/nginx_error.log  crit;
pid        /usr/local/nginx/logs/nginx.pid;
#Specifies the value for maximum file descriptors that can be opened by this process.
worker_rlimit_nofile 51200;
events
    {
        use epoll;
        worker_connections 51200;
        multi_accept on;
    }
http
    {
        include       mime.types;
        default_type  application/octet-stream;
        server_names_hash_bucket_size 128;
        client_header_buffer_size 32k;
        large_client_header_buffers 4 32k;
        client_max_body_size 50m;
        sendfile on;
        tcp_nopush     on;
        keepalive_timeout 60;
        tcp_nodelay on;
        fastcgi_connect_timeout 300;
        fastcgi_send_timeout 300;
        fastcgi_read_timeout 300;
        fastcgi_buffer_size 64k;
        fastcgi_buffers 4 64k;
        fastcgi_busy_buffers_size 128k;
        fastcgi_temp_file_write_size 256k;
        gzip on;
        gzip_min_length  1k;
        gzip_buffers     4 16k;
        gzip_http_version 1.0;
        gzip_comp_level 2;
        gzip_types       text/plain application/x-javascript text/css application/xml;
        gzip_vary on;
        gzip_proxied        expired no-cache no-store private auth;
        gzip_disable        "MSIE [1-6]\.";
        server_tokens off;
        #log_format  access  '$remote_addr - $remote_user [$time_local] "$request" ''$status $body_bytes_sent "$http_referer" ''"$http_user_agent" $http_x_forwarded_for';
        log_format  access  '$remote_addr - $remote_user [$time_local] "$request" '
             '$status $body_bytes_sent "$http_referer" '
             '"$http_user_agent" $http_x_forwarded_for "$upstream_addr" "$upstream_response_time" $request_time $content_length';
    server
    {
            listen       80;
            server_name localhost;
            index index.html index.htm index.php default.html default.htm default.php;
            root        /home/wwwroot/default;
            location ~ \.php($|/) {
                fastcgi_pass   unix:/tmp/php-cgi.sock;
                fastcgi_index  index.php;
                fastcgi_split_path_info ^(.+\.php)(.*)$;
                fastcgi_param   PATH_INFO $fastcgi_path_info;
                fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
                include        fastcgi_params;
            }
            location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$
                    {
                            expires      30d;
                    }
            location ~ .*\.(js|css)?$
                    {
                            expires      12h;
                    }
            if (!-e $request_filename) {
                rewrite ^/(.*)$ /index.php/$1 last;
                break;
            }
    }
}
6.5 后期配置
mkdir -p /home/wwwroot/default
chmod +w /home/wwwroot/default
mkdir -p /home/wwwlogs
chmod 777 /home/wwwlogs
chown -R www:www /home/wwwroot/default
6.6 编写nginx启动脚本
vim /etc/init.d/nginx
chmod +x /etc/init.d/nginx
下面是一份参考配置:
#!/bin/sh
# chkconfig: 2345 55 25
# Description: Startup script for nginx webserver on Debian. Place in /etc/init.d and
# run 'update-rc.d -f nginx defaults', or use the appropriate command on your
# distro. For CentOS/Redhat run: 'chkconfig --add nginx'
### BEGIN INIT INFO# Provides:          nginx
# Required-Start:    $all
# Required-Stop:     $all
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: starts the nginx web server# Description:       starts nginx using start-stop-daemon
### END INIT INFO
# Author:   licess
# website:  http://lnmp.org
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
NAME=nginx
NGINX_BIN=/usr/local/nginx/sbin/$NAME
CONFIGFILE=/usr/local/nginx/conf/$NAME.conf
PIDFILE=/usr/local/nginx/logs/$NAME.pid
SCRIPTNAME=/etc/init.d/$NAME
case "$1" in
    start)
        echo -n "Starting $NAME... "
        if netstat -tnpl | grep -q nginx;
        then
        echo "$NAME (pid `pidof $NAME`) already running."
        exit 1
        fi
        $NGINX_BIN -c $CONFIGFILE
        if [ "$?" != 0 ] ; 
        then
        echo " failed"
        exit 1
        else
        echo " done"
        fi
    ;;
    stop)
        echo -n "Stoping $NAME... "
        if ! netstat -tnpl | grep -q nginx; 
        then
        echo "$NAME is not running."
        exit 1
        fi
        $NGINX_BIN -s stop
        if [ "$?" != 0 ] ; then
        echo " failed. Use force-quit"
        exit 1
        else
    echo " done"
        fi
    ;;
    status)
        if netstat -tnpl | grep -q nginx; then
            PID=`pidof nginx`
            echo "$NAME (pid $PID) is running..."
            else
            echo "$NAME is stopped"
            exit 0
            fi
    ;;
    force-quit)
        echo -n "Terminating $NAME... "
        if ! netstat -tnpl | grep -q nginx; 
        then
        echo "$NAME is not running."
        exit 1
        fi
        kill `pidof $NAME`
        if [ "$?" != 0 ] ; 
        then
        echo " failed"
        xit 1
        else
        echo " done"
        fi
    ;;
    restart)
        $SCRIPTNAME stop
        sleep 1$SCRIPTNAME start
    ;;
    reload)
        echo -n "Reload service $NAME... "
        if netstat -tnpl | grep -q nginx; 
        then $NGINX_BIN -s reload
            echo " done"elseecho "$NAME is not running, can't reload."
            exit 1
            fi
    ;;
    configtest)
        echo -n "Test $NAME configure files... "$NGINX_BIN -t
    ;;

    *)
        echo "Usage: $SCRIPTNAME {start|stop|force-quit|restart|reload|status|configtest}"
        exit 1
    ;;
esac
6.6 测试nginx
6.6.1 写php测试代码
cat >/home/wwwroot/default/index.php<<EOF
<?
phpinfo();
?>
EOF
6.6.2启动nginx
/etc/init.d/nginx startps -ef|grep nginx
如果你开启了selinux，请关闭，否则访问不了:
sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/selinux/config
临时关闭selinux:
setenforce 0
关闭防火墙:
service iptables stop
6.6.3 设置开机启动
chkconfig --level 345 php-fpm on
chkconfig --level 345 nginx on
chkconfig --level 345 mysql on
7、 安装redis
7.1 下载redis
wget http://download.redis.io/releases/redis-2.8.19.tar.gz
7.2 解压编译redis
tar -zxvf redis-2.8.19.tar.gz
cd redis-2.8.19
make PREFIX=/usr/local/redis install
7.3 配置redis
mkdir -p /usr/local/redis/etc/
cp redis.conf  /usr/local/redis/etc/
sed -i 's/daemonize no/daemonize yes/g' /usr/local/redis/etc/redis.conf
cd ..
7.4 编写redis启动脚本
vim /etc/init.d/redis
chmod +x /etc/init.d/redis
下面是一份参考配置:
#! /bin/bash
## redis - this script starts and stops the redis-server daemon
## chkconfig:    2345 80 90
# description:  Redis is a persistent key-value database##
## BEGIN INIT INFO
# Provides:          redis
# Required-Start:    $syslog
# Required-Stop:     $syslog# Should-Start:        $local_fs# Should-Stop:        $local_fs
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description:    redis-server daemon
# Description:        redis-server daemon
### END INIT INFO
REDISPORT=6379
EXEC=/usr/local/redis/bin/redis-server
REDIS_CLI=/usr/local/redis/bin/redis-cli
PIDFILE=/var/run/redis.pid
CONF="/usr/local/redis/etc/redis.conf"
case "$1" in
    start)
        if [ -f $PIDFILE ]
        then
        echo "$PIDFILE exists, process is already running or crashed"
        else
        echo "Starting Redis server..."
        $EXEC $CONF
        fi
        if [ "$?"="0" ]
        then
        echo "Redis is running..."
        fi
        ;;
    stop)
        if [ ! -f $PIDFILE ]
        then
        echo "$PIDFILE does not exist, process is not running"
        else
                PID=$(cat $PIDFILE)
                echo "Stopping ..."$REDIS_CLI -p $REDISPORT shutdown
                while [ -x ${PIDFILE} ]
                do
                echo "Waiting for Redis to shutdown ..."
                    sleep 1
                    done
                    echo "Redis stopped"
                    fi
        ;;
   restart)
        ${0} stop
        ${0} start
        ;;
  *)  
    echo "Usage: /etc/init.d/redis {start|stop|restart}" >&2
    exit 1
esac
7.5 启动redis
/etc/init.d/redis start
查看redis是否启动
ps -ef|grep redis
8、 升级gcc，gdb等
(非常漫长,如果系统中自带的g++支持C++11，可跳过此步骤)
8.1 下载gcc4.9.2
wget http://ftp.tsukuba.wide.ad.jp/software/gcc/releases/gcc-4.9.2/gcc-4.9.2.tar.gz
8.2 解压编译gcc4.9.2
tar -zxvf gcc-4.9.2.tar.gz
cd gcc-4.9.2
./contrib/download_prerequisitesmkdir gcc-build-4.9.2cd gcc-build-4.9.2../configure --prefix=/usr -enable-checking=release -enable-languages=c,c++ -disable-multilib
make -j 2 && make install
cd ../../
8.3 下载termcap
wget https://mirrors.sjtug.sjtu.edu.cn/gnu/termcap/termcap-1.3.1.tar.gz
8.4 解压编译termcap
tar -zxvf termcap-1.3.1.tar.gz
cd termcap-1.3.1./configure --prefix=/usr
make -j 2 && make install
8.5 下载gdb
wget http://ftp.gnu.org/gnu/gdb/gdb-7.9.tar.gz
8.6 解压编译gdb
tar -zxvf gdb-7.9.tar.gz
cd gdb-7.9
./configure --prefix=/usr
make -j 2 && make install
9、 重启电脑
shutdown -r now
10、 安装PB
10.1 下载pb
wget https://github.com/google/protobuf/releases/download/v2.6.1/protobuf-2.6.1.tar.gz
如果上面的下载不了，可以使用下面的链接，下载后改下名字即可
wget https://launchpad.net/ubuntu/+archive/primary/+sourcefiles/protobuf/2.6.1-1.3/protobuf_2.6.1.orig.tar.gz
mv protobuf_2.6.1.orig.tar.gz protobuf_2.6.1.tar.gz
10.2 解压编译pb
tar -zxvf protobuf-2.6.1
cd protobuf-2.6.1
./configure --prefix=/usr/local/protobuf
make -j 2 && make install
11、 下载TeamTalk代码
git clone https://github.com/mogujie/TeamTalk.git
12、 生成pb文件
12.1 拷贝pb相关文件
拷贝pb的库、头文件到TeamTalk相关目录中:
mkdir -p /root/TeamTalk/server/src/base/pb/lib/linux/
cp /usr/local/protobuf/lib/libprotobuf-lite.a /root/TeamTalk/server/src/base/pb/lib/linux/
cp  -r /usr/local/protobuf/include/* /root/TeamTalk/server/src/base/pb/
12.2 生成pb协议
cd /root/TeamTalk/pb
执行:
export PATH=$PATH:/usr/local/protobuf/bin
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/protobuf/lib
sh create.sh
生成协议相关源码文件。
再执行:
sh sync.sh
将相关文件拷贝到server 目录下。
13、 安装依赖
cd /root/TeamTalk/server/src
sh make_log4cxx.sh
sh make_hiredis.sh
14、 编译server
由于我们是源码安装mysql的，所以对db_proxy_server中的CMakeList做一定的修改.
原来:
SET(MYSQL_INCLUDE_DIR /usr/include/mysql)
SET(MYSQL_LIB /usr/lib64/mysql)
修改为:
SET(MYSQL_INCLUDE_DIR /usr/local/mysql/include)
SET(MYSQL_LIB /usr/local/mysql/lib)
在server/src目录下，执行:
sh build.sh version 1.0.0
这时候会在src的上级目录server目录下构建出im-server-1.0.0.tar.gz的文件，将其拷贝到auto_setup目录下解压，并进入该目录。
然后执行下面的命令：
sh sync_lib_for_zip.sh
然后就可以配置并启动各个服务程序了。
15、 配置server(这里单独开一篇说明一下各个服务地址的配置，请看下面的链接)
https://blog.csdn.net/siyacaodeai/article/details/114981583
16、更新
16.1 导入mysql
登陆mysql:
mysql -uroot -p
输入密码:test123
创建TeamTalk数据库:
create database teamtalk
创建成功显示如下内容：
mysql> create database teamtalk;
Query OK, 1 row affected (0.00 sec)
创建teamtalk用户并给teamtalk用户授权teamtalk的操作:
grant select,insert,update,delete on teamtalk.* to 'teamtalk'@'%' identified by 'test@123';
flush privileges;
导入数据库.
use teamtalk;
source /root/TeamTalk/auto_setup/mariadb/conf/ttopen.sql;
show tables;
成功后会如下内容:
mysql> show tables;+--------------------+| Tables_in_teamtalk |+--------------------+| IMAdmin            || IMAudio            || IMDepart           || IMDiscovery        || IMGroup            || IMGroupMember      || IMGroupMessage_0   || IMGroupMessage_1   || IMGroupMessage_2   || IMGroupMessage_3   || IMGroupMessage_4   || IMGroupMessage_5   || IMGroupMessage_6   || IMGroupMessage_7   || IMMessage_0        || IMMessage_1        || IMMessage_2        || IMMessage_3        || IMMessage_4        || IMMessage_5        || IMMessage_6        || IMMessage_7        || IMRecentSession    || IMRelationShip     || IMUser             |+--------------------+25 rows in set (0.00 sec)mysql>
16.2 修改php
执行如下命令:
cd /home/wwwroot/default
cp -r /root/TeamTalk/php/* /home/wwwroot/default
修改config.php:
vim application/config/config.php
修改第18-19行:
$config['msfs_url'] = 'http://192.168.1.150:8700/';
$config['http_url'] = 'http://192.168.1.150:8400';
修改database.php
vim application/config/database.php
修改52-54行:
$db['default']['hostname'] = '192.168.1.150';
$db['default']['username'] = 'tamtalk';
$db['default']['password'] = 'test@123';
$db['default']['database'] = 'teamtalk';
这里需要注意安装自己的username和password进行修改
17、测试
直接在浏览器输入ip地址即可看到php页面，这时候就可以在后台添加test用户了
如果页面中出现如下错误，
Unable to connect to your database server using the provided settings.  
Filename: core/Loader.php  
Line Number: 346
可以参考后面的链接查找问题，我的修改 $db[‘default’][‘hostname’] = ‘127.0.0.1’;访问通过
TeamTalk部署问题及解决方案[https://blog.csdn.net/siyacaodeai/article/details/114984901]
18、 运行服务
./restart.sh login_server
./restart.sh route_server
./restart.sh msg_server
./restart.sh file_server
./restart.sh msfs
./restart.sh http_msg_server
./restart.sh push_server
./restart.sh db_proxy_server
ps -ef|grep server
如果看到如下:
[root@zhyh ~]# ps -ef|grep server
root      1653     1  0 22:13 ?        00:00:05 /usr/local/redis/bin/redis-server *:6379root      1658     1  1 22:13 ?        00:00:21 ./db_proxy_server
root      1717     1  0 22:13 ?        00:00:02 ./http_msg_server
root      1729     1  0 22:13 ?        00:00:02 ./route_server
root      1737     1  0 22:14 ?        00:00:02 ./login_server
root      1757     1  0 22:15 ?        00:00:02 ./msg_server
root      1788  1774  0 22:34 pts/2    00:00:00 grep server 
如果没有发现:db_proxy_server, http_msg_server,route_server,login_server,msg_server的进程，请执行如下命令启动:
cd /usr/local/teamtalk
cd xxxx
../daeml xxxx
xxx代表相应的程序名。通过查看:xxxx/log/default.log 查看程序错误。
19、 redis,php,nginx,mysql的启动，停止与重启
/etc/init.d/redis {start|stop|restart}
/etc/init.d/php-fpm {start|stop|force-quit|restart|reload}
/etc/init.d/nginx {start|stop|force-quit|restart|reload|status|configtest}
/etc/init.d/mysql {start|stop|restart|reload|force-reload|status}  [ MySQL server options ]


 Maven 镜像配置
 settings.xml 文件位于 Maven 安装目录的 conf 文件夹下
 在settings.xml文件中，找到mirrors节点。如果该节点不存在，可以在文件中添加一个。在mirrors节点中，需要添加一个或多个镜像配置。
 当设置了 Maven 镜像后，可以通过以下命令来验证是否生效：
mvn help:effective-settings
 <!-- 配置使用阿里云的Maven镜像 -->
 <mirror>
     <id>alimaven</id>
     <mirrorof>*</mirrorof>
     <name>阿里云镜像</name>
     <url>https://maven.aliyun.com/repository/central</url>
 </mirror>
 <!-- 配置使用华为云的Maven镜像地址 -->
 <mirror>
     <id>huaweicloud</id>
     <mirrorof>*</mirrorof>
     <name>华为云镜像</name>
     <url>https://mirrors.huaweicloud.com/repository/maven/central</url>
 </mirror>
 <!-- 配置使用Spring的Maven镜像地址 -->
 <mirror>
     <id>springcloud</id>
     <mirrorof>*</mirrorof>
     <name>spring云镜像</name>
     <url>http://repo.spring.io/libs-milestone-local</url>
 </mirror>
 <!-- 配置使用SpringIo的Maven镜像地址 -->
 <mirror>
     <id>springiocloud</id>
     <mirrorof>*</mirrorof>
     <name>springio云镜像</name>
     <url>https://repo.spring.io/libs-release-local</url>
 </mirror>
 <!-- 配置使用136的Maven镜像地址 -->
 <mirror>
     <id>163cloud</id>
     <mirrorof>*</mirrorof>
     <name>163云镜像</name>
     <url>http://mirrors.163.com/maven/repository/maven-public/central/</url>
 </mirror>
 <!-- 配置使用tencent的Maven镜像地址 -->
 <mirror>
     <id>tencentcloud</id>
     <mirrorof>*</mirrorof>
     <name>tencent云镜像</name>
     <url>http://mirrors.cloud.tencent.com/nexus/repository/maven-public/central/</url>
 </mirror>
 <!-- 配置使用oschina的Maven镜像地址 -->
 <mirror>
     <id>oschinacloud</id>
     <mirrorof>*</mirrorof>
     <name>oschina云镜像</name>
     <url>http://maven.oschina.net/content/groups/public/central/</url>
 </mirror>
maven设置临时代理
mvn clean compile -Dhttp.proxyHost=127.0.0.1 -Dhttp.proxyPort=7890 -Dhttps.proxyHost=proxy.example.com -Dhttps.proxyPort=7890
在<settings>标签内添加或修改<proxies>部分来配置代理
<settings>
  <proxies>
    <proxy>
      <id>http-proxy</id>
      <active>true</active>
      <protocol>http</protocol>
      <host>127.0.0.1</host>
      <port>7890</port>
      <!-- username>proxyuser</username --> <!-- 如果不需要用户名和密码，可以省略 -->
      <!-- password>proxypass</password --> <!-- 如果不需要用户名和密码，可以省略 -->
      <nonProxyHosts>*.google.com|*.example.com</nonProxyHosts> <!-- 指定不需要代理的主机 -->
    </proxy>
    <proxy>
      <id>https-proxy</id>
      <active>true</active>
      <protocol>https</protocol>
      <host>127.0.0.1</host>
      <port>7890</port>
      <!-- username>proxyuser</username --> <!-- 如果不需要用户名和密码，可以省略 -->
      <!-- password>proxypass</password --> <!-- 如果不需要用户名和密码，可以省略 -->
      <nonProxyHosts>*.google.com|*.example.com</nonProxyHosts> <!-- 指定不需要代理的主机 -->
    </proxy>
  </proxies>
</settings>


Regexp正则表达式
[ABC] :: 匹配 [...] 中的所有字符，例如 [aeiou] 匹配字符串 "google runoob taobao" 中所有的 e o u a 字母。
[^ABC] :: 匹配除了 [...] 中字符的所有字符，例如 [^aeiou] 匹配字符串 "google runoob taobao" 中除了 e o u a 字母的所有字符。
[A-Z] :: [A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。
. :: 匹配除换行符（\n、\r）之外的任何单个字符，相等于 [^\n\r]。
[\s\S] :: 匹配所有。\s 是匹配所有空白符，包括换行，\S 非空白符，不包括换行。
\w :: 匹配字母、数字、下划线。等价于 [A-Za-z0-9_]
\d	 :: 匹配任意一个阿拉伯数字（0 到 9）。等价于 [0-9]
\cx	 :: 匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。
\f	 :: 匹配一个换页符。等价于 \x0c 和 \cL。
\n	 :: 匹配一个换行符。等价于 \x0a 和 \cJ。
\r	 :: 匹配一个回车符。等价于 \x0d 和 \cM。
\s	 :: 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。
\S	 :: 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
\t	 :: 匹配一个制表符。等价于 \x09 和 \cI。
\v	 :: 匹配一个垂直制表符。等价于 \x0b 和 \cK。
$	 :: 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'。要匹配 $ 字符本身，请使用 \$。
( )	 :: 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。
*	 :: 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \*。
+	 :: 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。
.	 :: 匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \. 。
[	 :: 标记一个中括号表达式的开始。要匹配 [，请使用 \[。
?	 :: 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。
\	 :: 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\n' 匹配换行符。序列 '\\' 匹配 "\"，而 '\(' 则匹配 "("。
^	 :: 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 \^。
{	 :: 标记限定符表达式的开始。要匹配 {，请使用 \{。
|	 :: 指明两项之间的一个选择。要匹配 |，请使用 \|。
*	 :: 匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于 {0,}。	
+	 :: 匹配前面的子表达式一次或多次。例如，zo+ 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。	
?	 :: 匹配前面的子表达式零次或一次。例如，do(es)? 可以匹配 "do" 、 "does"、 "doxy" 中的 "do" 和 "does"。? 等价于 {0,1}。
{n}	 :: n 是一个非负整数。匹配确定的 n 次。例如，o{2} 不能匹配 "Bob" 中的 o，但是能匹配 "food" 中的两个 o。	
{n,}	 :: n 是一个非负整数。至少匹配n 次。例如，o{2,} 不能匹配 "Bob" 中的 o，但能匹配 "foooood" 中的所有 o。o{1,} 等价于 o+。o{0,} 则等价于 o*。	
{n,m}	 :: m 和 n 均为非负整数，其中 n <= m。最少匹配 n 次且最多匹配 m 次。例如，o{1,3} 将匹配 "fooooood" 中的前三个 o。o{0,1} 等价于 o?。请注意在逗号和两个数之间不能有空格。
^	 :: 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。	
$	 :: 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。	
\b	 :: 匹配一个单词边界，即字与空格间的位置。	
\B	 :: 非单词边界匹配。
常用正则表达式汇总
匹配大写字母开头单词      r"\b[A-Z]+[a-z]*\b"      r"\b[A-Z]\w*\b"
匹配数字     r"\s(-?\d+\.?/?\d*%?)"
替换日期  2019-09-09   换成  2019.09.09               r"\d{4}-\d{1,2}-\d{1,2}"
比较常用的几个正则表达式(匹配数字)
评注：匹配中文还真是个头疼的事，有了这个表达式就好办了
匹配双字节字符(包括汉字在内)：[^\x00-\xff]
评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）
匹配空白行的正则表达式：\n\s*\r
评注：可以用来删除空白行
匹配HTML标记的正则表达式：<(\S*?)[^>]*>.*?</\1>|<.*? />
评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力
匹配首尾空白字符的正则表达式：^\s*|\s*$
评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式
匹配Email地址的正则表达式：\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*
评注：表单验证时很实用
匹配网址URL的正则表达式：[a-zA-z]+://[^\s]*
评注：网上流传的版本功能很有限，上面这个基本可以满足需求
匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
评注：表单验证时很实用
匹配国内电话号码：\d{3}-\d{8}|\d{4}-\d{7}
评注：匹配形式如 0511-4405222 或 021-87888822
匹配腾讯QQ号：[1-9][0-9]{4,}
评注：腾讯QQ号从10000开始
匹配中国邮政编码：[1-9]\d{5}(?!\d)
评注：中国邮政编码为6位数字
匹配身份证：\d{15}|\d{18}
评注：中国的身份证为15位或18位
匹配ip地址：\d+\.\d+\.\d+\.\d+
评注：提取ip地址时有用
匹配特定数字：
^[1-9]\d*$　 　 //匹配正整数
^-[1-9]\d*$ 　 //匹配负整数
^-?[1-9]\d*$　　 //匹配整数
^[1-9]\d*|0$　 //匹配非负整数（正整数 + 0）
^-[1-9]\d*|0$　　 //匹配非正整数（负整数 + 0）
^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$　　 //匹配正浮点数
^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$　 //匹配负浮点数
^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$　 //匹配浮点数
^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$　　 //匹配非负浮点数（正浮点数 + 0）
^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$　　//匹配非正浮点数（负浮点数 + 0）
/^(100|[1-9]?\d)%$/      // 0% 到 100% 不能有小数
/^(100|[1-9]?\d(\.\d\d?)?)%$/    // 0% 到 100% 可有小数 (5.2%  55.55%)
评注：处理大量数据时有用，具体应用时注意修正
匹配特定字符串：
^[A-Za-z]+$　　//匹配由26个英文字母组成的字符串
^[A-Z]+$　　//匹配由26个英文字母的大写组成的字符串
^[a-z]+$　　//匹配由26个英文字母的小写组成的字符串
^[A-Za-z0-9]+$　　//匹配由数字和26个英文字母组成的字符串
^\w+$　　//匹配由数字、26个英文字母或者下划线组成的字符串
校验数字的表达式
1 数字：^[0-9]*$
2 n位的数字：^\d{n}$
3 至少n位的数字：^\d{n,}$
4 m-n位的数字：^\d{m,n}$
5 零和非零开头的数字：^(0|[1-9][0-9]*)$
6 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$
7 带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$   
8 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$
9 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$
10 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$
11 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$    
12 非零的负整数：^\-[1-9][]0-9"*$ 或 ^-[1-9]\d*$
13 非负整数：^\d+$ 或 ^[1-9]\d*|0$
14 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$
15 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$
16 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$
17 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$
18 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$
19 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$
校验字符的表达式
1 汉字：^[\u4e00-\u9fa5]{0,}$
2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$
3 长度为3-20的所有字符：^.{3,20}$
4 由26个英文字母组成的字符串：^[A-Za-z]+$
5 由26个大写英文字母组成的字符串：^[A-Z]+$
6 由26个小写英文字母组成的字符串：^[a-z]+$
7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$
8 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$
9 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$
10 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$
11 可以输入含有^%&',;=?$\"等字符：[^%&',;=?$\x22]+
12 禁止输入含有~的字符：[^~\x22]+
特殊需求表达式
1 Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$
2 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?
3 InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$
4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$
5 电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$
6 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7}
7 身份证号(15位、18位数字)：^\d{15}|\d{18}$
8 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$
9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$
11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$
12 日期格式：^\d{4}-\d{1,2}-\d{1,2}
13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$
14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$
15 钱的输入格式：
16 1.有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：^[1-9][0-9]*$
17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$
18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$
19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$
20 5.必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：^[0-9]+(.[0-9]{2})?$
21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$
22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$
23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$
24 备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里
25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$
26 中文字符的正则表达式：[\u4e00-\u9fa5]
27 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))
28 空白行的正则表达式：\n\s*\r (可以用来删除空白行)
29 HTML标记的正则表达式：<(\S*?)[^>]*>.*?</\1>|<.*? /> (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)
30 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)
31 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)
32 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)
33 IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)
34 IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))

Chromium Angle 在 Windows and Mac 编译
1. 准备好代理；
第一步：window系统开启代理；
第二步：下载window专用的 depot_tools，新建一个文件夹depot_tools，然后把depot_tools解压到这个文件夹depot_tools(一定带上git的文件夹，是隐藏的),将建立的这个文件夹depot_tools的路径设置到环境变量里面，并且必须在python的前面；
第三步：以管理员的身份进入命令行操作，找个可用的磁盘位置，输入命令 mkdir angle && cd angle；
第四步：执行git代理和Windows代理设置：
git 代理方式为：
git config --global http.proxy socks5://127.0.0.1:7890
git config --global https.proxy socks5://127.0.0.1:7890
git 代理取消方式为：
git config --global --unset http.proxy
git config --global --unset https.proxy
cmd代理设置：
set http_proxy=socks5://127.0.0.1:7890
set https_proxy=socks5://127.0.0.1:7890
set DEPOT_TOOLS_WIN_TOOLCHAIN=0 
第五步：克隆代码：
git clone https://chromium.googlesource.com/angle/angle
cd angle
python scripts/bootstrap.py
gclient sync
git checkout master
第六步：编译代码
编译之前需要确认一下是不是装了 最新的 Windows SDK 最新版本
Set DEPOT_TOOLS_WIN_TOOLCHAIN=0 // 不是Google的员工要有这步的操作
set vs2019_install=D:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise
gn gen out/Debug --sln=angle-debug --ide=vs2019 --args="is_debug=true is_clang=false dcheck_aways_on=true"
gn gen out/Release --sln=angle-release --ide=vs2019 --args="is_debug=false is_clang=false dcheck_aways_on=true"
2. MAC编译
第一步：先对Mac下的git代理（同window下的git）
第二步：设置Mac系统代理 Mac Terminal Proxy
// Execute one or both of the export commands for HTTP traffic. 
export http_proxy=192.168.1.10:8080
export HTTP_PROXY=192.168.1.10:8080
// Same as with HTTP, use one or both the examples below for HTTPS traffic
export https_proxy=192.168.1.10:8080
export HTTPS_PROXY=192.168.1.10:8080
第三步：配置depot_tools depot_tools
// clone the tools
git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git
// set the tool path
export PATH=$PATH:/path/to/depot_tools
第四步：clone 代码
git clone https://chromium.googlesource.com/angle/angle
cd angle
python scripts/bootstrap.py
gclient sync
git checkout master
第五步：编译
// use autoninja debug
gn gen  out/Debug
// use autoninja release
gn gen  out/Release --args="is_debug=false"
// use xcode build release
gn gen out/xcodeRelease  --ide=xcode --xcode-project=angle --args="is_debug=false"
// use xcode build debug
gn gen out/xcodeDebug  --ide=xcode --xcode-project=angle

C++11标准中常用到的各种算法汇总.
在C++11标准中定义了很多算法，这些算法可以让我们很方便的操作各种容器和数组，这里要注意一下，这些算法操作的并非容器，而是迭代器，然后通过迭代器来操作容器中的数据，算法本身并不会关注容器中保存的数据的类型。
以下是我对常识的算法的总结，这些算法大部分都在algorithm.h中，还有一些在numeric.h中。
这里我们的容器都用这几个：
vector<string> vec;
vector<int> vec1;
vec<string> vec2;
1.find();
   find()算法的作用是在指定的一段序列中查找某个数，包含三个参数，前两个参数是表示元素范围的迭代器，第三个参数是要查找的值。
   例：fing(vec.begin(), vec.end(), val); //在vec中查找值val，该val可以是数字、字符串。
2.count（）；
   count()算法的作用是查看给定序列中给定值出现的次数，同样包含三个参数，前两个参数是表示元素范围的迭代器，第三个参数是要查找的值。
   例：count(vec1.begin(), vec1.end(), 2);//在vec1中查看2出现的次数。
3.accumulate（）；//该函数在numeric.h文件中
   accumulate（）函数的作用是计算指定范围中各个数相加的和。包含三个参数，前两个参数是求和的序列范围，第三个参数是和的初始值。
   例：accumulate(vec1.begin（）， vec1.end(), 0)；//计算vec1中各个数相加的总和，和的初始值为0；
4.equal（）；
   equal（）算法的作用是确定两个序列是否保存相同的值，此算法接受三个迭代器，前两个迭代器表示第一个序列中元素的范围，第三个迭代器表示第二个序列的手元素。如果相等，则返回true， 否则返回false；
   equal（vec.begin(), vec.end(), vec2.begin()）;//比较vec和vec2中的元素是否相同。
5.fill();
   fill()算法的作用是对一个范围内的所有元素赋值，包含三个参数，前两个参数接受一对迭代器表示一个范围，第三个迭代器接受一个值。
   例：fill（vec.begin(), vec.end(), "");//将vec中的所有元素都置为空。
6.fill_n();
   fill_n算法的作用是将给定值赋给迭代器指向的元素开始的指定个元素。第一个参数接受一个迭代器，第二个元素接受一个计数值，第三个迭代器接受一个值。
   例：fill_n(vec.begin(), vec.size(), "");//将vec中的所有元素置为空。
   注：这里介绍一下back_inserter，它是一种插入迭代器，是一种向容器中添加元素的迭代器，它定义在iterator.h中，每调用一次back_inserter,函数则会调用一    次push_back。
   例：auto i = back_inseter(vec1);//通过它赋值会将元素添加到vec中
        *i = 42;//vec1中现有有一个元素，值为42
   这里back_inserter常用来创建一个迭代器作为算法的目的位置来使用。
   例：fill_n(back_inserter(vec1), 10, 0);//向vec1的末尾添加10个元素，元素值为0；
7.copy();
   copy()算法将输入范围中的元素拷贝到目的序列中。包括三个参数，前两个表示一个输入范围，第三个表示序列的起始位置。
   例：int a1[] = {0,1,2,3,4,5,6,7,8,9};
        int a2[sizeof(a1)/sizeof(*a1)];
        //ret指向拷贝到a2的为元素之后的位置
        auto ret = copy(begin(a1), end(a1), a2);//把a1的内容拷贝到a2.
8.replace();
   replace()算法的作用是将给定序列中所有等会给定值的元素都改为另一个值，此算法接收四个参数，前两个是迭代器，表示输入序列范围，第三个是表示要搜索的      值，第四个是要换的新值。
   例：replace(vec.begin(), vec.end(), "", "test");//将vec中的空字符串改为test。
   如果我们需要保证原序列的值不变，则可以使用replace_copy()算法，使原序列不变，将改变后的序列值拷贝给新容器。
   例：replace_copy(vec.begin(), vec.end()，back_inserter(vec2), "", "test");//将修改后的新序列保存到vec2中，原序列值不变。  
9.sort（）；
   sort()算法的作用是重新排列输入的序列中的元素，它是按照字典序列来重新排布序列。
   例：vector<string> vec = {"the", "quick", "red", "for", "jump","over", "the", "slow", "red", "turtle"}；
         sort(vec.begin(), vec.end());
        执行完后的结果：for jump over quick red slow the the turtle
10.unique（）；
    unique（）算法的作用是重新排列输入的序列号，并使前面的每个单词都只出现一次，返回指向不重复区域之后一个位置的迭代器。
    如9的vec，auto end_unique = unique(vec.begin(), vec.end());
     执行完后的结果：for jump over quick red slow the  turtle the
     这是如果我们需要得到一个不重复的序列，则只需要使用erase（）即可，即
     vec.erase(end_unique, vec.end());
      执行完后的结果：for jump over quick red slow the  turtle 
注：为了讲后面的算法，这里先普及一下谓词，这里所谓的谓词并不是语言语法上的谓词，而是向算法传递的函数名。
    例：bool isShort(const string &s1, const string &s2)
      { return s1.size() < s2.size(); }
     前面的sort()算法也是可以接收谓词的，如sort（vec.begin(), vec.end(), isShort）;
     该语句的意思是重新排列序列，但是是按照字符串的长度从小到大的顺序排列。
11.partiton（）；
    partition()算法的作用是对输入的容器的内容进行划分，该算法返回一个迭代器，返回指向最后一个是谓词为true的元素之后的位置。接受三个
    参数，前两个是元素的范围迭代器，后一个是划分标准。
    例：bool bigger(const string &a)
        { return a.size() > 5; }
        partition(vec.begin(), vec.end(), bigger);//将vec划分开，前部分是长度大于5的字符串，后部分是长度小于等于5的字符串。
注：这样再讲一下可调用对象lambda，格式[capture list](parameter list)->reture type{function boby}
     其中capture list（捕获列表）是一个lambda所在函数中定义的局部变量的列表（通常为空），reture type、parameter list、function boby和其他的函数一      样，分别表示返回类型、参数列表、函数体。像11中的例子可以写成：
     partition(vec.begin(), vec.end(), [](const string &a) {return a.size()>5;});//可以和上面达到一样的效果
12.find_if();
    find_if()算法的作用是在输入序列中查找第一个满足条件的元素，返回第一个指向满足条件的元素的迭代器。
    例：auto wc = find_if(vec.begin(), vec.end(), [sz](const string &a){return a.size>=sz;});//其中sz为在使用find_if的函数内部定义的局部变量。
    上诉算法得到的是第一个指向长度不小于sz的元素的迭代器，如果没有则返回vec.end();
13.for_each();
    for_each()算法的主要作用是打印输出序列。接收三个参数，前两个为打印元素的范围，后一个为一个可调用对象。
    例：for_each(wc, vec.end(), [](const string &s){cout << s << " ";});
         cout << endl;
    上述程序的作用就是打印输出序列中从wc到vec.end（）中的元素。
    

题解决C++调用C函数同名问题
我们在写C++类时，有时候需要调用C程序接口，这涉及到C++本身定义的成员函数名和C函数名重名的问题，如：
Test::Test()
{
}
int Test::open()
{
  int fd;
  fd=open("dev/i2c-1", O_RDWR);
  return 0;
}
其中Test::open()函数中调用的时系统open()函数，这样定义编译器就会报错，因为编译器认为你调用的是Test类的成员函数open()，当然解决方法有多种，比如我们把类的成员函数open()换个名称即可，但有时候为了函数命名规则及调用的明确化，我们可以这样（用到上述“2)全局作用域符号”的功能），如：
Test::Test()
{
}
int Test::open()
{
  int fd;
  fd=::open("dev/i2c-1", O_RDWR);
  return 0;
}
在被调用的C函数open()前加"::"，把C函数当作全局函数调用即可。

Direct2D入门
一. 资源管理(Resource management)
和Direct3D一样，Direct2D程序需要处理设备丢失(Device lost)问题。Direct2D中的资源分为设备独立资源(Device independent resource)和设备依赖资源(Device dependent resource)。
设备独立资源包括：
ID2D1DrawingStateBlock
ID2D1Factory
ID2D1Geometry 和由此继承而来的接口
ID2D1GeometrySink and ID2D1SimplifiedGeometrySink
ID2D1StrokeStyle
设备依赖资源包括：
ID2D1Brush 和由此继承而来的接口
ID2D1Layer
ID2D1RenderTarget 和由此继承而来的接口
二. Direct2D程序的结构
在程序初始化函数处创建设备独立资源，如ID2D1Factory，IDWriteFactory等；
创建设备依赖资源，如果运行过程中出现设备丢失，需要重新创建；
响应WM_PAINT消息，在OnPaint()或OnDraw()等处，用创建的资源Render；
响应WM_SIZE消息，在OnSize()处调用ID2D1RenderTarget::Resize();
响应WM_ERASEBKGND，在OnEraseBkgnd()处返回FALSE，阻止GDI重绘客户区背景色，设置背景色的工作交给Direct2D在Render时设置，否则在Resize时会出现窗口闪烁的问题；
退出程序前，清理资源。
为提高程序的性能，尽量减少资源的创建和销毁操作，将能够重复利用的资源接口变量申明为View类的成员变量。
三. Direct2D demo
一个简单的MFC程序，用于演示Direct2D程序的结构和一些简单绘图操作。
1.Direct2D prerequisite
D2dPrerequisite.h，包含一些编译Direct2D程序所需要用到的头文件，lib库文件，帮助宏和预处理指令：
  //D2dPrerequisite.h
  #pragma once
  //////////////////////////////////////////////////////////////////////////
  //Header files and lib files for Direct2D and DirectWrite
  #include <d2d1.h>                //Direct2D,for normal rendering task
  #include <d2d1helper.h>        
  #include <dwrite.h>                //DirectWrite,for drawing text
  #include <wincodec.h>                //Windows imaging component,for image decoding
 #pragma comment(lib,"d2d1.lib")
 #pragma comment(lib,"dwrite.lib")
 #pragma comment(lib,"windowscodecs.lib")
 //////////////////////////////////////////////////////////////////////////
 //Helper template for resource releasing
 template<class Interface>
 inlinevoid SafeRelease(Interface **ppInterfaceToRelease)
 {
         if (*ppInterfaceToRelease != NULL)
         {
                 (*ppInterfaceToRelease)->Release();
                 (*ppInterfaceToRelease) = NULL;
         }
 }
 #ifndef Assert
 #if defined( DEBUG ) || defined( _DEBUG )
 #define Assert(b) do {if (!(b)) {OutputDebugStringA("Assert: " #b "\n");}} while(0)
 #else
 #define Assert(b)
 #endif //DEBUG || _DEBUG
 #endif
 #ifndef HINST_THISCOMPONENT
 EXTERN_C IMAGE_DOS_HEADER __ImageBase;
 #define HINST_THISCOMPONENT ((HINSTANCE)&__ImageBase)
 #endif
2.View类中的成员变量：
  //View.h
  private:
          //Direct2D interface
          ID2D1Factory* m_pD2d1Factory;
          ID2D1HwndRenderTarget* m_pHwndRenderTarget;
          ID2D1SolidColorBrush* m_pSolidColorBrush;
          ID2D1LinearGradientBrush* m_pLinearGradientBrush;
          ID2D1RadialGradientBrush* m_pRadialGradientBrush;
         //DirectWrite interface
         IDWriteFactory* m_pDWriteFactory;
         IDWriteTextFormat* m_pTextFormat;
3.创建设备独立资源
  //View.cpp
  BOOL CBasicView::CreateDeviceIndependentResource()
  {
          HRESULT hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED,&m_pD2d1Factory);
          ASSERT(hr == S_OK);
          if (SUCCEEDED(hr))
          {
                  hr = DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED,
                         __uuidof(m_pDWriteFactory),
                         reinterpret_cast<IUnknown**>(&m_pDWriteFactory));
                 ASSERT(hr == S_OK);
         }
         //Create TextFormat object with IDWriteFactory
         if (SUCCEEDED(hr))
         {
                 const CString fontName = _T("Verdana");
                 const FLOAT fontSize = 32.0f;
                 hr = m_pDWriteFactory->CreateTextFormat(
                         fontName,
                         NULL,
                         DWRITE_FONT_WEIGHT_NORMAL,
                         DWRITE_FONT_STYLE_NORMAL,
                         DWRITE_FONT_STRETCH_NORMAL,
                         fontSize,
                         L"",        //locale
                         &m_pTextFormat
                         );
                 ASSERT(hr == S_OK);
                 if (SUCCEEDED(hr))
                 {
                         //Center alignment vertically and horizontally
                         m_pTextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
                         m_pTextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
                 }
         }
         return (hr == S_OK);
 }
4.创建设备依赖资源
  //View.cpp
  BOOL CBasicView::CreateDeviceDependentResource()
  {
          ASSERT(m_pD2d1Factory != NULL);
          if (m_pHwndRenderTarget != NULL)        //There is no need to create render target
                  return TRUE;
          RECT rc;
          GetClientRect(&rc);
         D2D1_SIZE_U size = SizeU(rc.right-rc.left,rc.bottom-rc.top);
         HRESULT hr = m_pD2d1Factory->CreateHwndRenderTarget(
                 RenderTargetProperties(),
                 HwndRenderTargetProperties(m_hWnd,size),//Bind the HwndRenderTarget to view window
                 &m_pHwndRenderTarget);
         ASSERT(hr == S_OK);
         if (SUCCEEDED(hr))
         {
                 //Create solid color brush
                 hr = m_pHwndRenderTarget->CreateSolidColorBrush(
                         ColorF(ColorF::LightGreen),
                         &m_pSolidColorBrush);
                 ASSERT(hr == S_OK);
                 //Create gradient stops collection,
                 //used by linear gradient brush or radial gradient brush
                 ID2D1GradientStopCollection* pGradientStops = NULL;
                 D2D1_GRADIENT_STOP stops[2];
                 stops[0].color = ColorF(ColorF::Yellow);
                 stops[0].position = 0.0f;
                 stops[1].color = ColorF(ColorF::Red);
                 stops[1].position = 1.0f;
                 HRESULT hr = m_pHwndRenderTarget->CreateGradientStopCollection(
                         stops,
                         2,
                         D2D1_GAMMA_2_2,
                         D2D1_EXTEND_MODE_CLAMP,
                         &pGradientStops);
                 ASSERT(hr == S_OK);
                 //Create linear gradient brush
                 hr = m_pHwndRenderTarget->CreateLinearGradientBrush(
                         LinearGradientBrushProperties(Point2F(210,110),Point2F(290,190)),
                         pGradientStops,
                         &m_pLinearGradientBrush);
                 ASSERT(hr == S_OK);
                 //Create radial gradient brush
                 hr = m_pHwndRenderTarget->CreateRadialGradientBrush(
                         RadialGradientBrushProperties(Point2F(350,150),Point2F(0,0),50,50),
                         pGradientStops,
                         &m_pRadialGradientBrush);
                 ASSERT(hr == S_OK);
                 SafeRelease(&pGradientStops);
         }
         return (hr == S_OK);
 }
5.Render
  //View.cpp
  void CBasicView::Render()
  {
          ASSERT(m_pD2d1Factory != NULL);
          if (!m_pHwndRenderTarget)        //Render target need to be recreated
          {
                  //Recreate device dependent resource
                  BOOL succeeded = CreateDeviceDependentResource();
                  if (!succeeded)
                         return;
         }
         const D2D1_COLOR_F redColor = ColorF(ColorF::Red);
         const D2D1_COLOR_F greenColor = ColorF(ColorF::Green);
         const D2D1_COLOR_F blueColor = ColorF(ColorF::Blue);
         const D2D1_COLOR_F yellowColor = ColorF(ColorF::Yellow);
         const D2D1_COLOR_F pinkColor = ColorF(ColorF::Pink);
         const D2D1_COLOR_F lightBlue = ColorF(ColorF::LightBlue);
         const D2D1_COLOR_F lightGreen = ColorF(ColorF::LightGreen);
         m_pHwndRenderTarget->BeginDraw();
         m_pHwndRenderTarget->Clear(ColorF(ColorF::White));        //Clear the background
         //Draw line
         //We can set the color and opacity of solid color brush at any time,
         //so there is no need to create brushes for different colors
         m_pSolidColorBrush->SetColor(redColor);        
         D2D1_POINT_2F startPoint = Point2F(10,10);
         D2D1_POINT_2F endPoint = Point2F(90,90);
         m_pHwndRenderTarget->DrawLine(startPoint,endPoint,m_pSolidColorBrush,5.0);
         //Draw rectangle
         m_pSolidColorBrush->SetColor(greenColor);
         D2D1_RECT_F rect = RectF(110,10,190,90);
         m_pHwndRenderTarget->DrawRectangle(rect,m_pSolidColorBrush,4.0f);
         //Draw rounded rectangle
         m_pSolidColorBrush->SetColor(blueColor);
         rect = RectF(210,10,290,90);
         D2D1_ROUNDED_RECT roundedRect = RoundedRect(rect,10,10);
         m_pHwndRenderTarget->DrawRoundedRectangle(roundedRect,m_pSolidColorBrush,3.0f);
         //Draw ellipse
         m_pSolidColorBrush->SetColor(redColor);
         D2D1_POINT_2F center = D2D1::Point2F(350,50);
         D2D1_ELLIPSE ellipse = D2D1::Ellipse(center,40,30);
         m_pHwndRenderTarget->DrawEllipse(ellipse,m_pSolidColorBrush,3.0f);
         //Fill rectangle
         m_pSolidColorBrush->SetColor(pinkColor);
         rect = RectF(10,110,90,190);
         m_pHwndRenderTarget->FillRectangle(rect,m_pSolidColorBrush);
         //Fill rounded rectangle
         m_pSolidColorBrush->SetColor(blueColor);
         m_pSolidColorBrush->SetOpacity(0.3f);
         rect = RectF(110,110,190,190);
         roundedRect = RoundedRect(rect,20,20);
         m_pHwndRenderTarget->FillRoundedRectangle(roundedRect,m_pSolidColorBrush);
         //Fill rectangle with linear gradient brush
         rect = RectF(210,110,290,190);
         m_pHwndRenderTarget->FillRectangle(rect,m_pLinearGradientBrush);
         //Fill ellipse with gradient brush
         ellipse = D2D1::Ellipse(Point2F(350,150),40,40);
         m_pHwndRenderTarget->FillEllipse(ellipse,m_pRadialGradientBrush);
         //Draw text with a linear gradient brush
         const CString text = _T("Text drawed with Direct2D & DWrite!");
         rect = RectF(20,210,380,290);
         m_pHwndRenderTarget->DrawTextW(
                 text,
                 text.GetLength(),
                 m_pTextFormat,
                 rect,
                 m_pLinearGradientBrush);
         HRESULT hr = m_pHwndRenderTarget->EndDraw();
         if (hr == D2DERR_RECREATE_TARGET)        //Render target need to be recreated
         {
                 //Discard all device dependent resources,
                 //and recreate them in the next render procedure
                 DiscardDeviceDependentResource();
         }
 }
6. 销毁设备依赖资源，以备下次Render时再次创建
  //View.cpp
  void CBasicView::DiscardDeviceDependentResource()
  {
          SafeRelease(&m_pRadialGradientBrush);
          SafeRelease(&m_pLinearGradientBrush);
          SafeRelease(&m_pSolidColorBrush);
          SafeRelease(&m_pHwndRenderTarget);
  }
7.Resize
  //View.cpp
  void CBasicView::Resize(int width,int height)
  {
         if (m_pHwndRenderTarget)
         {
                 m_pHwndRenderTarget->Resize(SizeU(width,height));
         }
  }

https://www.figma.com/file/HCMLMsZ0ZNoiVhptpWZQW0/%E5%9F%BA%E9%87%91%E8%82%A1%E7%A5%A8?type=design&node-id=1463-138&mode=design&t=n0XErCQyuKkFmCj2-0
http://202.81.237.68:8092/swagger-ui.html
http://202.81.237.68/#/fund/fundBuyRecord
https://miuiver.com/miflash/
https://www.123pan.com/s/NdTDVv-dgOn3.html Note12Turbo养老
https://www.123pan.com/s/q4S8Vv-agrWv.html MOOS极限精简
https://sourceforge.net/projects/eliteroms/files/MIUI-STABLE-UPDATES/MIUI-v14/ Elite欧版澎湃
https://www.iyio.net/search/label/%E5%85%8D%E8%B4%B9%E8%8A%82%E7%82%B9
https://nodefree.org/
https://bbs.kanxue.com/thread-268175.htm
https://bbs.kanxue.com/search-frida_E6_8C_81_E4_B9_85_E5_8C_96.htm
https://bbs.kanxue.com/thread-261844.htm
https://bbs.kanxue.com/thread-268256.htm
https://bbs.kanxue.com/thread-266785.htm
https://bbs.kanxue.com/thread-229970.htm
https://blog.csdn.net/weixin_51111267/article/details/131303876
https://mp.weixin.qq.com/s?__biz=MzI5ODYyMjk5NQ==&mid=2247484285&idx=1&sn=04bb0cd940c58d305d960b45fda316ad&chksm=eca24a01dbd5c317a3c7848636cf856b07ecf2852aa439cd6fedcfc8ce8fa4ad23dc25c18390&scene=21#wechat_redirect
https://mp.weixin.qq.com/s?__biz=MzI5ODYyMjk5NQ==&mid=2247484277&idx=1&sn=72a0ddacbae9ed0010119bd0070549ab&chksm=eca24a09dbd5c31f0ec612b594f45dc926bfb29c582b768278daafb7b2bafaa1aa2b348b546d&scene=21#wechat_redirect
https://github.com/telegramdesktop/tdesktop/releases
https://github.com/frida/frida/releases
https://github.com/ViRb3/magisk-frida/releases
https://github.com/lico-n/ZygiskFrida/releases
https://github.com/nitanmarcel/magisk-frida-inject
https://github.com/rev1si0n/lamda
https://github.com/hack0z/luject
https://github.com/qiang/Riru-ModuleFridaGadget
https://github.com/iGio90/FridaAndroidInjector
https://github.com/LinkSheet/LinkSheet
https://blog.csdn.net/Crazy__Hope/article/details/123113405
https://blog.csdn.net/Y_morph/article/details/129534274
https://blog.csdn.net/qq_43572758/article/details/127960298
https://blog.csdn.net/qq_42805977/article/details/128562524
https://www.52pojie.cn/thread-1189150-1-1.html?tdsourcetag=s_pcqq_aiomsg
https://www.52pojie.cn/thread-1167681-1-1.html
https://www.zhihu.com/tardis/bd/art/362925495?source_id=1001
https://blog.csdn.net/freeking101/article/details/120775403
https://github.com/GaoXiaoduo/gxd-robust
https://github.com/WaterLow3206/RobustFix
https://github.com/Meituan-Dianping/Robust
https://zhuanlan.zhihu.com/p/88820991 如何5分钟让你的 SDK 拥有热修复能力（原理篇）
https://blog.csdn.net/ljw124213/article/details/73844811 android热修复之Robust使用(真正的入门)
https://www.jianshu.com/p/5dc24a4e45e8
https://demon.blog.csdn.net/article/details/113585385 Android端FMOD&SoundTouch音频变声解决方案
https://blog.csdn.net/DeMonliuhui/article/details/78269234 Android Apk加壳技术实战详解


CentOS 7 配置 IP 地址
1：动态获取ip；2：设置静态IP地址
在配置网络之前我们先要知道centos的网卡名称是什么，centos7不再使用ifconfig命令，可通过命令 IP addr 查看网卡名为ens32，是没有IP地址的
1、动态获取ip（前提是你的路由器已经开启了DHCP）修改网卡配置文件 vi /etc/sysconfig/network-scripts/ifcfg-ens32    (最后一个为网卡名称)动态获取IP地址需要修改两处地方即可（1）bootproto=dhcp
（2）onboot=yes
（3）重启网络服务 systemctl restart network
这样动态配置IP地址就设置好了，这个时候再查看一下ip addr 就可以看到已经获取了IP地址，且可以上网（ping 百度）
2、配置静态IP地址设置静态IP地址与动态iIP差不多，也是要修改网卡配置文件 vi /etc/sysconfig/network-scripts/ifcfg-ens32    (最后一个为网卡名称)
（1）bootproto=static
（2）onboot=yes
（3）在最后加上几行，IP地址、子网掩码、网关、dns服务器
IPADDR=192.168.1.160
NETMASK=255.255.255.0
GATEWAY=192.168.1.1
DNS1=119.29.29.29
DNS2=8.8.8.8
（4）重启网络服务 systemctl restart network
使用 nmcli 命令设置静态 IP
如果你更喜欢使用命令行工具，nmcli 是一个强大的网络管理工具，可以快速设置静态 IP。
获取连接名称
使用以下命令查看网络接口的连接名称：
nmcli -p device
记下你要配置的接口名称。
设置静态 IP
使用 nmcli 命令修改接口的 IP 配置。例如，为接口 enp0s3 设置静态 IP：
sudo nmcli con modify enp0s3 ipv4.addresses 192.168.1.30/24
sudo nmcli con modify enp0s3 ipv4.gateway 192.168.1.1
sudo nmcli con modify enp0s3 ipv4.dns 8.8.8.8
sudo nmcli con modify enp0s3 ipv4.method manual
ipv4.addresses 设置静态 IP 地址和子网掩码。
ipv4.gateway 设置默认网关。
ipv4.dns 设置 DNS 服务器。
重启网络连接
使配置生效：
nmcli con down enp0s3 && sudo nmcli connection up enp0s3
验证设置
使用 ip addr show  命令验证 IP 地址是否正确

CentOS 镜像源配置
1. 备份
mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
2. 下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/
centos8（centos8官方源已下线，建议切换centos-vault源）
wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo
或者
curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo
centos6（centos6官方源已下线，建议切换centos-vault源）
wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-6.10.repo
或者
curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-6.10.repo
CentOS 7
wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo
或者
curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo
3. 运行 yum makecache 生成缓存
4. 其他
非阿里云ECS用户会出现 Couldn't resolve host 'mirrors.cloud.aliyuncs.com' 信息，不影响使用。用户也可自行修改相关配置: eg:
sed -i -e '/mirrors.cloud.aliyuncs.com/d' -e '/mirrors.aliyuncs.com/d' /etc/yum.repos.d/CentOS-Base.repo
CentOS 8 结束生命周期如何切换源
公网用户：
mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo
yum clean all && yum makecache
阿里云ecs用户：
mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.cloud.aliyuncs.com/repo/Centos-vault-8.5.2111.repo
sed -i 's/mirrors.cloud.aliyuncs.com/url_tmp/g' /etc/yum.repos.d/CentOS-Base.repo && sed -i 's/mirrors.aliyun.com/mirrors.cloud.aliyuncs.com/g' /etc/yum.repos.d/CentOS-Base.repo && sed -i 's/url_tmp/mirrors.aliyun.com/g' /etc/yum.repos.d/CentOS-Base.repo
yum clean all && yum makecache

CentOS7 配置阿里云yum源
//阿里源（推荐）：wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
//网易源：wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.163.com/.help/CentOS7-Base-163.repo
cd  /etc/yum.repos.d/
yum -y install wget
wget  http://mirrors.aliyun.com/repo/Centos-7.repo
mv  CentOs-Base.repo CentOs-Base.repo.bak
mv Centos-7.repo CentOs-Base.repo
yum clean all
yum makecache
yum update

无法通过WinSCP连接Debian
 1. 检查虚拟机是否启用了 SSH 服务WinSCP 连接虚拟机需要 SSH 服务在虚拟机中运行。检查 SSH 服务状态：在虚拟机中执行以下命令：sudo systemctl status ssh
如果 SSH 服务未启动：
 systemctl start ssh sudo systemctl enable ssh # 设置开机自启
如果未安装 SSH：
 sudo apt update sudo apt install openssh-server2. 确保虚拟机防火墙未阻止 SSH 端口（22）在虚拟机中执行：sudo ufw allow sshsudo ufw enablesudo ufw status确保状态显示 22/tcp ALLOW。3. 检查宿主机和虚拟机之间的连通性
虚拟机中(linux系统)通过ifconfig查看ens33的inet部分即虚拟机IP
在 宿主机 中 Ping 虚拟机 IP：ping 192.168.160.128(虚拟机 IP)如果 Ping 不通：
检查虚拟机是否正确联网（例如：NAT 或桥接模式）。
检查是否启用了 VMware 的网络适配器。
注意：在ifconfig之后（1）如果只显示lo(lookback接口)是网络配置问题 解决方案 1. 检查虚拟机网络适配器是否启用在 VMware 或 VirtualBox 中：
确保网络适配器已启用。
如果是 VMware，检查设置中是否勾选了 Connect at power on。
2. 重启网络服务在虚拟机内运行以下命令重启网络服务：sudo systemctl restart NetworkManagersudo service networking restart3. 检查网络接口信息ip link show
确保网络接口（例如 eth0、ens33 等）处于 UP 状态。
如果接口显示为 DOWN，可以手动启用：sudo ip link set <interface> up
4. 手动获取 IP 地址尝试使用 dhclient 请求 IP 地址：sudo dhclient <interface>5. 安装和检查驱动确保虚拟机中安装了正确的网络驱动（例如 VMware Tools 或 VirtualBox Guest Additions）。sudo apt-get install open-vm-tools-desktop # VMwaresudo apt-get install virtualbox-guest-dkms # VirtualBox个人是在4. 手动获取 IP 地址  这个方法解决（2）如果只有Ipv6地址，需要请求DHCP重新分配Ipv4ifconfig 的输出结果显示 ens33 网络接口只展示了 IPv6 地址，而没有显示 IPv4 地址。可能是由于网络配置不当或 DHCP（动态主机配置协议）没有成功分配 IPv4 地址。原因分析
未获取到 DHCP 分配的 IPv4 地址：虚拟机的网络适配器配置成了 DHCP 自动获取 IP，但没有成功分配 IPv4 地址。
虚拟机的网络设置有误：可能虚拟机的网络模式（如 NAT、桥接模式等）配置错误。
NetworkManager 或网络服务未正确启动：网络管理服务未能正常工作，导致网络接口没有获取到 IPv4 地址。
解决方案1. 重新请求 DHCP 获取 IPv4 地址在虚拟机中，尝试重新请求 DHCP 分配 IP 地址。sudo dhclient ens33执行完后，再次运行 ifconfig 查看是否有 IPv4 地址。2. 检查虚拟机的网络模式
如你使用 VMware 或 VirtualBox，确保虚拟机的网络模式配置正确：
NAT：虚拟机可以通过主机的网络访问外网。
桥接模式（Bridged）：虚拟机直接连接到物理网络，与主机在同一网段。
修改网络设置后，重启虚拟机的网络服务或重启虚拟机。3. 重启网络服务尝试重启虚拟机的网络服务：sudo systemctl restart NetworkManager或者：sudo service networking restart

无法通过WinSCP连接CentOS
1. 检查SSH服务
确保SSH服务正在运行。你可以通过以下命令来检查SSH服务的状态：
sudo systemctl status sshd
如果服务没有运行，你可以使用以下命令启动它：
sudo systemctl start sshd
2. 检查防火墙设置
确保防火墙允许SSH连接。在CentOS上，你可以使用firewalld或iptables来管理防火墙规则。
使用firewalld:
sudo firewall-cmd --permanent --zone=public --add-service=ssh
sudo firewall-cmd --reload
使用iptables:
sudo iptables -I INPUT -p tcp --dport 22 -j ACCEPT
sudo service iptables save
3. 检查SELinux状态
SELinux（Security-Enhanced Linux）可能会阻止某些网络连接。你可以暂时设置SELinux为宽容模式来测试是否是SELinux导致的问题：
sudo setenforce 0
如果这样做解决了问题，你需要调整SELinux的策略而不是永久禁用它。例如，你可以为SSH服务设置适当的类型：
sudo restorecon -Rv /var/lib/sshd/
4. 检查SSH配置文件
检查SSH的配置文件（通常位于/etc/ssh/sshd_config），确保配置没有错误，特别是关于监听地址和端口的部分。例如，确保没有将监听地址错误地设置为127.0.0.1。
# 查看监听地址和端口
grep -i listen /etc/ssh/sshd_config
5. 检查WinSCP设置
确保在WinSCP中使用的连接信息（如主机名、端口、用户名和密码）是正确的。默认SSH端口是22。
6. 日志文件分析
查看SSH日志文件，这可以帮助你发现连接失败的具体原因。日志文件通常位于/var/log/secure或/var/log/auth.log。
sudo tail -f /var/log/secure
或者对于较新的系统：
sudo tail -f /var/log/auth.log
7. 测试SSH连接
在命令行中尝试使用SSH命令来测试连接：
ssh username@your_server_ip

Centos 乱码
在 CentOS 系统中遇到乱码问题，通常是因为字符编码设置不正确或者终端环境没有正确配置。下面是一些解决 CentOS 乱码问题的常见方法：
1. 配置终端的字符编码
使用 locale 命令
查看当前系统支持的 locale 设置
locale -a
查看当前 locale 设置
locale
设置 locale
如果你发现使用的是 C 或者其他非中文编码，你可以设置为 zh_CN.UTF-8。首先，你需要确保系统中安装了对应的语言包。
sudo yum install glibc-common
sudo localedef -c -f UTF-8 -i zh_CN zh_CN.utf8
然后，设置环境变量：
export LANG=zh_CN.UTF-8
export LC_ALL=zh_CN.UTF-8
为了使这些设置永久生效，可以将上述 export 命令添加到你的 ~/.bashrc 或 ~/.bash_profile 文件中。
重新登录或重新启动终端
修改环境变量后，重新登录或重新启动你的终端，以确保设置生效。
2. 配置终端模拟器（如 GNOME Terminal, Konsole, xterm 等）
打开终端设置
在终端中，通常可以通过右键点击终端窗口选择“Preferences”或“Edit Profile”来打开设置。
更改字符编码
在“Encoding”或“Character Encoding”选项中，选择“UTF-8”。
保存并关闭设置
应用更改并关闭设置窗口。
3. 检查并修复文件内容的编码
如果乱码出现在特定文件中（如文本文件或代码文件），可能需要转换文件的编码。可以使用 iconv 工具来转换文件编码：
iconv -f [原编码] -t utf-8 [原文件] -o [新文件]
例如，将 GBK 编码的文件转换为 UTF-8：
iconv -f GBK -t utf-8 original_file.txt -o new_file.txt
4. 检查和安装语言包（可选）
如果你的系统缺少特定的语言包，也可能导致乱码问题。你可以通过以下命令安装中文语言包：
sudo yum install glibc-langpack-zh_CN
按照这些步骤操作后，大多数乱码问题应该能得到解决。如果问题仍然存在，请检查是否有其他配置或软件特定的问题。


基于加固App，过App的root检测、frida检测等App安全检测(通用解决方案)
常用命令，如下所示:
adb reboot bootloader
fastboot flashing unlock
fastboot flash recovery twrp.img
fastboot reboot
Windows10/Ubuntu环境安装frida，如下所示:
pip3 install numpy matplotlib
pip3 install frida
pip3 install frida-tools
adb shell ps -Z |findstr "adbd"
frida-ps -U

Help -> Find Action -> Register -> ide.usages.page.size 10000 AS2022以前解除全局搜索限制
Setting->Advanced Settings ->Find/Replace->Maximum number off results to show_channel_urls in Find in Files/Show Usages preview 20000  AS2022之后解除全局搜索限制
Tomcat ->package:mine  过滤当前应用包数据

mkdir bld&cd bld&cmake ..
git config --global user.name
git config --global user.email
git config --global user.name "WaterLow3206"
git config --global user.email "ruin52xl@outlook.com"
git config --global user.name "NilNull818"
git config --global user.email "diaosi.dev@gmail.com"
git config --global user.name "allen.x.6032"
git config --global user.email "allen.x.6032@gmail.com"
git config --system http.sslbackend openssl
git config --system https.sslbackend openssl
git config --global url."https://github.moeyy.xyz/https://github.com".insteadOf https://github.com
git config --global url."https://github.moeyy.xyz/https://github.com/".insteadOf git://github.com/
git config --global url."https://mirrors.ustc.edu.cn/aosp".insteadOf https://android.googlesource.com
git config --global url."https://mirrors.tuna.tsinghua.edu.cn/git/chromiumos".insteadOf https://chromium.googlesource.com
git clone --depth=1 -b master http://github.com/cats-oss/android-gpuimage
git clone  http://github.com/RikkaApps/Riru
git submodule update --init --recursive

Github高级搜索
in:name <关键字> 根据仓库名称搜索仓库。
in:description <关键字>：根据仓库描述搜索仓库。
in:readme <关键字>：根据 README 文件内容搜索仓库。
stars(fork): >(=) <数字> <关键字>：搜索 star 或 fork 数大于（或等于）指定数字的仓库，并包含关键字。
stars(fork): 10..20 <关键词>：搜索 star 或 fork 数在 10 到 20 之间的仓库，并包含关键字。
size:>=5000 <关键词>：搜索仓库大小≥ \geq≥ 5000KB，并包含关键字。
pushed(created):>2023-7-1 <关键字>：搜索更新或创建日期在 2023 年 7 月 1 日之后的仓库，并包含关键字。
license:mit <关键字>：搜索 LICENSE 为 MIT 的仓库，并包含关键字。
language:Go <关键字>：搜索仓库语言为 Go 的仓库，并包含关键字。
user:<用户名> <关键字>：查询某个用户的项目，并包含关键字。
org:<组织名> <关键字>：查询某个组织的项目，并包含关键字。// org:EsotericSoftware
repo:owner/name： 匹配特定仓库名称，例如repo:unique-pure/unique-pure.github.io
is:public/private <关键字>：根据公有或私有仓库搜索，并包含关键字。当然，只有你具有访问权限的私有仓库才可以搜索到。
topic:<关键字>：根据主题搜索仓库。//topic:animations
topics:>5：搜索具有3个以上主题的仓库。
followers:n：根据仓库关注者数量搜索仓库。

rd /s /q %USER_FOLDER%#强制删除文件夹
ftype txtfile=%SystemRoot%\system32\notepad.exe "%1" 
ftype text="E:\Notepad3\Notepad3.exe" %1 修复textfile类型关联打开程序
assoc .gradle=text 关联.gradle为textfile类型
assoc .md=text 
assoc .mjs=text 
assoc .conf=text 
assoc .patch=text 
assoc .props=text 
assoc .properties=text 
assoc .pro=text 
assoc .sh=text 
assoc .mk=text
assoc .h=text
assoc .hpp=text
assoc .c=text
assoc .cpp=text
assoc .js=text
assoc .mjs=text
assoc .ts=text
assoc .py=text
assoc .json=text
assoc .xml=text
assoc .ini=text
assoc .log=text
assoc .java=text
assoc .kt=text
assoc .lua=text
assoc .dart=text
assoc .css=text
assoc .gitmodules=text
assoc .iml=text
assoc .m=text
assoc .mm=text
assoc .cc=text
assoc .swift=text
assoc .manifest=text
assoc .yaml=text

TlbbTools
装备 EquipBase.txt      
装备上的buff StandardImpact.txt
buff说明     equipextraattr.txt
buff的特效  ImpactDirectly.txt
装备图标 WoWLookSkin.scheme.xml       .imageset.xml

win10下vs2008编译32位qt4.8.7
1.1 下载QT4.8.7的source code(qt-everywhere-opensource-src-4.8.7.zip)
1.2 将其解压到目录：D:\Qt4.8.7
1.3 从https://www.microsoft.com/en-us/download/confirmation.aspx?id=6812下载安装DirextX SDK
1.4 编译qt>=4.8需要安装Perl,这里下载的是activeperl版本。http://www.perl.org/get.html
2.1 开始  -> 所有程序 ->Micorsoft Visual Studio 2008->visual studio tools->Visual Studio 命令提示(2008)
2.2 用cd命令 进入D:\Qt4.8.7
2.3 设置如下环境变量：set QTDIR=D:\Qt4.8.7 set QMAKESPEC=win32-msvc2010
2.4  配置编译QT的选项 (可利用configure -hlep命令查看各选项意义，自己选择编译模块) configure -platform win32-msvc2010 -opensource -fast -qt-style-windowsxp -qt-style-windowsvista -no-qt3support -qt-sql-odbc -no-phonon -no-phonon-backend -no-script -no-scripttools -no-multimedia -nomake examples -nomake demos
2.5  使用nmake命令开始编译QT。编译完成后，可执行文件存放于 /bin， 具体的Release,Debug版本的库存放于/lib 目录下
 2.6  注意：编译一个多小时后会报以下错误：platform\DefaultLocalizationStrategy.cpp(327):error C2001：常量中有换行符platform\DefaultLocalizationStrategy.cpp(327):fatal error C1057:宏扩展中遇到意外的文件结束 NMAKE:fatal error U1077:"...(路径)\MSVS10.0\VC\BIN\cl.EXE":返回代码"0x2" Stop. NMAKE:fatal error U1077:"...(路径)\MSVS10.0\VC\BIN\nmake.EXE":返回代码"0x2" Stop. NMAKE:fatal error U1077:"cd":返回代码"0x2" Stop. NMAKE:fatal error U1077:"cd":返回代码"0x2" Stop. 解决方法：打开这个文件：<Qt Dir>\src\3rdparty\webkit\Source\WebCore\platform\DefaultLocalizationStrategy.cpp 按Ctrl+G定位 到 327 行，改为：return WEB_UI_STRING("Look Up \"<selection>\"", "Look Up context menu item with selected word").replace("<selection>",truncatedStringForLookupMenuItem(selectedString)); 注意第一个括号内look up 后的双引号。修改好后使用nmake重新编译。
2.7 预估总编译需要3个小时左右
3.1 把 qmake.cache(和configure.cache)备份到别的地方
3.2 nmake confclean 
3.3 把 qmake.cache(和configure.cache) 复制回原处如果不这样，安装 qt-vs-addin 后进行 Qt Versions 添加路径时将失败。
4.1 运行qt-vs-addin-1.1.11-opensource.exe
4.2  打开VS2010， 选择QT---->QT Options.在QTversions页面点击add, name中输入QT版本的名字，例如4.8.7，path中输入QT所在位置：D:\Qt4.8.74.3  环境变量path中添加D:\Qt4.8.7\bin
4.4 新建QT项目，编译时可能会弹出以下错误：The following error occured: There's no Qt version assigned to this project for platform Win32. Please use the 'change Qt version' feature and choose a valid Qt version for this platform. 解决办法：右键项目solution，选择“Change Solution's QT Version”---->选择当前的QT版本4.8.7。

编译FreePascal和Lazarus
一，准备目录
假设我们准备将整个FreePascal环境安装到D盘的fpc目录下，那么我们需要创建以下几个目录：
d:\fpc_svn\bin
d:\laz_svn
二，准备环境
1，安装SVN客户端TortoiseSVN和中文支持包，下载地址：http://tortoisesvn.net/downloads
2，使用SVN客户端CheckOut以下数据：
SVN URL：http://svn.freepascal.org/svn/fpcbuild/trunk/install/binw32
目录：d:\fpc_svn\bin\i386-win32
SVN URL：http://svn.freepascal.org/svn/fpcbuild/trunk/install/binw64
目录：d:\fpc_svn\bin\x86_64-win64
SVN URL：http://svn.freepascal.org/svn/fpc/trunk
目录：d:\fpc_svn
SVN URL：http://svn.freepascal.org/svn/lazarus/trunk
目录：d:\laz_svn
三，编译FPC
1，下载一个编译器并解压至d:\fpc_svn\bin目录，
   ftp://ftp.freepascal.org/pub/fpc/dist/2.6.2/bootstrap/i386-win32-ppc386.zip
   ftp://ftp.freepascal.org/pub/fpc/dist/2.6.2/bootstrap/x86_64-win64-ppcx64.zip
2，编写一个批处理，用以编译FPC：
@echo on
set myfpc=d:\fpc_svn
set mybin=d:\fpc_svn\bin
set PATH=%mybin%\i386-win32;%PATH%
cd %myfpc%
rd /s /q  %myfpc%\examples
make clean all install INSTALL_PREFIX=%myfpc% PP=%mybin%\ppc386.exe DATA2INC=%myfpc%\utils\data2inc.exe
pause
//-----------------------------------------------------------------------------------------------------
@echo on
set myfpc=d:\fpc_svn
set mybin=d:\fpc_svn\bin
set PATH=%mybin%\x86_64-win64;%PATH%
cd %myfpc%
rd /s /q %myfpc%\examples
make clean all install INSTALL_PREFIX=%myfpc% PP=%mybin%\ppcx64.exe DATA2INC=%myfpc%\utils\data2inc.exe
pause
3，将上面的命令保存为一个makefpcwin32.bat文件并运行，得到FPC的编译环境。
   打开cmd窗口:
   cd d:\fpc_svn
   makefpcwin32          //makefpcwin64
4，在命令行中运行以下命令，生成fpc.cfg文件：
   cd /d d:\fpc_svn\bin\i386-win32    //cd /d d:\fpc_svn\bin\x86_64-win64
   fpcmkcfg -d basepath=d:\fpc_svn -o .\fpc.cfg
四，编译Lazarus
   完成第三步后已经有一个FPC的编译环境了，我们还需要编译一个IDE环境：Lazarus。
1，编写一个批处理，用以编译Lazarus
@echo on
set myfpc=d:\fpc_svn
set mybin=d:\fpc_svn\bin
set PATH=%mybin%\i386-win32;%PATH%
cd d:\laz_svn
make clean all OPT="-glw2"
pause
//--------------------------------------------------------------------------------------------------------
set myfpc=d:\fpc_svn
set mybin=d:\fpc_svn\bin
set PATH=%mybin%\x86_64-win64;%PATH%
cd d:\laz_svn
make clean all OPT="-glw2"
pause
2，将上面的命令保存为makelazwin32.bat文件并运行，得到FPC的IDE环境Lazarus。
   打开cmd窗口:
   cd d:\fpc_svn
   makelazwin32      //makelazwin64
3，运行d:\laz_svn\lazarus.exe，即可打开IDE。
警告:The FPC source directory "D:\fpc_svn\" does not 
     look correct:
     Found version ..1, expected 2.7.1
   新建目录 d:\fpc_svn\source
   复制 d:\fpc_svn\packages 到d:\fpc_svn\source
   复制 d:\fpc_svn\rtl 到d:\fpc_svn\source  
lazarus目录   D:\laz_svn\
编译器路径    D:\fpc_svn\bin\i386-win32\fpc.exe
FPC源代码目录 D:\fpc_svn\source
Make文件目录  $Path($(CompPath))make.exe
Gdb文件目录   $Path($(CompPath))gdb.exe
注：以上过程完成后得到32位的FPC与Lazarus环境，如果要搭建64位环境的话，将相应代码中i386-win32改为x86_64-win64即可。
win64启动时警告：win64位缺少gdb.exe,SVN未获取64位版本的gdb,暂时不用
win64编译win32时，提示:compiler "D:\fpc_svn\bin\x86_64-win64\fpc.exe
   does not support target i386-win32
   将编译器路径改为 D:\fpc_svn\bin\i386-win32\fpc.exe
-----------------------------------------------------------------------------------------
制造绿色版的Lazarus:
1、在安装目录里建一个新的目录，如：config ，则路径显示为： d:\laz_svn\config 。
2、将目录：C:\Documents and Settings\Administrator\Local Settings\Application Data\lazarus
   下的所有东西都剪切到 d:\laz_svn\config 里。
6、在安装目录里建立一个批处理文件，如： run_lazarus.bat
   D:\laz_svn\startlazarus.exe --pcp=D:\laz_svn\config
7、运行 run_lazarus.bat 


 Linux下安装lazarus及升級到最新SVN方法 
ubuntu:
   sudo apt-get install lazarus
Fedora:
  sudo yum install lazarus
安装后升级到最新的开发版，因为官方是用SVN来管理源代码，所以要安装SVN工具：
ubuntu:
   sudo apt-get install subversion
Fedora:
  sudo yum install subversion
下载lazarus源码：
   svn co http://svn.freepascal.org/svn/lazarus/trunk lazarus
下载fpc源码：
[pre] svn co http://svn.freepascal.org/svn/fpc/trunk fpc
然后编译,编译前还要下载一些库：
sudo apt-get install libgpmg1-dev fakeroot libncurses5-dev build-essential
cd lazarus/tools/install 
./create_fpc_deb.sh fpc  /home/user/fpc 
编译fpc源码及生成deb包，/home/user/fpc源码的路径
完成后会生成一个fpc.tgz和fpc.deb包，如 fpc_2.5.1-101202_i386.deb fpc-2.5.1-101202.tar.gz
安装fpc: 
  sudo dpkg -i fpc_2.5.1-101202_i386.deb
然后cd ../..退出lazars目录下：make clean all
完成后使用./lazarus 打开
进入后到
Environment-&gt;Options
              -&gt;Lazarus directory(default for all projects)
               /home/user/lazarus/
              -&gt;Compiler path(e.g.fpc) 
               /usr/bin/fpc
              -&gt;FPC source directory
               /home/user/fpc/ 
              -&gt;Make path
                /usr/bin/make
              -&gt;Directory for building test projects
                /tmp 
完成后就可以用了！
以后再更新源碼就用：
  svn update fpc
  svn update lazarus
再重新 ./create_fpc_deb.sh fpc  /home/user/fpc  
      sudo dpkg -i fpc_2.5.1-101202_i386.deb
      make clena all
就可以了！Fedora 則要用 create_fpc_rpm.sh 了


pip install -i https://mirrors.ustc.edu.cn/pypi/web/simple pip -U
vim ~/.bashrc
export PATH=~/repo:$PATH
source ~/.bashrc
curl -s https://gitee.com/oschina/repo/raw/fork_flow/repo-py3>repo
sudo mv repo /usr/local/bin/repo
sudo chmod a+x /usr/local/bin/repo
repo init -u git@gitee.com:openharmony/manifest.git -b OpenHarmony-3.2-Release --no-repo-verify
repo sync -c
repo forall -c 'git lfs pull'
1)        安装Anaconda3-5.1.0，并更新conda
        conda update -n base conda
2)        # 创建环境  conda create --name py36 python=3.6
3)        # 进入环境  activate py36
4)        # 检查Python版本，应该返回Python 3.6.X
        python --version
       >> Python 3.6.5
      不在base环境下，可能需要重新安装conda install spyder=3.2.6
5)        conda install tensorflow=1.2.1
         # Python 验证tensorflow是否正常工作
        import tensorflow as tf
        hello = tf.constant('Hello, TensorFlow!')
        sess = tf.Session()
        print(sess.run(hello))
6)        conda install -c conda-forge librosa
7)        conda install Keras=2.1.2
        PATH环境变量
          C: \Anaconda3;
          C:\Anaconda3\Scripts;
          C:\Anaconda3\Library\mingw-w64\bin;
          C:\Anaconda3\Library\usr\bin;
          C:\Anaconda3\Library\bin;
8)     设置Anaconda镜像，加速下载包
        conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/c
        conda config --set show_channel_urls yes
        conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/`
        conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/
        
gcc -c xxx.c 
ar -crv libxxx.a -o xxx.o
gcc -shared -fPIC -o libxxx.so xxx.o
gcc xxx.c -shared -fPIC -o libxxx.so
gcc -E  main.c -o main.i / gcc -E + main.c 预处理
gcc -S main.i  -o main.s / gcc -S main.i 编译
gcc -c main.s -o main.o /  as -c main.s  -o main.o 汇编
gcc  main.o main 链接

NuGet镜像
https://mirrors.huaweicloud.com/repository/nuget/v3/index.json
https://nuget.cnblogs.com/v3/index.json 
https://api.nuget.org/v3/index.json
Git-Mirror镜像
https://gitee.com/mirrors/
Pip镜像
https://pypi.tuna.tsinghua.edu.cn/simple
http://mirrors.aliyun.com/pypi/simple/
https://pypi.mirrors.ustc.edu.cn/simple/
临时使用
pip install package -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com
pip install -r requirements.txt -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com
永久替换
pip config set global.index-url http://mirrors.aliyun.com/pypi/simple/ 
pip config set install.trusted-host mirrors.aliyun.com
Android Maven镜像
maven { url 'https://maven.aliyun.com/repository/xxx' } / central jcenter google gradle-plugin public

cd D:\qemu && D: && qemu-system-x86_64 -enable-kvm -cpu host -m 2048 -device virtio-balloon -device virtio-keyboard -device virtio-tablet -device virtio-net,netdev=net -device virtio-scsi -device virtio-serial  -device virtio-vga -chardev stdio,id=cons -mon chardev=cons -drive if=none,id=hd,file=oasis-20170211.qcow2 -device scsi-hd,drive=hd -netdev user,id=net

Android手机 闪存的格式化+trim 后，数据几乎很难找回来
全自动化任务工具需要root Marcodroid tasker autox.js power automate

ssh-keygen -t rsa -b 4096 -C "allen.x.6032@gmail.com" // 生成ssh密钥
ssh -T git@github.com // 校验ssh密钥
git config --global --list 
git config --global user.name "xx" 
git config --global user.email "x@x.x" 
git config --global https.postBuffer 512m
git config --global https.lowSpeedLimit 0
git config --global https.lowSpeedTime 99
git config --global core.editor emacs #编辑器 windows:"C:\Program Files\Typora\Typora.exe"
git config --global pack.threads 1
git config --global pack.deltaCacheSize 256m
git config --global pack.windowMemory 512m
git config --global https.proxy  http://127.0.0.1:7890
git config --global https.https://github.com.proxy socks5://127.0.0.1:7890
git config --global --unset https.https://github.com.proxy
git config --global --unset https.proxy
git config --global url."https://github.moeyy.xyz/https://github.com/".insteadOf https://github.com
git config --global --unset url.https://github.com/.insteadof
git clone --depth=1 ssh://git@ssh.github.com:443/MeowBoy326/
git fetch --unshallow

// #pragma comment(linker,”/entry:fn”) 修改函数入口为fn()
// #pragma comment( linker, "/subsystem:windows /entry:maincrtstartup")
// #pragma comment(linker, "/subsystem:console /entry:mainCRTStartup") (ANSI)
// #pragma comment(linker, "/subsystem:console /entry:wmainCRTStartuup") (UNICODE)
#pragma comment(linker, "/SUBSYSTEM:WINDOWS")//代码修改运行模式
#pragma comment(linker, "/ENTRY:mainCRTStartup")//代码修改入口函数
VS 常量$(LatestTargetPlatformVersion)$(DefaultPlatformToolset)$(SolutionDir)$(ProjectDir)$(Configuration)$(OutDir)$(ProjectName)$(Platform)$(IntDir)$(MSBuildProjectName)$(IncludePath)$(LibraryPath)
VS 链接-> 命令行 ->其他 \verbose:lib查看链接过程 \utf-8编码支持[#pragma warning (disable:4819)]
VS 链接 -> 清单文件 -> UAC执行级别 /level='requireAdministrator'
VS dumpbin /exports xxx.lib > xxx.txt dumpbin 可以查看 lib 库中的所有导出符号
VS undname ?XXX@XXX@XX undname方便查看未经过编译器处理的函数名
Microsoft.Cpp.Win32.user.props Microsoft.Cpp.x64.user.props VS2010VC++目录
Microsoft.Cpp.MSVC.Toolset.Win32.props Microsoft.Cpp.MSVC.Toolset.x64.props VS2022VC++目录
Windows导出环境变量 set >> evn.reg

Huggingface镜像站hf-mirror.com 大模型下载
pip install -U huggingface_hub hf_transfer
set HF_ENDPOINT=https://hf-mirror.com;set HF_HOME=D:/Work/hf-mirror/.cache/huggingface/hub;set TRANSFORMERS_CACHE=D:/Work/hf-mirror/.cache
huggingface-cli download --resume-download xxx/xx --local-dir xx

gradlew :app:dependencies > app.txt 依赖分析
gradlew app:assembleRelease 模块编译
设置GRADLE_USER_HOME环境变量 修改Gradle默认cache位置
管理员运行cmd， rd /s c:\\$Recycle.Bin  强制清理回收站
dupe:.vs dupe:ipch dupe:.git dupe:.gradle dupe:.idea dupe:gradle-build dupe:*.dir dupe:*.pdb dupe:*.idb dupe:*.exp dupe:*.cxx 
删除 java 注释 /* */：    /\*{1,2}[\s\S]*?\*/
删除 java 注释 //：        //[\s\S]*?\n  （谨慎操作，双斜线后面不一定是注释也会是路径）
删除 xml 注释：             <!-[\s\S]*?-->
删除空白行：               ^\s*\n

D:\android-sdk\ndk\android-ndk-r13b\ndk-build 
D:\crystax-ndk-10.3.2\ndk-build

md/mkdir 创建文件夹
rd/rmdir 删除文件夹
type nul>x.x 创建文件
echo x >x.x 写入文件
Windows环境变量
常用：
%USERPROFILE% =C:\Users\用户名
%SystemRoot% =C:\WINDOWS
%SystemDrive% =C:
%APPDATA% =C:\Users\用户名\AppData\Roaming
%LOCALAPPDATA% =C:\Users\用户名\AppData\Local
%windir% =C:\WINDOWS
%Path% =C:\Windows\system32;C:\Windows; 
%ProgramData% =C:\ProgramData
%ProgramFiles% =C:\Program Files
%ProgramFiles(x86)% =C:\Program Files (x86)
其他：
%ALLUSERSPROFILE% =C:\ProgramData
%CommonProgramFiles% =C:\Program Files\Common Files
%CommonProgramFiles(x86)% =C:\Program Files (x86)\Common Files
%CommonProgramW6432% =C:\Program Files\Common Files
%COMPUTERNAME% =MyPC
%ComSpec% =C:\WINDOWS\system32\cmd.exe
%HOMEDRIVE% =C:
%HOMEPATH% =\Users\用户名
%LOGONSERVER% =\\MicrosoftAccount
%OS% =Windows_NT
%ProgramW6432% =C:\Program Files  
%PUBLIC% =C:\Users\Public 
%TEMP% =C:\Users\用户名\AppData\Local\Temp
%TMP% =C:\Users\用户名\AppData\Local\Temp
%USERDOMAIN% =MyPC 
%USERNAME% =用户名
@echo off
echo 当前盘符：%~d0
echo 当前盘符和路径：%~dp0
echo 当前批处理全路径：%~f0
echo 当前盘符和路径的短文件名格式：%~sdp0
echo 当前CMD默认目录：%cd%
echo 目录中有空格也可以加入""避免找不到路径
echo 当前盘符："%~d0"
echo 当前盘符和路径："%~dp0"
echo 当前批处理全路径："%~f0"
echo 当前盘符和路径的短文件名格式："%~sdp0"
echo 当前CMD默认目录："%cd%"
pause

启用 WSL(方法)
wsl --install
管理员身份打开 PowerShell 工具并运行 
dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart
Windows 10（2004）上启用虚拟机平台
dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart
Windows 10（1903，1909）上启用虚拟机平台
Enable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform -NoRestart
设置 WSL 2 为默认值
wsl --set-default-version 2
将 WSL 1 上的 Ubuntu 转换到 WSL 2
wsl.exe --set-version Ubuntu 2
启用 WSL(简略)
wsl --install
dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart
dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart
wsl --set-default-version 2
下载WSL2更新包
wget https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi
修改Ubuntu20.04安装在位置
Invoke-WebRequest -Uri https://wsldownload.azureedge.net/Ubuntu_2004.2020.424.0_x64.appx -OutFile Ubuntu20.04.appx -UseBasicParsing
Rename-Item .\Ubuntu20.04.appx Ubuntu.zip
Expand-Archive .\Ubuntu.zip -Verbose
cd .\Ubuntu\
.\ubuntu2004.exe

wget https://gitee.com/lin-xi-269/tools/raw/master/os/QHubuntu20.04 && bash QHubuntu20.04
创建文件.wslconfig 
code %UserProfile%\.wslconfig 
修改WSL内存和处理核心增加自动释放内存和缓存文件
[wsl2]
 processors=8
 memory=2GB
 swap=8GB
 localhostForwarding=true
 autoProxy=true
 etworkingMode=mirrored
 #dnsTunneling=true
[experimental] 
 #hostAddressLoopback=true
 autoMemoryReclaim=gradual
 sparseVhd=true
 
wsl -l -o 列出可用在线系统
wsl -l -v 列出已安装系统
wsl --status 检查WSL状态
wsl --update 更新WSL
wsl --set-default xx 设置默认系统
wsl -d xx -u root 指定用户登录
wsl --set-version xx 2/1 修改WSL内核
wsl --export xx xx.tar 导出到tar包
wsl --import xx x:\xx xx.tar 导入tar包
wsl --unregister xx 注销并卸载系统

apt 换源
Debian / Ubuntu 的官方源在国内访问很慢，咱们更换为清华大学 TUNA 的软件源镜像
$ sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak
$ sudo vim /etc/apt/sources.list 
# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse
# 预发布软件源，不建议启用
# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse
$ sudo apt-get update
$ sudo apt-get upgrade
配置SSH服务器
$ sudo service ssh stop
$ sudo /usr/sbin/sshd -d
$ sudo apt purge openssh-server
$ sudo apt install openssh-server
配置 /etc/ssh/sshd_config，用 sudo 权限运行 vim 修改如下三个关键字记得删除
Port 22
# 这两行允许了 root 账户和密码登录
PermitRootLogin yes
PasswordAuthentication yes
$ sudo service ssh restart
$ sudo service ssh status
$ sudo passwd root
安装 Docker-CE
$ curl -skSL https://mirror.azure.cn/repo/install-docker-ce.sh | sh -s -- --mirror AzureChinaCloud
$ sudo service docker start
$ sudo docker version
$ sudo docker run hello-world

scons p=windows optimize=none target=editor
python.exe -m pip install --upgrade pip
git submodule update --init --recursive
mkdir bld&cd bld&cmake -A x64 ..
mkdir bld&cd bld&cmake ..
git checkout -f HEAD

管理员运行cmd， rd /s c:\\$Recycle.Bin  强制清理回收站

gradlew app:dependencies --configuration releaseRuntimeClasspath > dependencies.txt

copy /y $(OutDir)$(TargetFileName) $(Configuration)$(PlatformArchitecture)\lib\$(TargetFileName)

subject='/C=CN/ST=HuNan/L=ChangSha/O=allen/OU=allen/CN=www.inoop.cn/emailAddress=203075064@qq.com'
for x in releasekey platform shared media;
do
  ./development/tools/make_key build/target/product/security/$x "$subject";
done

https://www.peiluming.com/article/2
https://developer.aliyun.com/mirror/debian?spm=a2c6h.13651102.0.0.3e221b11fAkFNB
https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/
https://www.htcp.net/741.html
https://www.cnblogs.com/luoyesiqiu/p/10701419.html
http://www.gaohaiyan.com/3747.html
https://blog.csdn.net/qq_38844263/article/details/82153695
 https://blog.csdn.net/CrazyTracer/article/details/130329855
https://www.6hu.cc/archives/144932.html
http://www.debuglive.cn/article/1091666763961073664
https://www.yii666.com/blog/447194.html
https://blog.csdn.net/ymxkybqw/article/details/100678617
https://www.jianshu.com/p/0c1d07bfc45b
https://blog.csdn.net/Qwertyuiop2016/article/details/130476079
https://github.com/rev1si0n?tab=repositories
https://github.com/rev1si0n/bxxt
https://github.com/rev1si0n/android_kernel_oneplus_msm8998
https://github.com/LineageOS/android_kernel_oneplus_msm8998
https://github.com/LineageOS/android_device_oneplus_msm8998-common
https://github.com/LineageOS/android_device_oneplus_cheeseburger
https://github.com/LineageOS/android_hardware_oplus
https://github.com/LineageOS/android_hardware_lineage_interfaces
https://blog.csdn.net/qq_36059308/article/details/124785050
https://download.lineageos.org/devices/cheeseburger/builds
https://www.htcp.net/5016.html
https://github.com/tiann/KernelSU
https://www.htcp.net/741.html

https://gh-proxy.com/https://raw.githubusercontent.com/mfuu/v2ray/master/v2ray
https://gh-proxy.com/https://raw.githubusercontent.com/aiboboxx/v2rayfree/main/v2
https://gh-proxy.com/https://raw.githubusercontent.com/freev2/free/main/v2
https://gh-proxy.com/https://raw.githubusercontent.com/adiwzx/freenode/main/adispeed.txt
https://gh-proxy.com/https://raw.githubusercontent.com/ermaozi01/free_clash_vpn/main/subscribe/v2ray.txt
https://gh-proxy.com/https://raw.githubusercontent.com/ermaozi/get_subscribe/main/subscribe/v2ray.txt
https://gh-proxy.com/https://raw.githubusercontent.com/a2470982985/getNode/main/v2ray.txt
https://gh-proxy.com/https://raw.githubusercontent.com/codingbox/Free-Node-Merge/main/node.txt
https://gh-proxy.com/https://raw.githubusercontent.com/ZywChannel/free/main/sub
https://gh-proxy.com/https://raw.githubusercontent.com/ts-sf/fly/main/v2

https://ffmpeg.xianwaizhiyin.net/compile-ffmpeg/static.html[FFmpeg静态编译—FFmpeg编译教程]
https://www.cnblogs.com/bigben0123/p/12643839.html[跨平台：GN实践详解（ninja, 编译, windows/mac/android实战）]
https://zhuanlan.zhihu.com/p/707298876[在windows上编译ffmpeg]
https://www.gyan.dev/ffmpeg/builds/[FFmpeg Build binaries for Windows]
https://blog.csdn.net/cpp_learner/article/details/142345860[Windows环境 源码编译 FFmpeg]

cast from pointer to smaller type 'XX' (aka 'XX') loses information 
(XX)(size_t)?


VS2015下解决:无法解析的外部符号 __imp___vsnprintf 及__iob_func
1、解决:无法解析的外部符号 __imp___vsnprintf
在 vs2015 工程选项，链接器附加依赖项里面添加 legacy_stdio_definitions.lib 即可。
出现这个问题的原因是 vs2015 默认编译时将许多标准库采用内联方式处理，因而没有可以链接的标准库文件，所以要专门添加标准库文件来链接标准库中的函数。
2、解决:无法解析的外部符号__iob_func
在使用 VS2015 下使用 libjpeg-turbo 静态库，编译时报错了：
error LNK2019: 无法解析的外部符号 __iob_func，该符号在函数 output_message 中被引用
根据关键字在网上找到一些文章描述了类似的错误，大都是找不到外部符号 __iob ,原因是VS2010上使用了 VC6 编译的 DLL 。虽然与我的情况不同，但是原理是一样的，我遇到的这个问题的原因是 VS2015 下使用VS2010编译的静态库，因为我用的libjpeg-turbo静态库是从官网下载编译好的版本(应该是vs2010这样的版本编译的)。
其实 __iob_func 和 __iob 都是用来定义 stdin,stdout,stderr，只是不同的VC版本实现方式不同。
下面是VS2015的头文件corecrt_wstdio.h中对stdin,stdout,stderr定义
ACRTIMP_ALT FILE* __cdecl __acrt_iob_func(unsigned);
#define stdin  (__acrt_iob_func(0))
#define stdout (__acrt_iob_func(1))
#define stderr (__acrt_iob_func(2))
原来在 VS2015 中 __iob_func 改成了 __acrt_iob_func ,所以我参照《【LNK2019】 无法解析的外部符号 __iob》这篇文章的方法在自己的代码中增加了一个名为 __iob_func 转换函数：
/*
 * 当libjpeg-turbo为vs2010编译时，vs2015下静态链接libjpeg-turbo会链接出错:找不到__iob_func,
 * 增加__iob_func到__acrt_iob_func的转换函数解决此问题,
 * 当libjpeg-turbo用vs2015编译时，不需要此补丁文件
 */
#if _MSC_VER>=1900
#include "stdio.h" 
_ACRTIMP_ALT FILE* __cdecl __acrt_iob_func(unsigned); 
#ifdef __cplusplus 
extern "C" 
#endif 
FILE* __cdecl __iob_func(unsigned i) { 
    return __acrt_iob_func(i); 
}

snprintf重定义
#endif /* _MSC_VER>=1900 */
#if _MSC_VER>=1900
#  define STDC99
#endif
#if defined(_MSC_VER)&& _MSC_VER <1500
#ifndef snprintf
#define snprintf _snprintf
#endif
#endif

sol2 no member named 'construct' in 'optional<type-parameter-0-0 &>'
// this->construct(std::forward<Args>(args)...);
new (static_cast<void*>(this)) optional(std::in_place, std::forward<Args>(args)...);
return **this;

#pragma comment(lib, "comctl32.lib")
#ifdef _UNICODE
#if defined _M_IX86
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='x86' publicKeyToken='6595b64144ccf1df' language='*'\"")
#elif defined _M_X64
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='amd64' publicKeyToken='6595b64144ccf1df' language='*'\"")
#else
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
#endif
#endif

#ifdef _WIN64
#define GWL_WNDPROC GWLP_WNDPROC
#define GWL_HINSTANCE GWLP_HINSTANCE
// #define GWL_HINSTANCE (-6)
#endif

gcc将 VC++ (Visual C++) 风格的 manifest 文件嵌入到生成的 EXE 或 DLL 中
为什么需要 Manifest 文件
Manifest 文件通常用于指定应用程序所需的运行时库版本，例如 CRT (C Runtime Library) 的版本。这在混合使用不同版本的运行时库时尤为重要，比如在同一个应用程序中使用了由不同编译器编译的代码模块。
如何生成 Manifest 文件
手动创建 Manifest 文件：你可以手动创建一个 XML 格式的 manifest 文件，例如 MyApp.exe.manifest。
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <assemblyIdentity version="1.0.0.0"
                processorArchitecture="x86"
                name="CompanyName.ProductName"
                type="win32"/>
  <description>My Application</description>
  <dependency>
    <dependentAssembly>
      <assemblyIdentity
          type="win32"
          name="Microsoft.Windows.Common-Controls"
          version="6.0.0.0"
          processorArchitecture="x86"
          publicKeyToken="6595b64144ccf1df"
          language="*"
      />
    </dependentAssembly>
  </dependency>
</assembly>
使用 Linker 选项自动生成：在 GCC 的 MinGW 或类似工具链中，你可以通过链接器选项来自动生成 manifest 文件。
使用 -Wl,--enable-auto-import 和 -Wl,--enable-auto-image-base 选项可以自动处理导入库和基本地址。对于 manifest，可以使用 -Wl,--enable-runtime-pseudo-reloc 选项。例如：
gcc -o MyApp.exe MyApp.o -lmsvcrt -Wl,--enable-auto-import,--enable-auto-image-base,--enable-runtime-pseudo-reloc -Wl,--manifest,MyApp.exe.manifest
这会将生成的 manifest 文件嵌入到 EXE 中。
使用 mt 工具嵌入 Manifest
如果你更喜欢显式地控制 manifest 的嵌入，可以使用 Microsoft 的 mt.exe 工具（随 Visual Studio 或 Windows SDK 一起提供）。例如：
mt.exe -manifest MyApp.exe.manifest -outputresource:MyApp.exe;1
这个命令会将 MyApp.exe.manifest 嵌入到 MyApp.exe 中。

mingw-gcc 编译出有 win10 风格的 win32 程序
入口函数源文件加上
[[
#if defined _M_IX86  
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='x86' publicKeyToken='6595b64144ccf1df' language='*'\"")  
#elif defined _M_X64  
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='amd64' publicKeyToken='6595b64144ccf1df' language='*'\"")  
#else  
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")  
#endif 
]]
然后在程序输出目录下建一个 " 程序名.exe.manifest“ 的文件
[[
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
  <assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <assemblyIdentity
  name="Microsoft.Windows.XXXX"
  processorArchitecture="amd64"
  version="5.1.0.0"
  type="win32"/>
  <description>Windows Shell</description>
  <dependency>
  <dependentAssembly>
  <assemblyIdentity
  type="win32"
  name="Microsoft.Windows.Common-Controls"
  version="6.0.0.0"
  processorArchitecture="amd64"
  publicKeyToken="6595b64144ccf1df"
  language="*"
   />
  </dependentAssembly>
  </dependency>
  </assembly>
]]
这是 amd64
processorArchitecture="amd64"
如果是 x86 就改成 x86


c99版本getline()函数实现
#include <stdio.h>
#include <stdlib.h>
static ssize_t static_my_getline(char **lineptr, size_t *n, FILE *stream) {
    if (lineptr == NULL || n == NULL || stream == NULL) {
        return -1;  // 无效参数检查
    }
    size_t capacity = *n;  // 当前缓冲区大小
    size_t length = 0;     // 当前已读取的字符数
    int c;
    // 如果给定的缓冲区大小为 0 或指针为 NULL，则分配初始内存
    if (capacity == 0) {
        capacity = 128;  // 默认分配 128 字节的内存
        *lineptr = (char *)malloc(capacity);
        if (*lineptr == NULL) {
            return -1;  // 内存分配失败
        }
    }
    // 逐个字符读取直到换行符或者文件结束符
    while ((c = fgetc(stream)) != EOF) {
        // 如果当前字符是换行符，停止读取
        if (c == '\n') {
            break;
        }
        // 检查当前缓冲区是否足够存储读取的字符
        if (length + 1 >= capacity) {
            capacity *= 2;  // 扩展内存
            *lineptr = (char *)realloc(*lineptr, capacity);
            if (*lineptr == NULL) {
                return -1;  // 内存重新分配失败
            }
        }
        // 将当前字符存储到缓冲区
        (*lineptr)[length++] = (char)c;
    }
    // 如果没有读取到任何字符并且文件结束，则返回 -1
    if (length == 0 && c == EOF) {
        return -1;
    }
    // 添加字符串结束符
    (*lineptr)[length] = '\0';
    // 更新缓冲区大小
    *n = capacity;
    return length;
}
int main() {
    char *line = NULL;
    size_t len = 0;
    printf("Enter a line of text (Ctrl+D to end):\n");
    // 使用自定义的 my_getline 函数读取输入
    while (my_getline(&line, &len, stdin) != -1) {
        printf("You entered: %s", line);
    }
    // 释放内存
    free(line);
    return 0;
}


strndup函数实现
char* strndup(const char* str, size_t n) {
    char* ret = (char*)malloc(n + 1);
    if (ret == NULL) return NULL;
    memcpy(ret, str, n);
    ret[n] = '\0'; // 确保字符串以null结尾
    return ret;
}

drand48函数实现
#ifndef DRAND48_H  
#define DRAND48_H  
#include <stdlib.h>  
#define m 0x100000000LL  
#define c 0xB16  
#define a 0x5DEECE66DLL  
static unsigned long long seed = 1;  
double drand48(void)  
{  
    seed = (a * seed + c) & 0xFFFFFFFFFFFFLL;  
    unsigned int x = seed >> 16;  
    return  ((double)x / (double)m);  
}  
void srand48(unsigned int i)  
{  
    seed  = (((long long int)i) << 16) | rand();  
}  
#endif

#define _USE_MATH_DEFINES
#include <math.h>
//#include <cmath>
// #include <algorithm>
#ifndef M_PI
#define M_PI       3.14159265358979323846
#define M_PI_2     1.57079632679489661923
#define M_PI_4     0.785398163397448309616
#define M_1_PI     0.318309886183790671538
#define M_2_PI     0.636619772367581343076
#define M_2_SQRTPI 1.12837916709551257390
#define M_SQRT2    1.41421356237309504880
#define M_SQRT1_2  0.707106781186547524401
#endif

non-const lvalue reference to type 'xxx' cannot bind to a  temporary of type 'xxx'
1. 对于base& ref3 = base();
改为const base& ref3 = base();后此行代码编译通过
C++11标准中引入了右值引用，临时变量属于右值，所以也可以写成：
base&& ref3 = base();
2. 对于base* p1 = &base();
编译器报错：error: taking address of temporary [-fpermissive]|
即标准C++禁止对临时变量取地址操作。
将此行注释掉，编译通过。

实现gguf量化模型的配置参数设置以及cpu+gpu的混合推理
好的，用户想实现GGUF量化模型的配置参数设置以及CPU+GPU的混合推理。首先，我需要确认GGUF是什么。GGUF是GGML的新版本格式，用于量化模型，通常与llama.cpp一起使用。用户可能在使用像Llama这样的模型，并希望优化推理速度，同时利用CPU和GPU资源。
接下来，配置参数设置。我需要回忆llama.cpp支持的参数，比如模型路径、线程数、上下文长度、批处理大小等。混合推理可能涉及到将部分计算分配给GPU，比如使用CUDA或Metal后端，而CPU处理其他部分。需要确保用户安装了正确版本的llama.cpp，支持GPU加速。
然后，混合推理的具体实现。在llama.cpp中，通常通过指定层数分配到GPU，比如--n-gpu-layers 20。这需要用户有支持的GPU和相应的BLAS库，比如CUDA或OpenCL。同时，CPU线程的设置也会影响性能，需要合理分配线程数，可能将部分线程用于处理非GPU层。
用户可能遇到的问题包括安装错误、GPU层数设置不当导致的性能问题，或者内存不足。需要提醒用户根据GPU显存调整层数，并监控资源使用情况。此外，不同的量化版本（如Q4_K_M）会影响模型精度和速度，需要权衡选择。
最后，示例代码部分需要展示如何加载模型、设置参数，并执行推理。可能需要使用llama-cpp-python库，并确保其版本支持GPU。还要注意提示用户安装正确的依赖项，如cuBLAS或Metal。
总结步骤：安装依赖，配置模型参数（线程、GPU层数、量化类型），编写推理代码，处理输入和输出，优化建议。需要检查所有参数的正确性，并确保用户了解如何根据自身硬件调整参数。
以下是关于GGUF量化模型配置及CPU+GPU混合推理的详细指南，基于llama.cpp框架实现：
1. 环境准备
1.1 安装依赖
bash
复制代码
# 编译支持GPU的llama.cpp
git clone https://github.com/ggerganov/llama.cpp && cd llama.cpp
make LLAMA_CUBLAS=1  # NVIDIA GPU
# 或
make LLAMA_METAL=1   # Apple M系列芯片
1.2 Python包安装
bash
复制代码
pip install llama-cpp-python[server] --force-reinstall --upgrade --no-cache-dir
# 指定CUDA版本
CMAKE_ARGS="-DLLAMA_CUBLAS=on" pip install llama-cpp-python
2. GGUF模型配置参数
2.1 核心参数说明
python
复制代码
from llama_cpp import Llama
llm = Llama(
    model_path="mistral-7b-v0.1.Q4_K_M.gguf",  # GGUF模型路径
    n_ctx=4096,           # 上下文长度（最大支持4096）
    n_threads=8,          # CPU线程数（物理核心数）
    n_gpu_layers=35,      # 分配到GPU的层数（根据显存调整）
    n_batch=512,          # 批处理大小（提升吞吐量）
    offload_kqv=True,     # 将注意力计算保留在GPU
    main_gpu=0,           # 多GPU时选择主卡
    seed=42,              # 随机种子
    verbose=True          # 显示调试信息
)
3. 混合推理实现
3.1 硬件资源分配策略
GPU优先：通过n_gpu_layers将Transformer层卸载到GPU
CPU辅助：处理剩余计算和内存管理
显存优化：根据显存容量调整卸载层数：
8GB显存：约20-25层
24GB显存：可卸载全部40+层
3.2 性能优化参数
python
复制代码
# 高级配置示例
llm = Llama(
    ...
    n_threads=6,          # 物理核心数（非超线程）
    n_gpu_layers=28,      # RTX 3090 24GB设置
    tensor_split=[0.5,0.5], # 多GPU显存分配比例
    mul_mat_q=True,       # 启用矩阵乘法优化
    rms_norm_eps=1e-6,    # 数值稳定性参数
    flash_attn=True       # 启用FlashAttention加速
)
4. 推理示例
4.1 基础文本生成
python
复制代码
prompt = "如何制作法式薄饼？"
output = llm.create_completion(
    prompt,
    max_tokens=256,
    temperature=0.7,
    top_p=0.95,
    repeat_penalty=1.1,
    stream=True
)
for chunk in output:
    print(chunk["choices"][0]["text"], end="", flush=True)
4.2 流式输出配置
python
复制代码
response = llm(
    prompt,
    stream=True,
    stop=["\n##", "<|endoftext|>"],
    frequency_penalty=0.9,
    presence_penalty=0.8
)
5. 性能监控与调优
5.1 基准测试命令
bash
复制代码
./main -m model.gguf -n 128 -p "巴黎是" -ngl 25 -t 8 -c 2048 -b 512 --temp 0.7
5.2 关键性能指标
指标	预期值	监控方法
Tokens/s	>20 tokens/s	llama.cpp内置统计
GPU利用率	>85%	nvidia-smi / ROCm
内存占用	<90%	htop / sysmon
推理延迟	<200ms/token	时间戳测量
6. 常见问题解决
6.1 CUDA内存不足
python
复制代码
# 减少GPU卸载层数
n_gpu_layers=20
# 启用内存优化
llm = Llama(..., vocab_only=True, use_mmap=True)
6.2 性能瓶颈分析
bash
复制代码
# 查看各层执行设备
export LLAMA_DEBUG=1
./main ... 2>&1 | grep -E 'llm_load_tensors|llama_graph_compute'
7. 高级配置参考
python
复制代码
# 多GPU负载均衡
llm = Llama(
    ...
    tensor_split=[0.7, 0.3],  # GPU0:70%, GPU1:30%
    n_gpu_layers=40,
    offload_kqv=False,
    numa=True  # 启用NUMA优化
)
# 量化参数优化
llm.set_cache(
    type="f16",       # 缓存精度
    size=2048,        # 缓存槽位
    freq_base=10000,
    freq_scale=0.5
)
建议根据具体硬件配置调整参数，使用nvidia-smi和htop实时监控资源使用情况。不同量化版本（Q2_K, Q4_0, Q5_K_M）需进行精度-速度权衡测试。


BlackDex大法，是如何运作的？
0x1 前言
在现阶段Android环境下，开发者为了保护自身APP不被反编译以及逻辑的解读、应用重打包，许多开发者都会选择对APP进行加固，APP经过加固，一定程度上保护了APP，使APP没那么容易被反编译。当然，有加固技术的出现，也会有反加固技术的出现，即本文要分析的一种反加固的原理。
0x2 BlackDex
BlackDex是一个运行在Android手机上的脱壳工具，支持5.0～12，无需依赖任何环境任何手机都可以使用，包括模拟器。只需几秒，即可对已安装包括未安装的APK进行脱壳。
项目开源地址：https://github.com/CodingGay/BlackDex
本项目现仅供参考，因开源的原因，已经被许多加固厂商Anti，点到为止，现已停止维护。
0x3 前置知识
本项目涉及知识点，按照重要程度排序
Android 虚拟化技术
Android Dex加载原理
Android DexFile结构
Android Hook
总结
BlackDex核心原理是利用虚拟化技术，使APP进程运行，让加固壳进行自解密，最后完成DexFile的Dump，得益于依赖于虚拟化技术，不需要任何手机拥有任何逆向环境，甚至连APP都不用安装到手机上就可以进行脱壳。
BlackDex大法，是如何运作的？启动篇
0x1 前言
前篇 说到，BlackDex是基于虚拟化技术进行的，本项目实际上是基于 BlackBox 的基础下进行开发，很可惜的是由于某些原因此项目没能继续下去。
本系列将选定发表时最后的提交，朋友们可以Clone下来跟着本文走：https://github.com/CodingGay/BlackDex/tree/5580fa8f5d658afae4eb667f8c8d6632be5b9aaf
0x2 启动
本文主要分析如何从点击BlackDex图标之后，是如何进行启动APP的进程，此处不会过度深究虚拟化的实现过程，有机会更完这个系列之后会再出一系列虚拟化技术的文章。
核心启动dump方法：top.niunaijun.blackbox.BlackDexCore#dumpDex(java.lang.String)
public InstallResult dumpDex(String packageName) {
        // 将软件安装至BlackBox中
        InstallResult installResult = BlackBoxCore.get().installPackage(packageName);
        if (installResult.success) {
            // 安装成功则启动，否则卸载并且返回失败。
            boolean b = BlackBoxCore.get().launchApk(packageName);
            if (!b) {
                BlackBoxCore.get().uninstallPackage(installResult.packageName);
                return null;
            }
            return installResult;
        } else {
            return null;
        }
    }
两步事情：
将软件安装至BlackBox
如果安装成功则启动，不成功则返回失败
内部实现原理涉及虚拟化相关知识，此处不多深究，应用启动时，程序感知到的第一个方法就是Application#attachBaseContext，在虚拟环境内也是一样的，在经过一系列调度后。我们直接跟进到虚拟化进程的启动的方法：top.niunaijun.blackbox.app.BActivityThread#handleBindApplication
此函数比较长，代码内注释逐步解析
    private synchronized void handleBindApplication(String packageName, String processName) {
        // 初始化Dump的返回的信息
        DumpResult result = new DumpResult();
        result.packageName = packageName;
        result.dir = new File(BlackBoxCore.get().getDexDumpDir(), packageName).getAbsolutePath();
        try {
            // 以下是获取需要多开应用的信息，然后对当前进程进行重新设置，因为本进程信息是宿主的。
            PackageInfo packageInfo = BlackBoxCore.getBPackageManager().getPackageInfo(packageName, PackageManager.GET_PROVIDERS, BActivityThread.getUserId());
            if (packageInfo == null)
                return;
            .........
            // 以上省略部分虚拟化的代码。
            // 此处清除dump目录，防止多次脱壳的dex文件乱窜
            // clear dump file
            FileUtils.deleteDir(new File(BlackBoxCore.get().getDexDumpDir(), packageName));
            // 初始化native层代码
            VMCore.init(Build.VERSION.SDK_INT);
            // 启用IO重定向，支持虚拟应用运行环境
            IOCore.get().enableRedirect(packageContext);
            ......
            // 以上省略部分虚拟化代码
            // 反射LoadedApk获取多开应用的classloader，并且反射LoadedApk#makeApplication函数，makeApplication中会初始化Application，调用其attachBaseContext、onCreate函数，完成Application的初始化。
            try {
                ClassLoader call = LoadedApk.getClassloader.call(loadedApk);
                application = LoadedApk.makeApplication.call(loadedApk, false, null);
            } catch (Throwable e) {
                Slog.e(TAG, "Unable to makeApplication");
                e.printStackTrace();
            }
            // 如果走到此处没有发生异常，说明Application已经完成启动，一般在这种时候从理论上来说，应用已经运行起来了，那么自然加固也已经解密完成，我们接下来进行核心的dex的dump工作。
            if (Objects.equals(packageName, processName)) {
                ClassLoader loader;
                // 此处获取需要脱壳的app的classloader
                if (application == null) {
                    loader = LoadedApk.getClassloader.call(loadedApk);
                } else {
                    // 实际上走到这里，理论是启动失败了。不过还可以挣扎一下。
                    loader = application.getClassLoader();
                }
                // 调用核心DumpDex方法，进行dex的dump工作
                handleDumpDex(packageName, result, loader);
            }
        } catch (Throwable e) {
            // 如果发生异常，通知UI并且从BlackBox中卸载该应用
            e.printStackTrace();
            mAppConfig = null;
            BlackBoxCore.getBDumpManager().noticeMonitor(result.dumpError(e.getMessage()));
            BlackBoxCore.get().uninstallPackage(packageName);
        }
    }
其实从上述代码分析下来，整体的流程已经非常的顺畅了，汇总整理一下
使用虚拟化技术将应用运行起来，初始化Application。
一般来说，基本上99%的加固整体工作在Application已经完成，所以此时应用真实的Dex文件已经被解密释放并且加载到内存中。
在启动成功后，调用handleDumpDex核心方法进行dex的dump工作，即可达到脱壳的目的。
本系列将慢慢梳理每一个流程，本篇讲了BlackDex是如何启动且执行脱壳的，剩下的在后续的文章內继续深扒。
BlackDex大法，是如何运作的？Dump
书接上回
想要了解如何dump出Dex，就要先了解Dex文件是如何加载进内存的。上文说到Application是通过LoadedApk#makeApplication完成的，那么我们看下相关实现。
本文源码为：android11_r1
系统源码：android.app.LoadedApk#makeApplication
    @UnsupportedAppUsage
    public Application makeApplication(boolean forceDefaultAppClass,
            Instrumentation instrumentation) {
        if (mApplication != null) {
            return mApplication;
        }
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "makeApplication");
        Application app = null;
        String appClass = mApplicationInfo.className;
        if (forceDefaultAppClass || (appClass == null)) {
            appClass = "android.app.Application";
        }
        try {
            // 获取App的classloader
            final java.lang.ClassLoader cl = getClassLoader();
            if (!mPackageName.equals("android")) {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,
                        "initializeJavaContextClassLoader");
                initializeJavaContextClassLoader();
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            }
            .........省略
            // 内部通过classloader.findClass(appClass)，并且进行实例化Application。
            app = mActivityThread.mInstrumentation.newApplication(
                    cl, appClass, appContext);
        } catch (Exception e) {
            if (!mActivityThread.mInstrumentation.onException(app, e)) {
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                throw new RuntimeException(
                    "Unable to instantiate application " + appClass
                    + ": " + e.toString(), e);
            }
        }
        .........省略
        return app;
    }
getClassLoader内部流程过于复杂，感兴趣的自己去跟一下，简单点概括：根据ApplicationInfo中的信息，最终生成并返回PathClassloader
通过Classloader可以findClass我们Dex中的方法，由此可以看出，Classloader跟我们Dex是存在某种关系的。我们看一下PathClassloader是如何对Dex文件进行加载的。
源码：dalvik.system.PathClassLoader
public class PathClassLoader extends BaseDexClassLoader {
    public PathClassLoader(String dexPath, ClassLoader parent) {
        super(dexPath, null, null, parent);
    }
    public PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) {
        super(dexPath, null, librarySearchPath, parent);
    }
    public PathClassLoader(
            String dexPath, String librarySearchPath, ClassLoader parent,
            ClassLoader[] sharedLibraryLoaders) {
        super(dexPath, librarySearchPath, parent, sharedLibraryLoaders);
    }
}
可以看到都是调用父类BaseClassloader的构造方法，我们主要关注参数dexPath参数，看他是如何打开我们的Dex文件。
源码：dalvik.system.BaseDexClassLoader
    public BaseDexClassLoader(String dexPath,
            String librarySearchPath, ClassLoader parent, ClassLoader[] sharedLibraryLoaders,
            boolean isTrusted) {
        super(parent);
        // Setup shared libraries before creating the path list. ART relies on the class loader
        // hierarchy being finalized before loading dex files.
        this.sharedLibraryLoaders = sharedLibraryLoaders == null
                ? null
                : Arrays.copyOf(sharedLibraryLoaders, sharedLibraryLoaders.length);
        this.pathList = new DexPathList(this, dexPath, librarySearchPath, null, isTrusted);
        reportClassLoaderChain();
    }
继续跟进DexPathList，源码：dalvik.system.DexPathList
DexPathList(ClassLoader definingContext, String dexPath,
            String librarySearchPath, File optimizedDirectory, boolean isTrusted) {
        if (definingContext == null) {
            throw new NullPointerException("definingContext == null");
        }
        if (dexPath == null) {
            throw new NullPointerException("dexPath == null");
        }
        ........省略
        this.definingContext = definingContext;
        ArrayList<IOException> suppressedExceptions = new ArrayList<IOException>();
        // save dexPath for BaseDexClassLoader
        this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,
                                           suppressedExceptions, definingContext, isTrusted);
        ........省略
    }
splitDexPath主要做的是检查dexPath是否合规，以及加载DEX，ZIP，JAR的不同处理方法，最后返回一个List，里面装载着Dex文件File对象，继续跟进makeDexElements
private static Element[] makeDexElements(List<File> files, File optimizedDirectory,
            List<IOException> suppressedExceptions, ClassLoader loader, boolean isTrusted) {
      Element[] elements = new Element[files.size()];
      int elementsPos = 0;
      for (File file : files) {
          if (file.isDirectory()) {
              elements[elementsPos++] = new Element(file);
          } else if (file.isFile()) {
              String name = file.getName();
              DexFile dex = null;
              // 判断是否.dex结尾
              if (name.endsWith(DEX_SUFFIX)) {
                  try {
                      dex = loadDexFile(file, optimizedDirectory, loader, elements);
                      if (dex != null) {
                          elements[elementsPos++] = new Element(dex, null);
                      }
                  } catch (IOException suppressed) {
                      System.logE("Unable to load dex file: " + file, suppressed);
                      suppressedExceptions.add(suppressed);
                  }
              } else {
                  try {
                      dex = loadDexFile(file, optimizedDirectory, loader, elements);
                  } catch (IOException suppressed) {
                      ........省略
                  }
                  if (dex == null) {
                      elements[elementsPos++] = new Element(file);
                  } else {
                      elements[elementsPos++] = new Element(dex, file);
                  }
              }
          } else {
              System.logW("ClassLoader referenced unknown path: " + file);
          }
      }
      if (elementsPos != elements.length) {
          elements = Arrays.copyOf(elements, elementsPos);
      }
      return elements;
    }
以上可以看出，dexFile最终通过loadDexFile函数打开，返回dalvik.system.DexFile对象，最终通过dalvik.system.DexFile作为参数，new Element，然后返回Element[]。
继续跟进
    private static DexFile loadDexFile(File file, File optimizedDirectory, ClassLoader loader,
                                       Element[] elements)
            throws IOException {
        if (optimizedDirectory == null) {
            return new DexFile(file, loader, elements);
        } else {
            String optimizedPath = optimizedPathFor(file, optimizedDirectory);
            return DexFile.loadDex(file.getPath(), optimizedPath, 0, loader, elements);
        }
    }
源码：dalvik.system.DexFile
    DexFile(String fileName, ClassLoader loader, DexPathList.Element[] elements)
            throws IOException {
        mCookie = openDexFile(fileName, null, 0, loader, elements);
        mInternalCookie = mCookie;
        mFileName = fileName;
        //System.out.println("DEX FILE cookie is " + mCookie + " fileName=" + fileName);
    }
此处可以看出，通过openDexFile，最终返回mCookie，在Android 5.0的时候类型是long，6.0开始为Object，其实际内容是long[]，此处了解即可。
继续跟进
    private static native Object openDexFileNative(String sourceName, String outputName, int flags,
            ClassLoader loader, DexPathList.Element[] elements);
最终调用native中的openDexFileNative方法。
下面进入native的源码
源码：art/runtime/native/dalvik_system_DexFile.cc
static jobject DexFile_openDexFileNative(JNIEnv* env,
                                         jclass,
                                         jstring javaSourceName,
                                         jstring javaOutputName ATTRIBUTE_UNUSED,
                                         jint flags ATTRIBUTE_UNUSED,
                                         jobject class_loader,
                                         jobjectArray dex_elements) {
  ScopedUtfChars sourceName(env, javaSourceName);
  if (sourceName.c_str() == nullptr) {
    return nullptr;
  }
  std::vector<std::string> error_msgs;
  const OatFile* oat_file = nullptr;
  std::vector<std::unique_ptr<const DexFile>> dex_files =
      Runtime::Current()->GetOatFileManager().OpenDexFilesFromOat(sourceName.c_str(),
                                                                  class_loader,
                                                                  dex_elements,
                                                                  /*out*/ &oat_file,
                                                                  /*out*/ &error_msgs);
  return CreateCookieFromOatFileManagerResult(env, dex_files, oat_file, error_msgs);
}
最终是通过Runtime::Current()->GetOatFileManager().OpenDexFilesFromOat，打开了Dex，返回了Native中的DexFile，通过CreateCookieFromOatFileManagerResult返回到Java，也就是mCookie。
如果想进一步了解，可以看下其他博文：ClassLoader--02基于Android5.0的openDexFileNative
继续跟进
static jobject CreateCookieFromOatFileManagerResult(
    JNIEnv* env,
    std::vector<std::unique_ptr<const DexFile>>& dex_files,
    const OatFile* oat_file,
    const std::vector<std::string>& error_msgs) {
  .......省略
  jlongArray array = ConvertDexFilesToJavaArray(env, oat_file, dex_files);
  if (array == nullptr) {
    ScopedObjectAccess soa(env);
    for (auto& dex_file : dex_files) {
      if (linker->IsDexFileRegistered(soa.Self(), *dex_file)) {
        dex_file.release();  // NOLINT
      }
    }
  }
  return array;
}
继续跟进
static jlongArray ConvertDexFilesToJavaArray(JNIEnv* env,
                                             const OatFile* oat_file,
                                             std::vector<std::unique_ptr<const DexFile>>& vec) {
  // Add one for the oat file.
  jlongArray long_array = env->NewLongArray(static_cast<jsize>(kDexFileIndexStart + vec.size()));
  if (env->ExceptionCheck() == JNI_TRUE) {
    return nullptr;
  }
  jboolean is_long_data_copied;
  jlong* long_data = env->GetLongArrayElements(long_array, &is_long_data_copied);
  if (env->ExceptionCheck() == JNI_TRUE) {
    return nullptr;
  }
  // 此处为核心转换
  long_data[kOatFileIndex] = reinterpret_cast64<jlong>(oat_file);
  for (size_t i = 0; i < vec.size(); ++i) {
    // 将每个DexFile对象地址强转为long型，放入long_data中
    long_data[kDexFileIndexStart + i] = reinterpret_cast64<jlong>(vec[i].get());
  }
  env->ReleaseLongArrayElements(long_array, long_data, 0);
  if (env->ExceptionCheck() == JNI_TRUE) {
    return nullptr;
  }
  // Now release all the unique_ptrs.
  for (auto& dex_file : vec) {
    dex_file.release();  // NOLINT
  }
  // 最终返回
  return long_array;
}
以上可以看出来，art将dexfiles遍历，将dexfile强转为long型地址，最终返回到Java中。
所以可以这样认为，mCookie装载的，是art中的DexFile的对象的内存地址。
所以这跟脱壳有什么关系呢？让我们来看一下DexFile中的构造函数
源码：art/libdexfile/dex/dex_file.cc
DexFile::DexFile(const uint8_t* base,
                 size_t size,
                 const uint8_t* data_begin,
                 size_t data_size,
                 const std::string& location,
                 uint32_t location_checksum,
                 const OatDexFile* oat_dex_file,
                 std::unique_ptr<DexFileContainer> container,
                 bool is_compact_dex)
    : begin_(base),
      size_(size),
      data_begin_(data_begin),
      data_size_(data_size),
      location_(location),
      location_checksum_(location_checksum),
      header_(reinterpret_cast<const Header*>(base)),
      string_ids_(reinterpret_cast<const StringId*>(base + header_->string_ids_off_)),
      type_ids_(reinterpret_cast<const TypeId*>(base + header_->type_ids_off_)),
      field_ids_(reinterpret_cast<const FieldId*>(base + header_->field_ids_off_)),
      method_ids_(reinterpret_cast<const MethodId*>(base + header_->method_ids_off_)),
      proto_ids_(reinterpret_cast<const ProtoId*>(base + header_->proto_ids_off_)),
      class_defs_(reinterpret_cast<const ClassDef*>(base + header_->class_defs_off_)),
      method_handles_(nullptr),
      num_method_handles_(0),
      call_site_ids_(nullptr),
      num_call_site_ids_(0),
      hiddenapi_class_data_(nullptr),
      oat_dex_file_(oat_dex_file),
      container_(std::move(container)),
      is_compact_dex_(is_compact_dex),
      hiddenapi_domain_(hiddenapi::Domain::kApplication) {
  CHECK(begin_ != nullptr) << GetLocation();
  CHECK_GT(size_, 0U) << GetLocation();
  // Check base (=header) alignment.
  // Must be 4-byte aligned to avoid undefined behavior when accessing
  // any of the sections via a pointer.
  CHECK_ALIGNED(begin_, alignof(Header));
  InitializeSectionsFromMapList();
}
源码：art/libdexfile/dex/dex_file.h
  ........省略
  // The base address of the memory mapping.
  const uint8_t* const begin_;
  // The size of the underlying memory allocation in bytes.
  const size_t size_;
  // The base address of the data section (same as Begin() for standard dex).
  const uint8_t* const data_begin_;
  // The size of the data section.
  const size_t data_size_;
  // Typically the dex file name when available, alternatively some identifying string.
  //
  // The ClassLinker will use this to match DexFiles the boot class
  // path to DexCache::GetLocation when loading from an image.
  const std::string location_;
  const uint32_t location_checksum_;
  // Points to the header section.
  const Header* const header_;
  // Points to the base of the string identifier list.
  const dex::StringId* const string_ids_;
  // Points to the base of the type identifier list.
  const dex::TypeId* const type_ids_;
  // Points to the base of the field identifier list.
  const dex::FieldId* const field_ids_;
  // Points to the base of the method identifier list.
  const dex::MethodId* const method_ids_;
  // Points to the base of the prototype identifier list.
  const dex::ProtoId* const proto_ids_;
  // Points to the base of the class definition list.
  const dex::ClassDef* const class_defs_;
  // Points to the base of the method handles list.
  const dex::MethodHandleItem* method_handles_;
  // Number of elements in the method handles list.
  size_t num_method_handles_;
  // Points to the base of the call sites id list.
  const dex::CallSiteIdItem* call_site_ids_;
  // Number of elements in the call sites list.
  size_t num_call_site_ids_;
  ........省略
通过源码中的注释我们可以得知，Dex文件在内存中的映射地址是位于：begin_ ，Dex文件的大小：size_，后来实践中也证实了确实是这么回事。
知道DexFile对象与Dex文件的关系，这样一来就好办了，我们只要拿到所有的mCookie，就等于获取到了所有的DexFile，我们可以将其进行Dump，完成我们的脱壳。
0x2 流程简单梳理
PathClassloader -> BaseClassloader -> DexPathList
DexPathList里面通过 makeDexElements 获得Element[]
Element[]是通过 loadDexFile返回的dalvik.system.DexFile对象创建的
dalvik.system.DexFile最终通过openDexFileNative返回mCookie
反过来，即可得知获取mCookie的线路
先获取PathClassloader中的DexPathList对象
再获取DexPathList中的dexElements，也就是Element[]
再获取每个Element中的dexFile对象
再获取dexFile中的mCookie值
通过以上路线，即可获取到该Classloader中的所有mCookie
0x3 逻辑梳理
加固应用需要在最早的流程中进行解密并且加载Dex文件，否则应用将无法运行。
由于应用的Class被加固隐藏、保护起来了，如果不解密加载，应用会出现ClassNotFoundException。
既然我们应用能运行后，代表findClass可以找到该应用所需的Class，也同时代表了Classloader已经加载进内存了。
我们既然知道了Classloader与DexFile的关系，那么我们就可以根据Classloader，使用以上梳理的点获取该Classloader中的所有mCookie。
大体逻辑就如上面所说，我们再回头看看BlackDex时如何处理的。
0x4 BlackDex
书接上回
    private void handleDumpDex(String packageName, DumpResult result, ClassLoader classLoader) {
        new Thread(() -> {
            try {
                Thread.sleep(500);
            } catch (InterruptedException ignored) {
            }
            try {
                VMCore.cookieDumpDex(classLoader, packageName);
            } finally {
                mAppConfig = null;
                File dir = new File(result.dir);
                if (!dir.exists() || dir.listFiles().length == 0) {
                    BlackBoxCore.getBDumpManager().noticeMonitor(result.dumpError("not found dex file"));
                } else {
                    BlackBoxCore.getBDumpManager().noticeMonitor(result.dumpSuccess());
                }
                BlackBoxCore.get().uninstallPackage(packageName);
            }
        }).start();
    }
此处主要的工作是call
VMCore.cookieDumpDex(classLoader, packageName);
如果发生异常，则通知UI脱壳失败
继续跟进，一个大方法，我们逐步分析
public static void cookieDumpDex(ClassLoader classLoader, String packageName) {
        // 核心：根据Classloader获取当前Classloader中所有的Cookie
        List<Long> cookies = DexFileCompat.getCookies(classLoader);
        File file = new File(BlackBoxCore.get().getDexDumpDir(), packageName);
        DumpResult result = new DumpResult();
        result.dir = file.getAbsolutePath();
        result.packageName = packageName;
        // 此处跟开启多线程进行脱壳
        int availableProcessors = Runtime.getRuntime().availableProcessors();
        ExecutorService executorService = Executors.newFixedThreadPool(availableProcessors <= 0 ? 1 : availableProcessors);
        CountDownLatch countDownLatch = new CountDownLatch(cookies.size());
        AtomicInteger atomicInteger = new AtomicInteger(0);
        BlackBoxCore.getBDumpManager().noticeMonitor(result.dumpProcess(cookies.size(), atomicInteger.getAndIncrement()));
        // 此处遍历每一个cookie
        for (int i = 0; i < cookies.size(); i++) {
            long cookie = cookies.get(i);
            ........省略通知UI操作
            executorService.execute(() -> {
                // 调用native方法进行真正脱壳
                cookieDumpDex(cookie, file.getAbsolutePath(), BlackBoxCore.get().isFixCodeItem());
                ........省略通知UI操作
            });
        }
        File[] files = file.listFiles();
        if (files != null) {
            for (File dex : files) {
                if (dex.isFile() && dex.getAbsolutePath().endsWith(".dex")) {
                    // 如果脱壳成功，修复Dex的signature与checksum
                    DexUtils.fixDex(dex);
                }
            }
        }
    }
使用方法
List<Long> cookies = DexFileCompat.getCookies(classLoader);
获取Classloader所有的Cookie，原理我们上面也讲过，感兴趣的可以自行查看代码，此处不再细说。
以下是最核心的脱壳操作，我们逐步分析
void DexDump::cookieDumpDex(JNIEnv *env, jlong cookie, jstring dir, jboolean fix) {
    // 如果环境没有初始化则去初始化，初始化内容我们后续分析
    if (beginOffset == -2) {
        init(env);
    }
    // 如果初始化失败，我们则无法脱壳
    if (beginOffset == -1) {
        ALOGD("dumpDex not support!");
        return;
    }
    // 以上初始化核心工作为：获取DexFile->begin_的偏移量，知道了begin_我们才知道Dex在内存中的什么位置，才可以将它Dump出来，否则将无法脱壳。
    // Dex magic，某数字加固为了防止内存搜索脱壳，会将Dex magic抹除变成00 00 00 00 00 00 00，使得内存扫描无法找到Dex文件从而无法脱壳，BlackDex脱壳后会将此修复。
    char magic[8] = {0x64, 0x65, 0x78, 0x0a, 0x30, 0x33, 0x35, 0x00};
    // 将cookie转换成内存地址
    auto base = reinterpret_cast<char *>(cookie);
    // 根据初始化beginOffset，通过base + 偏移，得知begin_所在的位置
    auto begin = *(size_t *) (base + beginOffset * sizeof(size_t));
    // 此处经常会出现bad point，所以检查一下是否野指针
    if (!PointerCheck::check(reinterpret_cast<void *>(begin))) {
        return;
    }
    auto dirC = env->GetStringUTFChars(dir, 0);
    // 此处根据Dex + 0x20获取Dex文件的总大小，方便我们对Dex进行Dump
    auto dexSizeOffset = ((unsigned long) begin) + 0x20;
    int size = *(size_t *) dexSizeOffset;
    void *buffer = malloc(size);
    if (buffer) {
        // 将内存中的Dex复制出来
        memcpy(buffer, reinterpret_cast<const void *>(begin), size);
        // 修复 magic
        memcpy(buffer, magic, sizeof(magic));
        // 以下是检验Dex是否完整，符合格式
        const bool kVerifyChecksum = false;
        const bool kVerify = true;
        const art_lkchan::DexFileLoader dex_file_loader;
        std::string error_msg;
        std::vector<std::unique_ptr<const art_lkchan::DexFile>> dex_files;
        if (!dex_file_loader.OpenAll(reinterpret_cast<const uint8_t *>(buffer),
                                     size,
                                     "",
                                     kVerify,
                                     kVerifyChecksum,
                                     &error_msg,
                                     &dex_files)) {
            // Display returned error message to user. Note that this error behavior
            // differs from the error messages shown by the original Dalvik dexdump.
            ALOGE("Open dex error %s", error_msg.c_str());
            return;
        }
        // 是否需要深度修复，此处下文再讲。
        if (fix) {
            fixCodeItem(env, dex_files[0].get(), begin);
        }
        // 最终我们将Dex写出到指定的目录
        char path[1024];
        sprintf(path, "%s/cookie_%d.dex", dirC, size);
        auto fd = open(path, O_CREAT | O_WRONLY, 0600);
        ssize_t w = write(fd, buffer, size);
        fsync(fd);
        if (w > 0) {
            ALOGE("cookie dump dex ======> %s", path);
        } else {
            remove(path);
        }
        close(fd);
        free(buffer);
        env->ReleaseStringUTFChars(dir, dirC);
    }
}
我们分析一下init方法，看看BlackDex是如何获取begin_偏移量的
void init(JNIEnv *env) {
    // 此处使用PLT HOOK处理掉kill、killpg方法，避免在脱壳过程中应用kill掉自己。
    const char *soName = ".*\\.so$";
    xhook_register(soName, "kill", (void *) new_kill,
                   (void **) (&orig_kill));
    xhook_register(soName, "killpg", (void *) new_killpg,
                   (void **) (&orig_killpg));
    xhook_refresh(0);
    // 此处出现了一个loadEmptyDex方法
    jlongArray emptyCookie = VmCore::loadEmptyDex(env);
    .......省略
}
我们脱壳的第一步就是想要获取begin_的偏移量，但是偏偏这个begin_在DexFile中不一定是固定的位置，如果我们根据AOSP的代码，根据每个Android版本区分写死也没有问题，但是如果说某个手机厂商中间加了一个字段，减了一个字段。那么这里必定出现脱壳失败，此处我使用了一个 预测法 ，这种方法在许多Hook框架上也是常见的，比如需要预测ArtMethod的flags偏移的。
下面将说一下是怎么进行预测，首先我们观察每个Android版本的，可以发现。
  // The base address of the memory mapping.
  const uint8_t* const begin_;
  // The size of the underlying memory allocation in bytes.
  const size_t size_;
begin_与size_都是保持相对位置的，我们可以先这样决定，我们就认为在实际情况中，他们两个的值就是保持相对位置。
既然这样的话，我们不知道begin_，那么size_，也就是Dex文件的大小，我们是肯定能知道的，我们根据这个大小，来获取size_，然后通过 begin_与size_都是保持相对位置 这个特性，我们减去一个uint8_t的大小，那就能获取到begin_的偏移量。
继续看代码是如何操作的
void init(JNIEnv *env) {
    // 此处loadEmptyDex方法，就是加载一个我们指定的Dex文件，这个Dex文件是BlackDex里面准备好的，我已经知道了这个Dex的大小，此处我们加载这个Dex并且获取他的Cookie
    jlongArray emptyCookie = VmCore::loadEmptyDex(env);
    jsize arrSize = env->GetArrayLength(emptyCookie);
    if (env->ExceptionCheck() == JNI_TRUE) {
        return;
    }
    jlong *long_data = env->GetLongArrayElements(emptyCookie, nullptr);
    // 此处遍历cookie
    for (int i = 0; i < arrSize; ++i) {
        jlong cookie = long_data[i];
        if (cookie == 0) {
            continue;
        }
        // 此处我们从cookie的内存地址，也就是DexFile的内存地址，开始往下搜索。
        // 最多搜索10个size_t的大小
        auto dex = reinterpret_cast<char *>(cookie);
        for (int ii = 0; ii < 10; ++ii) {
            auto value = *(size_t *) (dex + ii * sizeof(size_t));
            // 如果此时，搜索到值等于1872，我们的Dex文件大小也是1872，那么可以确定这个内存地址为size_
            if (value == 1872) {
                // 那么我们将size_的偏移 - 1，就取得了begin_的所在内存地址。
                beginOffset = ii - 1;
                env->ReleaseLongArrayElements(emptyCookie, long_data, 0);
                return;
            }
        }
    }
    env->ReleaseLongArrayElements(emptyCookie, long_data, 0);
    beginOffset = -1;
}
这样，我们就可以获取到begin_与size_的偏移量，就可以配合cookieDumpDex进行Dex的Dump操作。至此，BlackDex的脱壳工作就此结束。但是想要真正了解BlackDex的还远远不够，更核心提供脱壳能力的还是虚拟化技术。
BlackDex还有一项加强功能为深度修复，此模式下可以对抗一些指令抽取壳，详情可见Github，有空之后将继续分析是如何对抗指令抽取壳并且实现指令还原。


ncnn编译与安装
ncnn 是由腾讯开发一个跨平台的神经网络前向计算框架，为手机端推理提供了极致优化的高性能。其源码编译可参考官方教程Building。这里记录一下编译安装流程（Windows/Linux）。
一、安装所需依赖
git
g++
cmake
Protobuf
GLslang
Vulkan（可选，GPU推理）
opencv (可选，编译例子需要)
其中git、g++、cmake是编译所需的工具。Protobuf(protocol buffers)是一种语言无关、平台无关、可扩展的序列化结构数据的方法，它可用于（数据）通信协议、数据存储等。GLslang(GLSL - OpenGL Shading Language)是一个以C语言为基础的高阶着色语言，它是由 OpenGL ARB 所建立，提供开发者对绘图管线更多的直接控制，而无需使用汇编语言或硬件规格语言。Vulkan是一个低开销、跨平台的二维、三维图形与计算的应用程序接口（API）。
二、编译安装Protobuf
2.1 下载
下载Protobuf-3.11.2: https://github.com/google/protobuf/archive/v3.11.2.zip 。
下载后解压。
2.2 编译安装
windows
我windows安装了Visual Studio 2019，因此直接用其自带的cmake，也可以单独安装cmake，然后利用cmake.gui。
在开始菜单找到Visual Studio 2019然后找到x64 Native Tools Command Prompt for VS 2019右击，点击更多，以管理员身份运行以下命令，以下命令是安装Release版本，如果安装Debug版本需把以下命令中的Release修改为Debug
cd <protobuf-root-dir>
mkdir build
cd build
cmake -A x64 -DCMAKE_INSTALL_PREFIX=%cd%/install -Dprotobuf_BUILD_TESTS=OFF -Dprotobuf_MSVC_STATIC_RUNTIME=OFF ../cmake
cmake --build . --config Release -j 2
cmake --build . --config Release --target install
Linux则执行以下命令进行安装
sudo apt install libprotobuf-dev protobuf-compiler
三、编译安装vulkan
3.1 下载
进入官网：https://vulkan.lunarg.com/sdk/home 下载相应版本
3.2 编译安装
windows
windows下载相应的exe文件直接进行安装即可，另外还需安装vulkan_intel驱动和vulkan_NVIDIA驱动。vulkan_intel驱动在 https://downloadcenter.intel.com/zh-cn/product/80939/- 找到与本机相应的驱动。安装vulkan_NVIDIA驱动先在 https://developer.nvidia.com/vulkan-driver 中选择显卡对应的驱动。
windows下修改CMakeLists.txt，相应的更改为vulkan的安装路径 ncnn/src/CMAKELists.txt
if(NCNN VULKAN)
    set (Vulkan_INCLUDE_DIR "D: /ncnn/VulkanSDK-1.3.216/ Include") 
    set (Vulkan LIBRARY "D: /ncnn/VulkanSDK-1.3.216/Lib/Vulkan-1.lib") 
    set (VULKAN_ SDK "D: /ncnn/VulkanSDK-1.3.216")
if (NCNN VULKAN)
    if (NOT Vulkan_ FOUND)
        find_ package (Vulkan QUIET)
    endif ()
    message ("Vulkan_ FOUND ”${Vulkan_ FOUND})
    if (NOT Vulkan_ FOUND)
        message (STATUS "=== CMAKE_ SYSTEM_ NAME is: $ {CMARE_ SYSTEM NAME}")
        if (DEFINED ENV{VULKAN_ _SDK} )
            if (CMAKE_ SYSTEM NAME MATCHES "Linux")
                list (APPEND CMAKE_ MODULE_ PATH "SENV{VULKAN_ SDK}/ 。./ source/VulkanTools/ cmake")
            elseif (CMAKE_ SYSTEM_ NAME MATCHES "Windows")
                list (APPEND CMAKE_ MODULE_ PATH "SENV{VULKAN_ SDK} / Samples/ cmake")
            elseif (CMAKE_ SYSTEM NAME MATCHES "Darwin")
                message (WARNING "Failed to find vulkan since cmake too o1d\n"  "cmake >= 3.7 required. Consider、 brew upgrade cmake “")
            endif ()
        else()
            message (FATAL_ ERROR "! ! CMake didn't find Vulkan. Please set VULKAN_ SDK env var, e.g. :\n" "Linux: export VULKAN_ _SDK=~/ soft/Vulkansdk/1.2.148.0/x86_ 64\n" "Windows: set VULKAN_ SDK=E:/lib/VulkanSDK/1.2.148.0\n" "MacOS: export VULKAN SDK=~/ soft/vulkansdk/1.2.148.0/macOS\n")
         endif ()
         find_ package (Vulkan REQUIRED)
  endif ()         
Linux下执行以下命令进行安装
sudo apt install libvulkan-dev vulkan-utils
四、编译安装openCV
参考 https://www.cnblogs.com/xiaxuexiaoab/p/15894993.html
五、编译安装ncnn
Windows
前面步骤执行完后，可安装ncnn，执行以下命令进行安装。注意如果编译Release，则对应的依赖如：Protobuf也需要编译成Release版本
cd <ncnn-root-dir>
mkdir -p build
cd build
cmake -A x64 -DCMAKE_INSTALL_PREFIX=%cd%/install -DProtobuf_INCLUDE_DIR=<protobuf-root-dir>/build/install/include -DProtobuf_LIBRARIES=<protobuf-root-dir>/build/install/lib/libprotobuf.lib -DProtobuf_PROTOC_EXECUTABLE=<protobuf-root-dir>/build/install/bin/protoc.exe -DNCNN_VULKAN=ON ..
cmake --build . --config Release -j 2
cmake --build . --config Release --target install
Linux
cd <ncnn-root-dir>
mkdir -p build
cd build
cmake -DCMAKE_BUILD_TYPE=Release -DNCNN_VULKAN=ON -DNCNN_BUILD_EXAMPLES=ON ..
make -j4
make install
六、使用ncnn
在CMakeLists.txt里面指定ncnn安装路径以及VulKan库路径
set(USE_VULKAN ON)
# Ncnn
if(WIN32)
    if (USE_VULKAN)
        set(NCNN_ROOT "D:/ncnn/ncnn_install/Release/ncnn_install_vulkan")
        set(NCNN_ROOT_DEBUG "D:/ncnn/ncnn_install/Debug/ncnn_install_vulkan")
        set(NCNN_LIBRARIES 
            "${NCNN_ROOT}/lib/ncnn.lib"
            "${NCNN_ROOT}/lib/SPIRV.lib"
            "${NCNN_ROOT}/lib/glslang.lib"
            "${NCNN_ROOT}/lib/GenericCodeGen.lib"
            "${NCNN_ROOT}/lib/MachineIndependent.lib"
            "${NCNN_ROOT}/lib/OGLCompiler.lib"
            "${NCNN_ROOT}/lib/OSDependent.lib"
        CACHE INTERNAL "")
        set(NCNN_LIBRARIES_DEBUG
            "${NCNN_ROOT_DEBUG}/lib/ncnnd.lib"
            "${NCNN_ROOT}/lib/SPIRVd.lib"
            "${NCNN_ROOT}/lib/glslangd.lib"
            "${NCNN_ROOT}/lib/GenericCodeGend.lib"
            "${NCNN_ROOT}/lib/MachineIndependentd.lib"
            "${NCNN_ROOT}/lib/OGLCompilerd.lib"
            "${NCNN_ROOT}/lib/OSDependentd.lib"
        CACHE INTERNAL "")
    else()
        set(NCNN_ROOT "D:/ncnn/ncnn_install/Release/ncnn_install_no_vulkan")
        set(NCNN_ROOT_DEBUG "D:/ncnn/ncnn_install/Debug/ncnn_install_no_vulkan")
        set(NCNN_LIBRARIES 
            "${NCNN_ROOT}/lib/ncnn.lib"
        CACHE INTERNAL "")
        set(NCNN_LIBRARIES_DEBUG
            "${NCNN_ROOT_DEBUG}/lib/ncnnd.lib"
        CACHE INTERNAL "")
    endif()
	set(NCNN_INCLUDE_PATH "${NCNN_ROOT_DEBUG}/include" CACHE INTERNAL "")
elseif(UNIX)
endif()
if (USE_VULKAN)
    # Vulkan
    if(WIN32)
        set(VULKAN_ROOT "D:/ncnn/VulkanSDK-1.3.216")
        set(VULKAN_LIBRARIES
            "${VULKAN_ROOT}/Lib/vulkan-1.lib"
            "${VULKAN_ROOT}/Lib/shaderc_combined.lib"
        CACHE INTERNAL "")
        set(VULKAN_LIBRARIES_DEBUG 
            "${VULKAN_ROOT}/Lib/vulkan-1.lib"
            "${VULKAN_ROOT}/Lib/shaderc_combinedd.lib"
        CACHE INTERNAL "")
	    set(VULKAN_INCLUDE_PATH "${VULKAN_ROOT}/Include" CACHE INTERNAL "")
        message("vulkan " ${VULKAN_INCLUDE_PATH})
    elseif(UNIX)
    endif()
endif()
if (USE_VULKAN)
    target_link_libraries(${PROJECT_NAME} 
    PUBLIC
        # debug ${NCNN_LIBRARIES_DEBUG}
	    # optimized ${NCNN_LIBRARIES}
        "$<IF:$<CONFIG:Debug>,${NCNN_LIBRARIES_DEBUG},${NCNN_LIBRARIES}>"
        debug ${OPENCV_LIBRARIES_DEBUG}
	    optimized ${OPENCV_LIBRARIES}
        # debug ${VULKAN_LIBRARIES_DEBUG}
        # optimized ${VULKAN_LIBRARIES}
        "$<IF:$<CONFIG:Debug>,${VULKAN_LIBRARIES_DEBUG},${VULKAN_LIBRARIES}>"
    ) 
else()
    target_link_libraries(${PROJECT_NAME} 
    PUBLIC
	    debug ${NCNN_LIBRARIES_DEBUG}
	    optimized ${NCNN_LIBRARIES}
        debug ${OPENCV_LIBRARIES_DEBUG}
	    optimized ${OPENCV_LIBRARIES}
    ) 
endif()

Tencent/ncnn/wiki/how-to-build[https://github.com/Tencent/ncnn/wiki/how-to-build]
Git clone ncnn repo with submodule
git clone https://github.com/Tencent/ncnn.git
cd ncnn
git submodule update --init
Build for Linux
Install required build dependencies:
git
g++
cmake
protocol buffer (protobuf) headers files and protobuf compiler
(optional) LLVM OpenMP header files # If building with Clang, and multithreaded CPU inference is desired
(optional) opencv # For building examples
Generally if you have Intel, AMD or Nvidia GPU from last 10 years, Vulkan can be easily used.
On some systems there are no Vulkan drivers easily available at the moment (October 2020), so you might need to disable use of Vulkan on them. This applies to Raspberry Pi 3 (but there is experimental open source Vulkan driver in the works, which is not ready yet). Nvidia Tegra series devices (like Nvidia Jetson) should support Vulkan. Ensure you have most recent software installed for best experience.
On Debian, Ubuntu, or Raspberry Pi OS, you can install all required dependencies using:
sudo apt install build-essential git cmake libprotobuf-dev protobuf-compiler libomp-dev libopencv-dev
On Redhat or Centos, you can install all required dependencies using:
sudo yum install build-essential git cmake libprotobuf-dev protobuf-compiler libopencv-dev
To use Vulkan after building ncnn later, you will also need to have Vulkan driver for your GPU. For AMD and Intel GPUs these can be found in Mesa graphics driver, which usually is installed by default on all distros (i.e. sudo apt install mesa-vulkan-drivers on Debian/Ubuntu). For Nvidia GPUs the proprietary Nvidia driver must be downloaded and installed (some distros will allow easier installation in some way). After installing Vulkan driver, confirm Vulkan libraries and driver are working, by using vulkaninfo or vulkaninfo | grep deviceType, it should list GPU device type. If there are more than one GPU installed (including the case of integrated GPU and discrete GPU, commonly found in laptops), you might need to note the order of devices to use later on.
Nvidia Jetson
The Vulkan driver is a default component of the Linux For Tegra BSP release, check the device list.
cd ncnn
mkdir -p build
cd build
cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE=../toolchains/jetson.toolchain.cmake -DNCNN_VULKAN=ON -DNCNN_BUILD_EXAMPLES=ON ..
make -j$(nproc)
Raspberry Pi
Vulkan drivers do exists, but are not mature. You are free to experiment at your own discretion, and report results and performance.
cd ncnn
mkdir -p build
cd build
cmake -DCMAKE_BUILD_TYPE=Release -DNCNN_VULKAN=ON -DNCNN_BUILD_EXAMPLES=ON ..
make -j$(nproc)
You can add -GNinja to cmake above to use Ninja build system (invoke build using ninja or cmake --build .).
For Raspberry Pi 3 on 32bit OS, add -DCMAKE_TOOLCHAIN_FILE=../toolchains/pi3.toolchain.cmake to cmake. You can also consider disabling Vulkan support as the Vulkan drivers for Raspberry Pi are still not mature, but it doesn't hurt to build the support in, but not use it.
POWER
For POWER9 with Clang:
cd ncnn
mkdir -p build
cd build
cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE=../toolchains/power9le-linux-gnu-vsx.clang.toolchain.cmake -DNCNN_VULKAN=ON -DNCNN_BUILD_EXAMPLES=ON ..
make -j$(nproc)
To use GCC instead, use the power9le-linux-gnu-vsx.toolchain.cmake toolchain file instead. Note that according to benchmarks, Clang appears to produce noticeably faster CPU inference than GCC for POWER9 targets. For fastest inference, use Clang 18 or higher; earlier versions of Clang may have impaired inference speed due to Bug 49864 and Bug 64664.
For POWER8 instead of POWER9, use the power8le-linux-gnu-vsx.clang.toolchain.cmake or power8le-linux-gnu-vsx.toolchain.cmake toolchain file instead. POWER8 will be slower than POWER9.
Note that the POWER toolchain files only support little-endian mode.
Intel oneAPI
Besides the prerequests in this section, Intel oneAPI BaseKit and HPCKit should be installed. They are available from https://www.intel.com/content/www/us/en/developer/tools/oneapi/base-toolkit.html and https://www.intel.com/content/www/us/en/developer/tools/oneapi/hpc-toolkit.html freely.
Intel oneAPI offers two kinds of compilers, the classic icc/icpc and the LLVM based icx/icpx. To build with these compilers, add CC=icc CXX=icpc or CC=icx CXX=icpx before the cmake command. When compiling with icc/icpc, cmake will warn that xop, avx512, and bf16 extensions are not supported by the compiler, while icx/icpx works well.
Both of these compilers have been tested and passed the ncnn benchmark successfully. The results have been included in ncnn benchmark readme. Generally, icx/icpx are likely to show better performance than icc/icpc and the quantized models can benefit from the extensions icx/icpx supports.
Cross compile: Riscv-gnu-toolchain
Before compiling the whole project, toolchain must be installed. Reference: Riscv-gnu-toolchain build guide
# configure with vector extension.
./configure --prefix=/opt/riscv --enable-multilib --with-arch=rv64gcv
# configure without vector extension.
./configure --prefix=/opt/riscv --enable-multilib --with-arch=rv64gc
# it takes quite a long time:(
sudo make linux
Now you can build the project:
mkdir build-riscv
cd build-riscv
cmake -DDCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE=../toolchains/riscv64-unknown-linux-gnu.toolchain.cmake -DNCNN_BUILD_EXAMPLES=ON ..
make -j$(nproc) # or `make -j2` if your cpu isn't powerful enough.
Verification
Verify build by running some examples:
cd ../examples
../build/examples/squeezenet ../images/256-ncnn.png
[0 AMD RADV FIJI (LLVM 10.0.1)]  queueC=1[4]  queueG=0[1]  queueT=0[1]
[0 AMD RADV FIJI (LLVM 10.0.1)]  bugsbn1=0  buglbia=0  bugcopc=0  bugihfa=0
[0 AMD RADV FIJI (LLVM 10.0.1)]  fp16p=1  fp16s=1  fp16a=0  int8s=1  int8a=1
532 = 0.163452
920 = 0.093140
716 = 0.061584
You can also run benchmarks (the 4th argument is a GPU device index to use, refer to vulkaninfo, if you have more than one GPU):
cd ../benchmark
../build/benchmark/benchncnn 10 $(nproc) 0 0
[0 AMD RADV FIJI (LLVM 10.0.1)]  queueC=1[4]  queueG=0[1]  queueT=0[1]
[0 AMD RADV FIJI (LLVM 10.0.1)]  bugsbn1=0  buglbia=0  bugcopc=0  bugihfa=0
[0 AMD RADV FIJI (LLVM 10.0.1)]  fp16p=1  fp16s=1  fp16a=0  int8s=1  int8a=1
num_threads = 4
powersave = 0
gpu_device = 0
cooling_down = 1
          squeezenet  min =    4.68  max =    4.99  avg =    4.85
     squeezenet_int8  min =   38.52  max =   66.90  avg =   48.52
...
To run benchmarks on a CPU, set the 5th argument to -1.
Build for Windows x64 using Visual Studio Community 2017
Download and Install Visual Studio Community 2017 from https://visualstudio.microsoft.com/vs/community/
Start the command prompt: Start → Programs → Visual Studio 2017 → Visual Studio Tools → x64 Native Tools Command Prompt for VS 2017
You can also search x64 Native Tools Command Prompt for VS 2017 directly.
Download protobuf-3.11.2 from https://github.com/google/protobuf/archive/v3.11.2.zip
Build protobuf library:
cd <protobuf-root-dir>
mkdir protobuf_build
cd protobuf_build
cmake -A x64 -DCMAKE_INSTALL_PREFIX=%cd%/install -Dprotobuf_BUILD_TESTS=OFF -Dprotobuf_MSVC_STATIC_RUNTIME=OFF ../cmake
cmake --build . --config Release -j 2
cmake --build . --config Release --target install
Build ncnn library (replace <protobuf-root-dir> with a proper path):
cd <ncnn-root-dir>
mkdir -p protobuf_build
cd protobuf_build
cmake -A x64 -DCMAKE_INSTALL_PREFIX=%cd%/install -Dprotobuf_DIR=<protobuf-root-dir>/protobuf_build/install/cmake -DNCNN_VULKAN=ON ..
cmake --build . --config Release -j 2
cmake --build . --config Release --target install
Note: To speed up compilation process on multi core machines, configuring cmake to use jom or ninja using -G flag is recommended.
Note: For protobuf >=22.0 (Take v25.3 for example):
Build zlib:
git clone -b -v1.3.1 https://github.com/madler/zlib.git
cd zlib
mkdir build
cd build
cmake -A x64 -DCMAKE_INSTALL_PREFIX=%cd%/install ..
cmake --build . --config Release -j 2
cmake --build . --config Release --target install
Build protobuf library (replace <zlib-root-dir> with a proper path):
git clone -b v25.3 https://github.com/protocolbuffers/protobuf.git
cd protobuf
git submodule update --init --recursive
mkdir protobuf_build
cd protobuf_build
cmake -A x64 -DCMAKE_INSTALL_PREFIX=%cd%/install -DCMAKE_CXX_STANDARD=14 -Dprotobuf_BUILD_TESTS=OFF -Dprotobuf_MSVC_STATIC_RUNTIME=OFF -DZLIB_INCLUDE_DIR=<zlib-root-dir>\build\install\include -DZLIB_LIBRARY=<zlib-root-dir>\build\install\lib\zlib.lib -DABSL_PROPAGATE_CXX_STD=ON ../cmake
cmake --build . --config Release -j 2
cmake --build . --config Release --target install
Build ncnn library (replace <zlib-root-dir> and <protobuf-root-dir> with a proper path):
cd <ncnn-root-dir>
mkdir -p build
cd build
cmake -A x64 -DCMAKE_INSTALL_PREFIX=%cd%/install -DCMAKE_PREFIX_PATH=<protobuf-root-dir>/protobuf_build\install\cmake -DZLIB_INCLUDE_DIR=<zlib-root-dir>\build\install\include -DZLIB_LIBRARY=<zlib-root-dir>\build\install\lib\zlib.lib -Dabsl_DIR=<protobuf-root-dir>/protobuf_build\install\lib\cmake\absl -Dutf8_range_DIR=<protobuf-root-dir>/protobuf_build\install\lib\cmake\utf8_range -DNCNN_VULKAN=ON ..
cmake --build . --config Release -j 2
cmake --build . --config Release --target install
Build for Windows x64 using MinGW-w64
Download MinGW-w64 toolchain from winlibs or w64devkit, add bin folder to environment variables.
Build ncnn library:
cd <ncnn-root-dir>
mkdir build
cd build
cmake -DNCNN_VULKAN=ON -G "MinGW Makefiles" ..
cmake --build . --config Release -j 4
cmake --build . --config Release --target install
Build for macOS
We've published ncnn to brew now, you can just use following method to install ncnn if you have the Xcode Command Line Tools installed.
brew update
brew install ncnn
Or if you want to compile and build ncnn locally, first install Xcode or Xcode Command Line Tools according to your needs.
Then install protobuf and libomp via homebrew
brew install protobuf libomp
Download and install Vulkan SDK from https://vulkan.lunarg.com/sdk/home
wget https://sdk.lunarg.com/sdk/download/1.3.280.1/mac/vulkansdk-macos-1.3.280.1.dmg -O vulkansdk-macos-1.3.280.1.dmg
hdiutil attach vulkansdk-macos-1.3.280.1.dmg
sudo /Volumes/vulkansdk-macos-1.3.280.1/InstallVulkan.app/Contents/MacOS/InstallVulkan --root `pwd`/vulkansdk-macos-1.3.280.1 --accept-licenses --default-answer --confirm-command install
hdiutil detach /Volumes/vulkansdk-macos-1.3.280.1
# setup env
export VULKAN_SDK=`pwd`/vulkansdk-macos-1.3.280.1/macOS
cd <ncnn-root-dir>
mkdir -p build
cd build
cmake -DCMAKE_TOOLCHAIN_FILE=../toolchains/ios.toolchain.cmake -DPLATFORM=MAC -DARCHS="x86_64;arm64" \
    -DVulkan_LIBRARY=`pwd`/../vulkansdk-macos-1.3.280.1/macOS/lib/libMoltenVK.dylib \
    -DNCNN_VULKAN=ON -DNCNN_BUILD_EXAMPLES=ON ..
cmake --build . -j 4
cmake --build . --target install
Note: If you encounter libomp related errors during installation, you can also check our GitHub Actions at here to install and use openmp.
Build for ARM Cortex-A family with cross-compiling
Download ARM toolchain from https://developer.arm.com/open-source/gnu-toolchain/gnu-a/downloads
export PATH="<your-toolchain-compiler-path>:${PATH}"
Alternatively install a cross-compiler provided by the distribution (i.e. on Debian / Ubuntu, you can do sudo apt install g++-arm-linux-gnueabi g++-arm-linux-gnueabihf g++-aarch64-linux-gnu).
Depending on your needs build one or more of the below targets.
AArch32 target with soft float (arm-linux-gnueabi)
cd <ncnn-root-dir>
mkdir -p build-arm-linux-gnueabi
cd build-arm-linux-gnueabi
cmake -DCMAKE_TOOLCHAIN_FILE=../toolchains/arm-linux-gnueabi.toolchain.cmake ..
make -j$(nproc)
AArch32 target with hard float (arm-linux-gnueabihf)
cd <ncnn-root-dir>
mkdir -p build-arm-linux-gnueabihf
cd build-arm-linux-gnueabihf
cmake -DCMAKE_TOOLCHAIN_FILE=../toolchains/arm-linux-gnueabihf.toolchain.cmake ..
make -j$(nproc)
AArch64 GNU/Linux target (aarch64-linux-gnu)
cd <ncnn-root-dir>
mkdir -p build-aarch64-linux-gnu
cd build-aarch64-linux-gnu
cmake -DCMAKE_TOOLCHAIN_FILE=../toolchains/aarch64-linux-gnu.toolchain.cmake ..
make -j$(nproc)
Build for Hisilicon platform with cross-compiling
Download and install Hisilicon SDK. The toolchain should be in /opt/hisi-linux/x86-arm
cd <ncnn-root-dir>
mkdir -p build
cd build
# Choose one cmake toolchain file depends on your target platform
cmake -DCMAKE_TOOLCHAIN_FILE=../toolchains/hisiv300.toolchain.cmake ..
cmake -DCMAKE_TOOLCHAIN_FILE=../toolchains/hisiv500.toolchain.cmake ..
cmake -DCMAKE_TOOLCHAIN_FILE=../toolchains/himix100.toolchain.cmake ..
cmake -DCMAKE_TOOLCHAIN_FILE=../toolchains/himix200.toolchain.cmake ..
make -j$(nproc)
make install
Build for Android
You can use the pre-build ncnn-android-lib.zip from https://github.com/Tencent/ncnn/releases
Download Android NDK from http://developer.android.com/ndk/downloads/index.html and install it, for example:
unzip android-ndk-r21d-linux-x86_64.zip
export ANDROID_NDK=<your-ndk-root-path>
(optional) remove the hardcoded debug flag in Android NDK android-ndk issue
# open $ANDROID_NDK/build/cmake/android.toolchain.cmake for ndk < r23
# or $ANDROID_NDK/build/cmake/android-legacy.toolchain.cmake for ndk >= r23
# delete "-g" line
list(APPEND ANDROID_COMPILER_FLAGS
  -g
  -DANDROID
Build armv7 library
cd <ncnn-root-dir>
mkdir -p build-android-armv7
cd build-android-armv7
cmake -DCMAKE_TOOLCHAIN_FILE="$ANDROID_NDK/build/cmake/android.toolchain.cmake" \
    -DANDROID_ABI="armeabi-v7a" -DANDROID_ARM_NEON=ON \
    -DANDROID_PLATFORM=android-14 -DNCNN_VULKAN=ON ..
# If you use cmake >= 3.21 and ndk-r23
# you need to add -DANDROID_USE_LEGACY_TOOLCHAIN_FILE=False option for working optimization flags
make -j$(nproc)
make install
Pick build-android-armv7/install folder for further JNI usage.
Build aarch64 library:
cd <ncnn-root-dir>
mkdir -p build-android-aarch64
cd build-android-aarch64
cmake -DCMAKE_TOOLCHAIN_FILE="$ANDROID_NDK/build/cmake/android.toolchain.cmake"\
    -DANDROID_ABI="arm64-v8a" \
    -DANDROID_PLATFORM=android-21 -DNCNN_VULKAN=ON ..
# If you use cmake >= 3.21 and ndk-r23
# you need to add -DANDROID_USE_LEGACY_TOOLCHAIN_FILE=False option for working optimization flags
make -j$(nproc)
make install
Pick build-android-aarch64/install folder for further JNI usage.
Build for iOS on macOS with xcode
You can use the pre-build ncnn.framework glslang.framework and openmp.framework from https://github.com/Tencent/ncnn/releases
Install xcode
You can replace -DENABLE_BITCODE=0 to -DENABLE_BITCODE=1 in the following cmake arguments if you want to build bitcode enabled libraries.
Download and install openmp for multithreading inference feature on iPhoneOS
wget https://github.com/llvm/llvm-project/releases/download/llvmorg-11.0.0/openmp-11.0.0.src.tar.xz
tar -xf openmp-11.0.0.src.tar.xz
cd openmp-11.0.0.src
# apply some compilation fix
sed -i'' -e '/.size __kmp_unnamed_critical_addr/d' runtime/src/z_Linux_asm.S
sed -i'' -e 's/__kmp_unnamed_critical_addr/___kmp_unnamed_critical_addr/g' runtime/src/z_Linux_asm.S
mkdir -p build-ios
cd build-ios
cmake -DCMAKE_TOOLCHAIN_FILE=<ncnn-root-dir>/toolchains/ios.toolchain.cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=install \
    -DPLATFORM=OS64 -DENABLE_BITCODE=0 -DENABLE_ARC=0 -DENABLE_VISIBILITY=0 -DARCHS="arm64;arm64e" \
    -DPERL_EXECUTABLE=/usr/local/bin/perl \
    -DLIBOMP_ENABLE_SHARED=OFF -DLIBOMP_OMPT_SUPPORT=OFF -DLIBOMP_USE_HWLOC=OFF ..
cmake --build . -j 4
cmake --build . --target install
# copy openmp library and header files to xcode toolchain sysroot
# <xcode-dir> is usually /Applications/Xcode.app or /Applications/Xcode-beta.app depends on your Xcode version
sudo cp install/include/* <xcode-dir>/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/include
sudo cp install/lib/libomp.a <xcode-dir>/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/lib
Download and install openmp for multithreading inference feature on iPhoneSimulator
wget https://github.com/llvm/llvm-project/releases/download/llvmorg-11.0.0/openmp-11.0.0.src.tar.xz
tar -xf openmp-11.0.0.src.tar.xz
cd openmp-11.0.0.src
# apply some compilation fix
sed -i'' -e '/.size __kmp_unnamed_critical_addr/d' runtime/src/z_Linux_asm.S
sed -i'' -e 's/__kmp_unnamed_critical_addr/___kmp_unnamed_critical_addr/g' runtime/src/z_Linux_asm.S
mkdir -p build-ios-sim
cd build-ios-sim
cmake -DCMAKE_TOOLCHAIN_FILE=<ncnn-root-dir>/toolchains/ios.toolchain.cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=install \
    -DPLATFORM=SIMULATORARM64 -DENABLE_BITCODE=0 -DENABLE_ARC=0 -DENABLE_VISIBILITY=0 -DARCHS="x86_64;arm64" \
    -DPERL_EXECUTABLE=/usr/local/bin/perl \
    -DLIBOMP_ENABLE_SHARED=OFF -DLIBOMP_OMPT_SUPPORT=OFF -DLIBOMP_USE_HWLOC=OFF ..
cmake --build . -j 4
cmake --build . --target install
# copy openmp library and header files to xcode toolchain sysroot
# <xcode-dir> is usually /Applications/Xcode.app or /Applications/Xcode-beta.app depends on your Xcode version
sudo cp install/include/* <xcode-dir>/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/include
sudo cp install/lib/libomp.a <xcode-dir>/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib
Package openmp framework:
cd <openmp-root-dir>
mkdir -p openmp.framework/Versions/A/Headers
mkdir -p openmp.framework/Versions/A/Resources
ln -s A openmp.framework/Versions/Current
ln -s Versions/Current/Headers openmp.framework/Headers
ln -s Versions/Current/Resources openmp.framework/Resources
ln -s Versions/Current/openmp openmp.framework/openmp
lipo -create build-ios/install/lib/libomp.a build-ios-sim/install/lib/libomp.a -o openmp.framework/Versions/A/openmp
cp -r build-ios/install/include/* openmp.framework/Versions/A/Headers/
sed -e 's/__NAME__/openmp/g' -e 's/__IDENTIFIER__/org.llvm.openmp/g' -e 's/__VERSION__/11.0/g' <ncnn-root-dir>/Info.plist > openmp.framework/Versions/A/Resources/Info.plist
Download and install Vulkan SDK from https://vulkan.lunarg.com/sdk/home
wget https://sdk.lunarg.com/sdk/download/1.2.189.0/mac/vulkansdk-macos-1.2.189.0.dmg?Human=true -O vulkansdk-macos-1.2.189.0.dmg
hdiutil attach vulkansdk-macos-1.2.189.0.dmg
sudo /Volumes/vulkansdk-macos-1.2.189.0/InstallVulkan.app/Contents/MacOS/InstallVulkan --root `pwd`/vulkansdk-macos-1.2.189.0 --accept-licenses --default-answer --confirm-command install
hdiutil detach /Volumes/vulkansdk-macos-1.2.189.0
# setup env
export VULKAN_SDK=`pwd`/vulkansdk-macos-1.2.189.0/macOS
Build library for iPhoneOS:
cd <ncnn-root-dir>
git submodule update --init
mkdir -p build-ios
cd build-ios
cmake -DCMAKE_TOOLCHAIN_FILE=../toolchains/ios.toolchain.cmake -DPLATFORM=OS64 -DARCHS="arm64;arm64e" \
    -DENABLE_BITCODE=0 -DENABLE_ARC=0 -DENABLE_VISIBILITY=0 \
    -DOpenMP_C_FLAGS="-Xclang -fopenmp" -DOpenMP_CXX_FLAGS="-Xclang -fopenmp" \
    -DOpenMP_C_LIB_NAMES="libomp" -DOpenMP_CXX_LIB_NAMES="libomp" \
    -DOpenMP_libomp_LIBRARY="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/lib/libomp.a" \
    -DNCNN_VULKAN=ON -DNCNN_BUILD_BENCHMARK=OFF ..
cmake --build . -j 4
cmake --build . --target install
Build library for iPhoneSimulator:
cd <ncnn-root-dir>
mkdir -p build-ios-sim
cd build-ios-sim
cmake -DCMAKE_TOOLCHAIN_FILE=../toolchains/ios.toolchain.cmake -DPLATFORM=SIMULATORARM64 -DARCHS="x86_64;arm64" \
    -DENABLE_BITCODE=0 -DENABLE_ARC=0 -DENABLE_VISIBILITY=0 \
    -DOpenMP_C_FLAGS="-Xclang -fopenmp" -DOpenMP_CXX_FLAGS="-Xclang -fopenmp" \
    -DOpenMP_C_LIB_NAMES="libomp" -DOpenMP_CXX_LIB_NAMES="libomp" \
    -DOpenMP_libomp_LIBRARY="/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/libomp.a" \
    -DNCNN_BUILD_BENCHMARK=OFF ..
cmake --build . -j 4
cmake --build . --target install
Package glslang framework for iPhoneOS:
cd <ncnn-root-dir>
mkdir -p glslang.framework/Versions/A/Headers
mkdir -p glslang.framework/Versions/A/Resources
ln -s A glslang.framework/Versions/Current
ln -s Versions/Current/Headers glslang.framework/Headers
ln -s Versions/Current/Resources glslang.framework/Resources
ln -s Versions/Current/glslang glslang.framework/glslang
libtool -static build-ios/install/lib/libglslang.a build-ios/install/lib/libSPIRV.a -o build-ios/install/lib/libglslang_combined.a
lipo -create build-ios/install/lib/libglslang_combined.a -o glslang.framework/Versions/A/glslang
cp -r build/install/include/glslang glslang.framework/Versions/A/Headers/
sed -e 's/__NAME__/glslang/g' -e 's/__IDENTIFIER__/org.khronos.glslang/g' -e 's/__VERSION__/1.0/g' Info.plist > glslang.framework/Versions/A/Resources/Info.plist
Package ncnn framework for iPhoneOS:
cd <ncnn-root-dir>
mkdir -p ncnn.framework/Versions/A/Headers
mkdir -p ncnn.framework/Versions/A/Resources
ln -s A ncnn.framework/Versions/Current
ln -s Versions/Current/Headers ncnn.framework/Headers
ln -s Versions/Current/Resources ncnn.framework/Resources
ln -s Versions/Current/ncnn ncnn.framework/ncnn
lipo -create build-ios/install/lib/libncnn.a -o ncnn.framework/Versions/A/ncnn
cp -r build-ios/install/include/* ncnn.framework/Versions/A/Headers/
sed -e 's/__NAME__/ncnn/g' -e 's/__IDENTIFIER__/com.tencent.ncnn/g' -e 's/__VERSION__/1.0/g' Info.plist > ncnn.framework/Versions/A/Resources/Info.plist
Pick ncnn.framework glslang.framework and openmp.framework folder for app development.
Build for WebAssembly
Install Emscripten
git clone https://github.com/emscripten-core/emsdk.git
cd emsdk
./emsdk install 3.1.28
./emsdk activate 3.1.28
source emsdk_env.sh
Build without any extension for general compatibility:
mkdir -p build
cd build
cmake -DCMAKE_TOOLCHAIN_FILE=$EMSDK/upstream/emscripten/cmake/Modules/Platform/Emscripten.cmake \
    -DNCNN_THREADS=OFF -DNCNN_OPENMP=OFF -DNCNN_SIMPLEOMP=OFF -DNCNN_SIMPLEOCV=ON -DNCNN_RUNTIME_CPU=OFF -DNCNN_SSE2=OFF -DNCNN_AVX2=OFF -DNCNN_AVX=OFF \
    -DNCNN_BUILD_TOOLS=OFF -DNCNN_BUILD_EXAMPLES=OFF -DNCNN_BUILD_BENCHMARK=OFF ..
cmake --build . -j 4
cmake --build . --target install
Build with WASM SIMD extension:
mkdir -p build-simd
cd build-simd
cmake -DCMAKE_TOOLCHAIN_FILE=$EMSDK/upstream/emscripten/cmake/Modules/Platform/Emscripten.cmake \
    -DNCNN_THREADS=OFF -DNCNN_OPENMP=OFF -DNCNN_SIMPLEOMP=OFF -DNCNN_SIMPLEOCV=ON -DNCNN_RUNTIME_CPU=OFF -DNCNN_SSE2=ON -DNCNN_AVX2=OFF -DNCNN_AVX=OFF \
    -DNCNN_BUILD_TOOLS=OFF -DNCNN_BUILD_EXAMPLES=OFF -DNCNN_BUILD_BENCHMARK=OFF ..
cmake --build . -j 4
cmake --build . --target install
Build with WASM Thread extension:
mkdir -p build-threads
cd build-threads
cmake -DCMAKE_TOOLCHAIN_FILE=$EMSDK/upstream/emscripten/cmake/Modules/Platform/Emscripten.cmake \
    -DNCNN_THREADS=ON -DNCNN_OPENMP=ON -DNCNN_SIMPLEOMP=ON -DNCNN_SIMPLEOCV=ON -DNCNN_RUNTIME_CPU=OFF -DNCNN_SSE2=OFF -DNCNN_AVX2=OFF -DNCNN_AVX=OFF \
    -DNCNN_BUILD_TOOLS=OFF -DNCNN_BUILD_EXAMPLES=OFF -DNCNN_BUILD_BENCHMARK=OFF ..
cmake --build . -j 4
cmake --build . --target install
Build with WASM SIMD and Thread extension:
mkdir -p build-simd-threads
cd build-simd-threads
cmake -DCMAKE_TOOLCHAIN_FILE=$EMSDK/upstream/emscripten/cmake/Modules/Platform/Emscripten.cmake \
    -DNCNN_THREADS=ON -DNCNN_OPENMP=ON -DNCNN_SIMPLEOMP=ON -DNCNN_SIMPLEOCV=ON -DNCNN_RUNTIME_CPU=OFF -DNCNN_SSE2=ON -DNCNN_AVX2=OFF -DNCNN_AVX=OFF \
    -DNCNN_BUILD_TOOLS=OFF -DNCNN_BUILD_EXAMPLES=OFF -DNCNN_BUILD_BENCHMARK=OFF ..
cmake --build . -j 4
cmake --build . --target install
Pick build-XYZ/install folder for further usage.
Build for AllWinner D1
Download c906 toolchain package from https://www.xrvm.cn/community/download?id=4453617141140230144
tar -xf Xuantie-900-gcc-linux-6.6.0-glibc-x86_64-V3.1.0-20250522.tar.gz
export RISCV_ROOT_PATH=/home/nihui/osd/Xuantie-900-gcc-linux-6.6.0-glibc-x86_64-V3.1.0
Build ncnn with riscv-v vector and simpleocv enabled:
mkdir -p build-c906
cd build-c906
cmake -DCMAKE_TOOLCHAIN_FILE=../toolchains/c906-v310.toolchain.cmake \
    -DCMAKE_BUILD_TYPE=release -DNCNN_OPENMP=OFF -DNCNN_THREADS=OFF -DNCNN_RUNTIME_CPU=OFF -DNCNN_RVV=OFF -DNCNN_XTHEADVECTOR=ON -DNCNN_ZFH=ON -DNCNN_ZVFH=OFF \
    -DNCNN_SIMPLEOCV=ON -DNCNN_BUILD_EXAMPLES=ON ..
cmake --build . -j 4
cmake --build . --target install
Pick build-c906/install folder for further usage.
You can upload binary inside build-c906/examples folder and run on D1 board for testing.
Build for Loongson 2K1000
For gcc version < 8.5, you need to fix msa.h header for workaround msa fmadd/fmsub/maddv/msubv bug.
Open /usr/lib/gcc/mips64el-linux-gnuabi64/8/include/msa.h, find __msa_fmadd and __msa_fmsub and apply changes as the following
// #define __msa_fmadd_w __builtin_msa_fmadd_w
// #define __msa_fmadd_d __builtin_msa_fmadd_d
// #define __msa_fmsub_w __builtin_msa_fmsub_w
// #define __msa_fmsub_d __builtin_msa_fmsub_d
#define __msa_fmadd_w(a, b, c) __builtin_msa_fmadd_w(c, b, a)
#define __msa_fmadd_d(a, b, c) __builtin_msa_fmadd_d(c, b, a)
#define __msa_fmsub_w(a, b, c) __builtin_msa_fmsub_w(c, b, a)
#define __msa_fmsub_d(a, b, c) __builtin_msa_fmsub_d(c, b, a)
find __msa_maddv and __msa_msubv and apply changes as the following
// #define __msa_maddv_b __builtin_msa_maddv_b
// #define __msa_maddv_h __builtin_msa_maddv_h
// #define __msa_maddv_w __builtin_msa_maddv_w
// #define __msa_maddv_d __builtin_msa_maddv_d
// #define __msa_msubv_b __builtin_msa_msubv_b
// #define __msa_msubv_h __builtin_msa_msubv_h
// #define __msa_msubv_w __builtin_msa_msubv_w
// #define __msa_msubv_d __builtin_msa_msubv_d
#define __msa_maddv_b(a, b, c) __builtin_msa_maddv_b(c, b, a)
#define __msa_maddv_h(a, b, c) __builtin_msa_maddv_h(c, b, a)
#define __msa_maddv_w(a, b, c) __builtin_msa_maddv_w(c, b, a)
#define __msa_maddv_d(a, b, c) __builtin_msa_maddv_d(c, b, a)
#define __msa_msubv_b(a, b, c) __builtin_msa_msubv_b(c, b, a)
#define __msa_msubv_h(a, b, c) __builtin_msa_msubv_h(c, b, a)
#define __msa_msubv_w(a, b, c) __builtin_msa_msubv_w(c, b, a)
#define __msa_msubv_d(a, b, c) __builtin_msa_msubv_d(c, b, a)
Build ncnn with mips msa and simpleocv enabled:
mkdir -p build
cd build
cmake -DNCNN_DISABLE_RTTI=ON -DNCNN_DISABLE_EXCEPTION=ON -DNCNN_RUNTIME_CPU=OFF -DNCNN_MSA=ON -DNCNN_MMI=ON -DNCNN_SIMPLEOCV=ON ..
cmake --build . -j 2
cmake --build . --target install
Pick build/install folder for further usage.
You can run binary inside build/examples folder for testing.
Build for Termux on Android
Install app Termux on your phone,and install Ubuntu in Termux.
If you want use ssh, just install openssh in Termux
pkg install proot-distro
proot-distro install ubuntu
or you can see what system can be installed using proot-distro list
while you install ubuntu successfully, using proot-distro login ubuntu to login Ubuntu.
Then make ncnn,no need to install any other dependencies.
git clone https://github.com/Tencent/ncnn.git
cd ncnn
git submodule update --init
mkdir -p build
cd build
cmake -DCMAKE_BUILD_TYPE=Release -DNCNN_BUILD_EXAMPLES=ON -DNCNN_PLATFORM_API=OFF -DNCNN_SIMPLEOCV=ON ..
make -j$(nproc)
Then you can run a test
on my Pixel 3 XL using Qualcomm 845,cant load 256-ncnn.png
cd ../examples
../build/examples/squeezenet ../images/128-ncnn.png
Build for QNX
Request license and download SDP from QNX Software Center: https://www.qnx.com/products/everywhere/ .
Setup QNX environment by invoking SDP's bundled script:
on Windows, open cmd and run
call C:\Users\zz\qnx800\qnxsdp-env.bat
on Linux, use /bin/bash and run
source /home/zz/qnx800/qnxsdp-env.sh
If it gives error cannot find ld on Linux, solve it by creaing link file:
cd ${QNX_HOST}/usr/bin/
ln -s aarch64-unknown-nto-qnx7.1.0-ld ld
Build ncnn with cmake in same shell:
git clone https://github.com/Tencent/ncnn.git
cd ncnn
git submodule update --init
mkdir -p build-qnx
cd build-qnx
cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE=../toolchains/aarch64-qnx.toolchain.cmake ..
make -j$(nproc)
make install
Pick build-qnx/install folder for further usage.
Build for Nintendo 3DS Homebrew Launcher
Install DevkitPRO toolchains
If you are working on windows, download DevkitPro installer from DevkitPro.
If you are using Ubuntu, the official guidelines from DevkitPro might not work for you. Try using the lines below to install
sudo apt-get update
sudo apt-get upgrade
wget https://apt.devkitpro.org/install-devkitpro-pacman
chmod +x ./install-devkitpro-pacman
sudo ./install-devkitpro-pacman
export DEVKITPRO=/opt/devkitpro
export DEVKITARM=/opt/devkitpro/devkitARM
export DEVKITPPC=/opt/devkitpro/devkitPPC
export export PATH=$/opt/devkitpro/tools/bin:$PATH
source ~/.profile
sudo dkp-pacman -Sy
sudo dkp-pacman -Syu
sudo dkp-pacman -S 3ds-dev
Copy the toolchain files from 3DS-cmake(DevitARM3DS.cmake and the cmake folder) to NCNN's toolchains folder.
├── toolchains
│   ├── cmake
│   │   ├── bin2s_header.h.in
│   │   ├── FindCITRO3D.cmake
│   │   ├── FindCTRULIB.cmake
│   │   ├── FindFreetype.cmake
│   │   ├── FindJPEG.cmake
│   │   ├── FindPNG.cmake
│   │   ├── FindSF2D.cmake
│   │   ├── FindSFIL.cmake
│   │   ├── FindSFTD.cmake
│   │   ├── FindZLIB.cmake
│   │   ├── LibFindMacros.cmake
│   │   ├── Tools3DS.cmake
│   │   ├── ToolsGBA.cmake
│   │   └── try_add_imported_target.cmake
│   ├── DevkitArm3DS.cmake
...
Build with:
cd ncnn
mkdir build && cd build
cmake -DCMAKE_TOOLCHAIN_FILE=../toolchains/DevkitArm3DS.cmake .. -DNCNN_SIMPLEOCV=ON -DNCNN_OPENMP=OFF -DNCNN_VFPV4=OFF ..
make -j4
make install
Modify the Makefile in Homebrew example to link and use NCNN in your 3DS Homebrew app.
Build for HarmonyOS with cross-compiling
Download and install HarmonyOS SDK. The sdk installation directory is /opt/ohos-sdk/linux
cd <ncnn-root-dir>
mkdir -p build
cd build
export HM_SDK=/opt/ohos-sdk/linux
# Choose HarmonyOS sdk cmake toolchain file.
# If you want to enable vulkan, set -DNCNN_VULKAN=ON
# The HarmonyOS sdk does not support openmp, use ncnn simpleomp instead.
# Cross-compiling with CMake must use the one provided by the HarmonyOS SDK; otherwise, it won't recognize parameters like OHOS_PLATFORM, leading to compilation errors.
${HM_SDK}/native/build-tools/cmake/bin/cmake -DOHOS_STL=c++_static -DOHOS_ARCH=arm64-v8a -DOHOS_PLATFORM=OHOS -DCMAKE_TOOLCHAIN_FILE=${HM_SDK}/native/build/cmake/ohos.toolchain.cmake -DNCNN_VULKAN=ON -DNCNN_SIMPLEOMP=ON ..
make -j$(nproc)
make install
Build for ESP32 with cross-compiling
Download esp-idf sdk
git clone https://github.com/espressif/esp-idf
cd esp-idf
git submodule update --init --recursive
Install esp-idf sdk and configure the environment
sudo sh install.sh
source export.sh
Note: python>=3.8, cmake>=3.24.0
Build ncnn library:
mkdir build-esp32
cd build-esp32
cmake -DCMAKE_TOOLCHAIN_FILE=../toolchains/esp32.toolchain.cmake -DCMAKE_BUILD_TYPE=Release ..
make -j 4
make install
Note: Make sure to compile in esp-idf environment.
The compiled ncnn library and headers can be put to the esp32 project to test.

smali文件语法手册
0.类型
Dalvik指令中的类型和java的对应关系如下：
语法	Java类型
V	void，只用于返回值类型
Z	boolean
B	byte
S	short
C	char
I	int
J	long
F	float
D	double
L	Java类类型
[	数组类型
默认Dalvik寄存器是32位，J和D是64位类型，需要使用两个相邻的寄存器来存储。
1.方法
方法表示
方法用.method表示开始，.end method表示结束。用#来添加注释，# virtual methods表示这是一个虚方法，# direct methods表示一个直接方法
方法表示语法为：
Lpackage/name/ObjectName;->MethodName(III)Z
Lpackage/name/ObjectName；表示类型
MethodName表示ObjectName类下面的方法
III表示三个整形参数
Z表示为返回bool类型的值
例子：
method(I[[IILjava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;
对应java为：
String method(int,int[][],int,String,Object[])
方法调用
指令	含义
invoke-virtual(/range)	用于调用实例的虚方法
invoke-super(/range)	用于调用实例的父类方法
invoke-direct(/range)	用于调用实例的直接方法
invoke-static(/range)	用于调用实例的静态方法
invoke-interface(/range)	用于调用实例的接口方法
2.字段
字段表示
字段与方法类型，使用.field 表示。# instance fields表示实例字段，# static fields表示静态字段
字段表示语法为：
Lpackage/name/ObjectName;->FieldName:Ljava/lang/String;
字段操作指令
对普通字段操作，读使用iget指令，写使用iput指令。例如iget、iget-wide、iget-object、iget-boolean、iget-type、iget-char、iget-short
静态字段操作，读使用siget指令，写使用sput指令
3.寄存器
寄存器声明，可以理解为变量开辟的存储数量。使用关键.registers 、.local 、.param。
.registers N表示寄存器总数为N
.local N表示为方法内的寄存器数量,通常用v字母开头表示。如：v0、v1、v2....
.param 指定方法参数名，通常用p字母开头表示。如：p0、p1、p2...
4.类型变量
声明变量，使用关键字 const；
64位的常规类型的字节码添加-wide后缀，像long，double等，占两个寄存器；
特殊类型的字节码，添加特殊的后缀。可以是--boolean，-byte，-char，-short，-int，-long，-float，-double，-object，-string，-class，-void等。
对于会产生歧义的，会添加/字节码来消除歧义。
指令 move-wide/from16 vAA,vBBBB 为例，move为基础字节码，表示一个基本操作。-wide为名称后缀，表示操作的数据宽度为64位。from16为字节码后缀，表示一个来自16位的寄存器引用变量。vAA为目标寄存器，vBBBB为源寄存器
常量、字符串、类
const (/4/16/high16) vA,xx 表示将xx赋值给vA，/后面根据xx长度选择
const-wide(/16/32/high16) vAA，xxxx 表示将xxxx赋值给寄存器vAA、vAA+1 ，/后面根据xxxx长度选择
const-string(/jumbo) vAA,xxxx 表示通过字符串索引构造一个字符串并赋值给vAA，较大时使用/jumbo 后缀
const-class(/jumbo) vAA,xxxx 表示通过类型索引获取一个类引用，并赋值给vAA
数组
array-length vA,vB 指令用于获取给定vB寄存器中数组的长度，并将值赋予给vA寄存器
new-array(/jumbo) vA,vB,type@CCCC 指令用于构造制定类型（type@CCCC）和大小（vB)的数组，并将值赋予vA寄存器
filled-new-array(/range/jumbo) {vC,vD,vE,vF,vG} , type@BBBB 指令用于构造制定类型（type@BBBB)和大小 （vA)的数组并填充内容。vA是隐含使用，除了制定数组的小，还指定参数个数。vC-vG是使用的参数寄存器序列。需要指定取值范围时，filled-new-array/range {vCCCC....vNNNN} 这种格式。
fill-array-data vAA,xxxx 指令用指定的数据来填充数组
arrayop vAA,vBB,vCC 指令用于对vBB寄存器指定的数组元素进行取值与赋值。vCC 寄存器用于指定数组元素的索引。vAA寄存器用于存放读取和需要设置数据组元素的值。读取元素时使用aget指令，赋值时使用aput指令。
5.数据操作
数据操作的指令位move，数据返回指令为return
move (/16/from16) vA，vB 用于将vB寄存器的值赋予vA寄存器。
move-wide(/from16) vAAAA,vBBBB 用于将vBBBB寄存器的值赋予vAAAA寄存器
move-object(/16/from16) vAAAA,vBBBB 用于为对象赋值
move-result vAA 用于将上一个invoke调用的方法非对象结果赋予vAA寄存器。move-result-wide 表示占用连续寄存器赋值，move-result-object 表示方法对象结果赋值
move-exception vAA 表示将运行时异常保存到vAA寄存器。必须在异常处理器内使用，否则无效
return-void 表示函数从一个 void方法返回
return vAA 表示函数返回一个32为非对象值，使用8位寄存器。-wide表示64位非对象值，使用相邻两个8位寄存器，-object表示对象类型返回值。
6.类型转换与检查
check-cast(/jumbo) vAA,type@BBBB 表示将vAA中的对象引用转换成指定类型
instance-of(/jumbo) vA,vB,type@CCCC 用于判断vB中的对象引用是否可以转换成type@CCCC类型，可以vA寄存器中值位1，不可以vA值为0
new-instance(/jumbo) vAA，type@BBBB 指令用于构造一个指定类型对象的新实例，并将对象引用赋值给vAA寄存器
基本类型转换
指令	含义
neg-int(long/float/double)	对数值做减法运算
not-int(long/float/double)	对数值取反
int(long/float/double)-long(/float/double/int)	表示数值转换
int-to-byte	用于将整形转换为字节
int-to-char	用于将整形转换为字符串
int-to-shot	用于将整形转换为短整形
7.数据运算
常用的运算符：
运算符	含义
add-type	加法（+）
sub-type	减法（-）
mul-type	乘法（*）
div-type	除法（/）
rem-type	模运算（%）
and-type	与运算（AND)
or-type	或运算（OR）
xor-type	异或运算（XOR)
shl-type	左移运算（<<)
shr-type	右移运算（>>)
ushr-type	无符号数右移运算(>>)
上述运算符 vAA,vBB,vCC 指令用于将vBB与vCC进行运算，将结果保存到vAA寄存器
上述运算符/2ddr vA,vB 用于将vA与vB进行运算，将结果保存到vA寄存器中
上述运算符/lit16/lit8 vA,vB,xxx 用于将vB与常量xxx进行运算，将结果保存到vA寄存器中
8.比较
比较指令是用于对两个寄存器的值进行比较，格式为cmpxxx vAA,vBB,vCC。其中vBB与vCC是需要比较的两个寄存器或寄存器对，比较的结果放到vAA中
关键字	含义
cmpl-float	比较两个单精度浮点数，如果vBB大于vCC，则vAA为-1，等于为0，小于为1
cmpg-float	比较两个单精度浮点数，如果vBB大于vCC，则vAA为1，等于为0，小于为-1
cmpl-double	比较两个双精度浮点数，如果vBB大于vCC，则vAA为-1，等于为0，小于为1
cmpg-double	比较两个双精度浮点数，如果vBB大于vCC，则vAA为1，等于为0，小于为-1
cmp-long	比较两个长整形，如果vBB大于vCC，则vAA为1，等于为0，小于为-1
9.条件和跳转
指令跳转分为三种类型，一种goto跳转，分支switch跳转，条件跳转if
goto +AA 表示指令用于无条件跳转至指定便宜处，偏移量AA不为0
packed-switch vAA,+BBBB 分支跳转指令，vAA寄存器为switch分支中需要判断的值，BBBB指向一个packed-switch-payload格式的偏移表，表中的值是递增的偏移量
sparse-swicth vAA,+BBBB 分支跳转指令，vAA寄存器为switch分支中需要判断的值，BBBB指向一个sparse-switch-payload格式的偏移表，表中的值是递增的偏移量
if-test vA,VB,+CCCC 条件跳转质量用于比较vA寄存器和vB寄存器中的值。如果条件满足就跳转至CCCC偏移处，偏移量不能为0
if-test类型指令如下：
if-test指令	含义
if-eq	等于（==）
if-ne	不等于（!=）
if-gt	大于（>）
if-ge	大于等于（>=）
if-lt	小于 （<）
if-le	小于等于 （<=）
if-testz vAA,+BBBB 条件跳转指令将vAA寄存器的值与0比较。如果结果满足则跳转至BBBB的偏移处，偏移量不为0
if-testz指令	含义
if-eqz	为0 if(!vAA)
if-nez	不为0 if(vAA)
if-ltz	小于0 if(vAA<0)
if-gez	大于等于0 if(vAA>=0)
if-gtz	大于0 if(vAA>0)
if-lez	小于等于0 if(!vAA<=0)
10.其他
类声明
.class 类的包名及完整签名
.super 类的父类包名及完整签名
注释
smail文件用#表示注释，且只支持单行
注解
注解会添加#annotaions注释，并用.annotation指令开始，以.end annotation指令结束
行号
.line表示java源文件中的行信息
锁指令
monitor-enter vAA表示为vAA加锁
monitor-exit vAA 表示释放指定对象的锁
异常指令
throw vAA 用于抛出vAA寄存器中指定类型的异常


Smali基本语法
数据类型
Smali(方法类型)
Smali（代码）
Java
备注
V
return-void
void
只能用于返回值类型
Z
const/4 v0,0x1
boolean
布尔值类型，判断逻辑
Ljava/lang/String;
const-string v0,”字符串”
String
字符串类型
I
const/4 v0,0x1
int
整数类型
Lpackage/name;
Lpackage/name;
对象类型
L表示这是一个对象类型，package表示该对象所在的包，; 表示对象名称的结束
S
const/16 v0, 0x64
short
短整数类型
J
const-wide/32 v0, 0x186a0
long
长整数类型
F
const/high16 v0, 0x42c80000   
float
浮点数类型
D
const-wide/high16 v0, 0x4059000000000000L
double
双浮点数类型
C
const/16 v0, 0x61
char
字符类型
B
const/4 v0, 0x1
byte
字节类型
[类型
[类型
数组
[l表示一个int型数据，[Ljava/lang/String 表示一个String的对象数组
语法关键词
关键词
说明
.class
定义java类名
.super
定义父类名
.source
定义Java源文件名
.filed
定义字段
.method
定义方法开始
.end method
定义方法结束
.annotation
定义注解开始
.end annotation
定义注解结束
.implements
定义接口指令
.local
指定了方法内局部变量的个数
.registers
指定方法内使用寄存器的总数
.prologue
表示方法中代码的开始处
.line
表示java源文件中指定行
.paramter
指定了方法的参数
.param
和.paramter含义一致但是表达格式不同
寄存器
Java中变量都是存放在内存中的，Android为了提高性能，变量都是存放在寄存器中的，寄存器为32位，可以支持任何类型。
寄存器分为如下两类：
1、本地寄存器
用v开头数字结尾的符号来表示，v0, v1, v2,...
2、参数寄存器
用p开头数字结尾的符号来表示，p0,p1,p2,...
注意：
在非static方法中，p0代指this，p1为方法的第一个参数。
在static方法中，p0为方法的第一个参数。
Smali代码示例
const/4 v0, 0x1 //把值0x1存到v0本地寄存器
iput-boolean v0,p0,Lcom/aaa;->IsRegisterd:Z //把v0中的值赋给com.aaa.IsRegistered，p0代表this，相当于this.Isregistered=true
成员变量
成员变量定义格式为：
.field public/private [static][final] varName:<类型>
获取指令
iget, sget, iget-boolean, sget-boolean, iget-object, sget-object
操作指令
iput, sput, iput-boolean, sput-boolean, iput-object, sput-object
array的操作是aget和aput
指令解析
sget-object v0,Lcom/aaa;->ID:Ljava/lang/String;
获取ID这个String类型的成员变量并放到v0这个寄存器中
iget-object v0,p0,Lcom/aaa;->view:Lcom/aaa/view;
iget-object比sget-object多一个参数p0，这个参数代表变量所在类的实例。这里p0就是this
Smali代码示例1：
const/4 v3, 0x0
sput-object v3, Lcom/aaa;->timer:Lcom/aaa/timer;
相当于java代码：this.timer = null;
Smali代码示例2：
.local v0, args:Landroid/os/Message;
const/4 v1, 0x12
iput v1,v0,Landroid/os/Message;->what:I
相当于java代码：args.what = 18;
其中args为Message的实例
函数
函数定义格式为：
.method public/private [static][final] methodName()<类型>
.end method
Smali代码示例
.method private ifRegistered()Z
    .locals 2            // 本地寄存器的个数
    .prologue
    const/4 v0, 0x1      //v0赋值为1
    if-eqz v0, :cond_0   //判断v0是否等于0，等于0则跳到cond_0执行
    const/4 v1, 0x1      //符合条件分支
    :goto_0              //标签
    return v1            //返回v1的值
    :cond_0              //标签
    const/4 v1, 0x0      //cond_0分支
    goto :goto_0         //跳到goto_0执行
.end method
函数分为两类：direct method和virtual method
direct method就是private方法，virtual method就是指其余的方法。
调用指令：
invoke-direct
invoke-virtual
invoke-static
invoke-super
invoke-interface
调用格式：
invoke-指令类型 {参数1, 参数2,...}, L类名;->方法名
如果不是是静态方法，参数1代表调用该方法的实例。
Smali代码示例：
const-string v0, "NDKLIB"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
相当于java代码：System.loadLibrary("NDKLIB")
函数返回结果
Smali需要用指令move-result或move-result-object来保存函数返回的结果
Smali代码示例：
const-string v0, "Eric"
invoke-static {v0}, Lcmb/pbi;->t(Ljava/lang/String;)Ljava/lang/String;
move-result-object v2
表示将方法t返回的String对象保存到v2中。
方法的定义
private static int sum(int a, int b) {
        return a+b;
}
使用编译后是这样
.method private static sum(II)I
    .locals 4   表示需要申请4个本地寄存器
    .parameter
    .parameter 2  这里表示有两个参数
    .prologue
    .line 27
    move v0, p0
    .local v0, a:I
    move v1, p1
    .local v1, b:I
    move v2, v0
    move v3, v1
    add-int/2addr v2, v3
    move v0, v2
    .end local v0           a:I
    return v0
.end method
从上面可以看到函数声明使用.method开始 .end method结束，java中的关键词private,static 等都可以使用，同时使用签名来表示唯一的方法，这里是sum(II)I。
指令执行
smali字节码是类似于汇编的，如果你有汇编基础，理解起来是非常容易的。
比如：
move v0, v3 把v3寄存器的值移动到寄存器v0上.
const v0， 0x1 把值0x1赋值到寄存器v0上。
invoke-static {v4, v5}, Lme/isming/myapplication/MainActivity;->sum(II)I 执行方法sum(),v4,v5的值分别作为sum的参数
条件跳转分支
"if-eq vA, vB, :cond_x"　---　如果vA等于vB则跳转到:cond_x
"if-ne vA, vB, :cond_x"　---　如果vA不等于vB则跳转到:cond_x
"if-lt vA, vB, :cond_x"　---　如果vA小于vB则跳转到:cond_x
"if-ge vA, vB, :cond_x"　---　如果vA大于等于vB则跳转到:cond_x
"if-gt vA, vB, :cond_x"　---　如果vA大于vB则跳转到:cond_x
"if-le vA, vB, :cond_x"　---　如果vA小于等于vB则跳转到:cond_x
"if-eqz vA, :cond_x"　---　如果vA等于0则跳转到:cond_x
"if-nez vA, :cond_x"　---　如果vA不等于0则跳转到:cond_x
"if-ltz vA, :cond_x"　---　如果vA小于0则跳转到:cond_x
"if-gez vA, :cond_x"　---　如果vA大于等于0则跳转到:cond_x
"if-gtz vA, :cond_x"　---　如果vA大于0则跳转到:cond_x
"if-lez vA, :cond_x"　---　如果vA小于等于0则跳转到:cond_x
常用修改技巧
const-string v0,”json数据”     //写死抓包返回的vip信息的数据
goto :cond_x       //无视后面的任何判断，直接跳转到校验成功后的代码段
return-void       //如果方法是返回的void，直接在某个代码的后面加上，终止后面的代码的执行
const/4 v0,0x1    //对于判断，写死true 0x1或者false 0x0
#               //某行代码前添加#，代表该行代码被注释掉，和删掉这行代码一样，但方便恢复
if-eq/…          //直接修改判断条件


Smali基本语法
数据类型
Smali	Java	备注
v	void	只能用于返回值类型
Z	boolean	
B	byte	
S	short	
C	char	
I	int	
J	long	
F	float	
D	double	
Lpackage/name;	对象类型	L表示这是一个对象类型，package表示该对象所在的包，；表示对象名称的结束
[类型	数组	[I表示一个int型数据，[Ljava/lang/String 表示一个String的对象数组
语法关键词
关键词	说明
.class	定义java类名
.super	定义父类名
.source	定义Java源文件名
.filed	定义字段
.method	定义方法开始
.end method	定义方法结束
.annotation	定义注解开始
.end annotation	定义注解结束
.implements	定义接口指令
.local	指定了方法内局部变量的个数
.registers	指定方法内使用寄存器的总数
.prologue	表示方法中代码的开始处
.line	表示java源文件中指定行
.paramter	指定了方法的参数
.param	和.paramter含义一致,但是表达格式不同
寄存器
Java中变量都是存放在内存中的，Android为了提高性能，变量都是存放在寄存器中的，寄存器为32位，可以支持任何类型。
为什么寄存器比内存快，可以参考这篇文章：http://www.ruanyifeng.com/blog/2013/10/register.html
寄存器分为如下两类：
1、本地寄存器
用v开头数字结尾的符号来表示，v0, v1, v2,...
2、参数寄存器
用p开头数字结尾的符号来表示，p0,p1,p2,...
注意：
在非static方法中，p0代指this，p1为方法的第一个参数。
在static方法中，p0为方法的第一个参数。
Smali代码示例：
const/4 v0, 0x1 //把值0x1存到v0本地寄存器
iput-boolean v0,p0,Lcom/aaa;->IsRegisterd:Z //把v0中的值赋给com.aaa.IsRegistered，p0代表this，相当于this.Isregistered=true
成员变量
成员变量定义格式为：
.field public/private [static][final] varName:<类型>
获取指令
iget, sget, iget-boolean, sget-boolean, iget-object, sget-object
操作指令
iput, sput, iput-boolean, sput-boolean, iput-object, sput-object
array的操作是aget和aput
指令解析
sget-object v0,Lcom/aaa;->ID:Ljava/lang/String;
获取ID这个String类型的成员变量并放到v0这个寄存器中
iget-object v0,p0,Lcom/aaa;->view:Lcom/aaa/view;
iget-object比sget-object多一个参数p0，这个参数代表变量所在类的实例。这里p0就是this
Smali代码示例1：
const/4 v3, 0x0
sput-object v3, Lcom/aaa;->timer:Lcom/aaa/timer;
相当于java代码：this.timer = null;
Smali代码示例2：
.local v0, args:Landroid/os/Message;
const/4 v1, 0x12
iput v1,v0,Landroid/os/Message;->what:I
相当于java代码：args.what = 18;
其中args为Message的实例
函数
函数定义格式为：
.method public/private [static][final] methodName()<类型>
.end method
Smali代码示例:
.method private ifRegistered()Z
    .locals 2            // 本地寄存器的个数
    .prologue
    const/4 v0, 0x1      //v0赋值为1
    if-eqz v0, :cond_0   //判断v0是否等于0，等于0则跳到cond_0执行
    const/4 v1, 0x1      //符合条件分支
    :goto_0              //标签
    return v1            //返回v1的值
    :cond_0              //标签
    const/4 v1, 0x0      //cond_0分支
    goto :goto_0         //跳到goto_0执行
.end method
函数分为两类：direct method和virtual method
direct method就是private方法，virtual method就是指其余的方法。
调用指令：
invoke-direct
invoke-virtual
invoke-static
invoke-super
invoke-interface
调用格式：
invoke-指令类型 {参数1, 参数2,...}, L类名;->方法名
如果不是是静态方法，参数1代表调用该方法的实例。
Smali代码示例：
const-string v0, "NDKLIB"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
相当于java代码：System.loadLibrary("NDKLIB")
函数返回结果
Smali需要用指令move-result或move-result-object来保存函数返回的结果
Smali代码示例：
const-string v0, "Eric"
invoke-static {v0}, Lcmb/pbi;->t(Ljava/lang/String;)Ljava/lang/String;
move-result-object v2


smali语法中文版
表中的vx、vy、vz表示某个Dalvik寄存器。根据不同指令可以访问16、256或64K寄存器。
表中lit4、lit8、lit16、lit32、lit64表示字面值（直接赋值），数字是值所占用位的长度。
long和double型的值占用两个寄存器，例：一个在v0寄存器的double值实际占用v0,v1两个寄存器。
boolean值的存储实际是1和0，1为真、0为假；boolean型的值实际是转成int型的值进行操作。
所有例子的字节序都采用高位存储格式，例：0F00 0A00的编译为0F, 00, 0A, 00 存储。
有一些指令没有说明和例子，因为我没有在正常使用中看到过这些指令，它们的存在是从这里知道的：Android opcode constant list。
Opcode
操作码(hex)
Opcode name
操作码名称
Explanation
说明
Example
示例
00
nop
无操作
0000 - nop
01
move vx, vy
移动vy的内容到vx。两个寄存器都必须在最初的256寄存器范围以内。
0110 - move v0, v1
移动v1寄存器中的内容到v0。
02
move/from16 vx, vy
移动vy的内容到vx。vy可能在64K寄存器范围以内，而vx则是在最初的256寄存器范围以内。
0200 1900 - move/from16 v0, v25
移动v25寄存器中的内容到v0。
03
move/16
未知注4
04
move-wide
未知注4
05
move-wide/from16 vx, vy
移动一个long/double值，从vy到vx。vy可能在64K寄存器范围以内，而vx则是在最初的256寄存器范围以内。
0516 0000 - move-wide/from16 v22, v0
移动v0,v1寄存器中的内容到 v22,v23。
06
move-wide/16
未知注4
07
move-object vx, vy
移动对象引用，从vy到vx。
0781 - move-object v1, v8
移动v8寄存器中的对象引用到v1。
08
move-object/from16 vx, vy
移动对象引用，从vy到vx。vy可以处理64K寄存器地址，vx可以处理256寄存器地址。
0801 1500 - move-object/from16 v1, v21
移动v21寄存器中的对象引用到v1。
09
move-object/16
未知注4
0A
move-result vx
移动上一次方法调用的返回值到vx。
0A00 - move-result v0
移动上一次方法调用的返回值到v0。
0B
move-result-wide vx
移动上一次方法调用的long/double型返回值到vx,vx+1。
0B02 - move-result-wide v2
移动上一次方法调用的long/double型返回值到v2,v3。
0C
move-result-object vx
移动上一次方法调用的对象引用返回值到vx。
0C00 - move-result-object v0
移动上一次方法调用的对象引用返回值到v0。
0D
move-exception vx
当方法调用抛出异常时移动异常对象引用到vx。
0D19 - move-exception v25
当方法调用抛出异常时移动异常对象引用到v25。
0E
return-void
返回空值。
0E00 - return-void
返回值为void，即无返回值，并非返回null。
0F
return vx
返回在vx寄存器的值。
0F00 - return v0
返回v0寄存器中的值。
10
return-wide vx
返回在vx,vx+1寄存器的double/long值。
1000 - return-wide v0
返回v0,v1寄存器中的double/long值。
11
return-object vx
返回在vx寄存器的对象引用。
1100 - return-object v0
返回v0寄存器中的对象引用。
12
const/4 vx, lit4
存入4位常量到vx。
1221 - const/4 v1, #int 2
存入int型常量2到v1。目的寄存器在第二个字节的低4位，常量2在更高的4位。
13
const/16 vx, lit16
存入16位常量到vx。
1300 0A00 - const/16 v0, #int 10
存入int型常量10到v0。
14
const vx, lit32
存入int 型常量到vx。
1400 4E61 BC00 - const v0, #12345678 // #00BC614E
存入常量12345678到v0。
15
const/high16 v0, lit16
存入16位常量到最高位寄存器，用于初始化float值。
1500 2041 - const/high16 v0, #float 10.0 // #41200000
存入float常量10.0到v0。该指令最高支持16位浮点数。
16
const-wide/16 vx, lit16
存入int常量到vx,vx+1寄存器，扩展int型常量为long常量。
1600 0A00 - const-wide/16 v0, #long 10
存入long常量10到v0,v1寄存器。
17
const-wide/32 vx, lit32
存入32位常量到vx,vx+1寄存器，扩展int型常量到long常量。
1702 4e61 bc00 - const-wide/32 v2, #long 12345678 // #00bc614e
存入long常量12345678到v2,v3寄存器。
18
const-wide vx, lit64
存入64位常量到vx,vx+1寄存器。
1802 874b 6b5d 54dc 2b00- const-wide v2, #long 12345678901234567 // #002bdc545d6b4b87
存入long常量12345678901234567到v2,v3寄存器。
19
const-wide/high16 vx, lit16
存入16位常量到最高16位的vx,vx+1寄存器，用于初始化double 值。
1900 2440 - const-wide/high16 v0, #double 10.0 // #402400000
存入double常量10.0到v0,v1。
1A
const-string vx, 字符串ID
存入字符串常量引用到vx，通过字符串ID或字符串。
1A08 0000 - const-string v8, "" // string@0000
存入string@0000（字符串表#0条目）的引用到v8。
1B
const-string-jumbo
未知注4
1C
const-class vx, 类型ID
存入类对象常量到vx，通过类型ID或类型（如Object.class）。
1C00 0100 - const-class v0, Test3 // type@0001
存入Test3.class（类型ID表#1条目）的引用到v0。
1D
monitor-enter vx
获得vx寄存器中的对象引用的监视器。
1D03 - monitor-enter v3
获得v3寄存器中的对象引用的监视器。
1E
monitor-exit
释放vx寄存器中的对象引用的监视器。
1E03 - monitor-exit v3
释放v3寄存器中的对象引用的监视器。
1F
check-cast vx, 类型ID
检查vx寄存器中的对象引用是否可以转换成类型ID对应类型的实例。如不可转换，抛出ClassCastException 异常，否则继续执行。
1F04 0100 - check-cast v4, Test3 // type@0001
检查v4寄存器中的对象引用是否可以转换成Test3（类型ID表#1条目）的实例。
20
instance-of vx, vy,类型ID
检查vy寄存器中的对象引用是否是类型ID对应类型的实例，如果是，vx存入非0值，否则vx存入0。
2040 0100 - instance-of v0, v4, Test3 // type@0001
检查v4寄存器中的对象引用是否是Test3（类型ID表#1条目）的实例。如果是，v0存入非0值，否则v0存入0。
21
array-length vx, vy
计算vy寄存器中数组引用的元素长度并将长度存入vx。
2111 - array-length v0, v1
计算v1寄存器中数组引用的元素长度并将长度存入v0。
22
new-instance vx, 类型ID
根据类型ID或类型新建一个对象实例，并将新建的对象的引用存入vx。
2200 1500 - new-instance v0, java.io.FileInputStream // type@0015
实例化java.io.FileInputStream（类型ID表#15H条目）类型，并将其对象引用存入v0。
23
new-array vx, vy,类型ID
根据类型ID或类型新建一个数组，vy存入数组的长度，vx存入数组的引用。
2312 2500 - new-array v2, v1, char[] // type@0025
新建一个char（类型ID表#25H条目）数组，v1存入数组的长度，v2存入数组的引用。
24
filled-new-array {参数}, 类型ID
根据类型ID或类型新建一个数组并通过参数填充注5。新的数组引用可以得到一个move-result-object指令，前提是执行过filled-new-array 指令。
2420 530D 0000 - filled-new-array {v0,v0},[I // type@0D53
新建一个int（类型ID表#D53H条目）数组，长度将为2并且2个元素将填充到v0寄存器。
25
filled-new-array-range {vx..vy}, 类型ID
根据类型ID或类型新建一个数组并以寄存器范围为参数填充。新的数组引用可以得到一个move-result-object指令，前提是执行过filled-new-array 指令。
2503 0600 1300 - filled-new-array/range {v19..v21}, [B // type@0006
新建一个byte（类型ID表#6条目）数组，长度将为3并且3个元素将填充到v19,v20,v21寄存器注4。
26
fill-array-data vx, 偏移量
用vx的静态数据填充数组引用。静态数据的位址是当前指令位置加偏移量的和。
2606 2500 0000 - fill-array-data v6, 00e6 // +0025
用当前指令位置+25H的静态数据填充v6寄存器的数组引用。偏移量是32位的数字，静态数据的存储格式如下：
0003 // 表类型：静态数组数据
0400 // 每个元素的字节数（这个例子是4字节的int型）
0300 0000 // 元素个数
0100 0000 // 元素 #0：int 1
0200 0000 // 元素 #1：int 2
0300 0000 // 元素 #2：int 3
27
throw vx
抛出异常对象，异常对象的引用在vx寄存器。
2700 - throw v0
抛出异常对象，异常对象的引用在v0寄存器。
28
goto 目标
通过短偏移量注2无条件跳转到目标。
28F0 - goto 0005 // -0010
跳转到当前位置-16（hex 10）的位置，0005是目标指令标签。
29
goto/16目标
通过16位偏移量注2无条件跳转到目标。
2900 0FFE - goto/16 002f // -01f1
跳转到当前位置-1F1H的位置，002f是目标指令标签。
2A
goto/32目标
通过32位偏移量注2无条件跳转到目标。
2B
packed-switch vx, 索引表偏移量
实现一个switch 语句，case常量是连续的。这个指令使用索引表，vx是在表中找到具体case的指令偏移量的索引，如果无法在表中找到vx对应的索引将继续执行下一个指令（即default case）。
2B02 0C00 0000 - packed-switch v2, 000c // +000c
根据v2寄存器中的值执行packed switch，索引表的位置是当前指令位置+0CH，表如下所示：
0001 // 表类型：packed switch表
0300 // 元素个数
0000 0000 // 基础元素
0500 0000 0: 00000005 // case 0: +00000005
0700 0000 1: 00000007 // case 1: +00000007
0900 0000 2: 00000009 // case 2: +00000009
2C
sparse-switch vx, 查询表偏移量
实现一个switch 语句，case常量是非连续的。这个指令使用查询表，用于表示case常量和每个case常量的偏移量。如果vx无法在表中匹配将继续执行下一个指令（即default case）。
2C02 0c00 0000 - sparse-switch v2, 000c // +000c
根据v2寄存器中的值执行sparse switch ，查询表的位置是当前指令位置+0CH，表如下所示：
0002 // 表类型：sparse switch表
0300 // 元素个数
9cff ffff // 第一个case常量: -100
fa00 0000 // 第二个case常量: 250
e803 0000 // 第三个case常量: 1000
0500 0000 // 第一个case常量的偏移量: +5
0700 0000 // 第二个case常量的偏移量: +7
0900 0000 // 第三个case常量的偏移量: +9
2D
cmpl-float vx, vy, vz
比较vy和vz的float值并在vx存入int型返回值注3。
2D00 0607 - cmpl-float v0, v6, v7
比较v6和v7的float值并在v0存入int型返回值。非数值默认为小于。如果参数为非数值将返回-1。
2E
cmpg-float vx, vy, vz
比较vy和vz的float值并在vx存入int型返回值注3。
2E00 0607 - cmpg-float v0, v6, v7
比较v6和v7的float值并在v0存入int型返回值。非数值默认为大于。如果参数为非数值将返回1。
2F
cmpl-double vx, vy, vz
比较vy和vz注2的double值并在vx存入int型返回值注3。
2F19 0608 - cmpl-double v25, v6, v8
比较v6,v7和v8,v9的double值并在v25存入int型返回值。非数值默认为小于。如果参数为非数值将返回-1。
30
cmpg-double vx, vy, vz
比较vy和vz注2的double值并在vx存入int型返回值注3。
3000 080A - cmpg-double v0, v8, v10
比较v8,v9和v10,v11的double值并在v0存入int型返回值。非数值默认为大于。如果参数为非数值将返回1。
31
cmp-long vx, vy, vz
比较vy和vz的long值并在vx存入int型返回值注3。
3100 0204 - cmp-long v0, v2, v4
比较v2和v4的long值并在v0存入int型返回值。
32
if-eq vx,vy, 目标
如果vx == vy注2，跳转到目标。vx和vy是int型值。
32b3 6600 - if-eq v3, v11, 0080 // +0066
如果v3 == v11，跳转到当前位置+66H。0080是目标指令标签。
33
if-ne vx,vy, 目标
如果vx != vy注2，跳转到目标。vx和vy是int型值。
33A3 1000 - if-ne v3, v10, 002c // +0010
如果v3 != v10，跳转到当前位置+10H。002c是目标指令标签。
34
if-lt vx,vy, 目标
如果vx < vy注2，跳转到目标。vx和vy是int型值。
3432 CBFF - if-lt v2, v3, 0023 // -0035
如果v2 < v3，跳转到当前位置-35H。0023是目标指令标签。
35
if-ge vx, vy, 目标
如果vx >= vy注2，跳转到目标。vx和vy是int型值。
3510 1B00 - if-ge v0, v1, 002b // +001b
如果v0 >= v1，跳转到当前位置+1BH。002b是目标指令标签。
36
if-gt vx,vy, 目标
如果vx > vy注2，跳转到目标。vx和vy是int型值。
3610 1B00 - if-ge v0, v1, 002b // +001b
如果v0 > v1，跳转到当前位置+1BH。002b是目标指令标签。
37
if-le vx,vy, 目标
如果vx <= vy注2，跳转到目标。vx和vy是int型值。
3756 0B00 - if-le v6, v5, 0144 // +000b
如果v6 <= v5，跳转到当前位置+0BH。0144是目标指令标签。
38
if-eqz vx, 目标
如果vx == 0注2，跳转到目标。vx是int型值。
3802 1900 - if-eqz v2, 0038 // +0019
如果v2 == 0，跳转到当前位置+19H。0038是目标指令标签。
39
if-nez vx, 目标
如果vx != 0注2，跳转到目标。
3902 1200 - if-nez v2, 0014 // +0012
如果v2 != 0，跳转到当前位置+18(hex 12)。0014是目标指令标签。
3A
if-ltz vx, 目标
如果vx < 0注2，跳转到目标。
3A00 1600 - if-ltz v0, 002d // +0016
如果v0 < 0，跳转到当前位置+16H。002d是目标指令标签。
3B
if-gez vx, 目标
如果vx >= 0注2，跳转到目标。
3B00 1600 - if-gez v0, 002d // +0016
如果v0 >= 0，跳转到当前位置+16H。002d是目标指令标签。
3C
if-gtz vx, 目标
如果vx > 0注2，跳转到目标。
3C00 1D00 - if-gtz v0, 004a // +001d
如果v0 > 0，跳转到当前位置+1DH。004a是目标指令标签。
3D
if-lez vx, 目标
如果vx <= 0注2，跳转到目标。
3D00 1D00 - if-lez v0, 004a // +001d
如果v0 <= 0，跳转到当前位置+1DH。004a是目标指令标签。
3E
unused_3E
未使用
3F
unused_3F
未使用
40
unused_40
未使用
41
unused_41
未使用
42
unused_42
未使用
43
unused_43
未使用
44
aget vx, vy, vz
从int数组获取一个int型值到vx，对象数组的引用位于vy，需获取的元素的索引位于vz。
4407 0306 - aget v7, v3, v6
从数组获取一个int型值到v7，对象数组的引用位于v3，需获取的元素的索引位于v6。
45
aget-wide vx, vy, vz
从long/double数组获取一个long/double值到vx,vx+1，数组的引用位于vy，需获取的元素的索引位于vz。
4505 0104 - aget-wide v5, v1, v4
从long/double数组获取一个long/double值到v5,vx6，数组的引用位于v1，需获取的元素的索引位于v4。
46
aget-object vx, vy, vz
从对象引用数组获取一个对象引用到vx，对象数组的引用位于vy，需获取的元素的索引位于vz。
4602 0200 - aget-object v2, v2, v0
从对象引用数组获取一个对象引用到v2，对象数组的引用位于v2，需获取的元素的索引位于v0。
47
aget-boolean vx, vy, vz
从boolean数组获取一个boolean值到vx，数组的引用位于vy，需获取的元素的索引位于vz。
4700 0001 - aget-boolean v0, v0, v1
从boolean数组获取一个boolean值到v0，数组的引用位于v0，需获取的元素的索引位于v1。
48
aget-byte vx, vy, vz
从byte数组获取一个byte值到vx，数组的引用位于vy，需获取的元素的索引位于vz。
4800 0001 - aget-byte v0, v0, v1
从byte数组获取一个byte值到v0，数组的引用位于v0，需获取的元素的索引位于v1。
49
aget-char vx, vy, vz
从char数组获取一个char值到vx，数组的引用位于vy，需获取的元素的索引位于vz。
4905 0003 - aget-char v5, v0, v3
从char数组获取一个char值到v5，数组的引用位于v0，需获取的元素的索引位于v3。
4A
aget-short vx, vy, vz
从short数组获取一个short值到vx，数组的引用位于vy，需获取的元素的索引位于vz。
4A00 0001 - aget-short v0, v0, v1
从short数组获取一个short值到v0，数组的引用位于v0，需获取的元素的索引位于v1。
4B
aput vx, vy, vz
将vx的int值作为元素存入int数组，数组的引用位于vy，元素的索引位于vz。
4B00 0305 - aput v0, v3, v5
将v0的int值作为元素存入int数组，数组的引用位于v3，元素的索引位于v5。
4C
aput-wide vx, vy, vz
将vx,vx+1的double/long值作为元素存入double/long数组，数组的引用位于vy，元素的索引位于vz。
4C05 0104 - aput-wide v5, v1, v4
将v5,v6的double/long值作为元素存入double/long数组，数组的引用位于v1，元素的索引位于v4。
4D
aput-object vx, vy, vz
将vx的对象引用作为元素存入对象引用数组，数组的引用位于vy，元素的索引位于vz。
4D02 0100 - aput-object v2, v1, v0
将v2的对象引用作为元素存入对象引用数组，数组的引用位于v1，元素的索引位于v0。
4E
aput-boolean vx, vy, vz
将vx的boolean值作为元素存入boolean数组，数组的引用位于vy，元素的索引位于vz。
4E01 0002 - aput-boolean v1, v0, v2
将v1的boolean值作为元素存入boolean数组，数组的引用位于v0，元素的索引位于v2。
4F
aput-byte vx, vy, vz
将vx的byte值作为元素存入byte数组，数组的引用位于vy，元素的索引位于vz。
4F02 0001 - aput-byte v2, v0, v1
将v2的byte值作为元素存入byte数组，数组的引用位于v0，元素的索引位于v1。
50
aput-char vx, vy, vz
将vx的char值作为元素存入char数组，数组的引用位于vy，元素的索引位于vz。
5003 0001 - aput-char v3, v0, v1
将v3的char值作为元素存入char数组，数组的引用位于v0，元素的索引位于v1。
51
aput-short vx, vy, vz
将vx的short值作为元素存入short数组，数组的引用位于vy，元素的索引位于vz。
5102 0001 - aput-short v2, v0, v1
将v2的short值作为元素存入short数组，数组的引用位于v0，元素的索引位于v1。
52
iget vx, vy, 字段ID
根据字段ID读取实例的int型字段到vx，vy寄存器中是该实例的引用。
5210 0300 - iget v0, v1, Test2.i6:I // field@0003
读取int型字段i6（字段表#3条目）到v0，v1寄存器中是Test2实例的引用。
53
iget-wide vx, vy, 字段ID
根据字段ID读取实例的double/long型字段到vx,vx+1注1，vy寄存器中是该实例的引用。
5320 0400 - iget-wide v0, v2, Test2.l0:J // field@0004
读取long型字段l0（字段表#4条目）到v0,v1，v2寄存器中是Test2实例的引用。
54
iget-object vx, vy, 字段ID
根据字段ID读取一个实例的对象引用字段到vx，vy寄存器中是该实例的引用。
iget-object v1, v2, LineReader.fis:Ljava/io/FileInputStream; // field@0002
读取FileInputStream对象引用字段fis（字段表#2条目）到v1，v2寄存器中是LineReader实例的引用。
55
iget-boolean vx, vy, 字段ID
根据字段ID读取实例的boolean型字段到vx，vy寄存器中是该实例的引用。
55FC 0000 - iget-boolean v12, v15, Test2.b0:Z // field@0000
读取boolean型字段b0（字段表#0条目）到v12，v15寄存器中是Test2实例的引用。
56
iget-byte vx, vy, 字段ID
根据字段ID读取实例的byte型字段到vx，vy寄存器中是该实例的引用。
5632 0100 - iget-byte v2, v3, Test3.bi1:B // field@0001
读取byte型字段bi1（字段表#1条目）到v2，v3寄存器中是Test2实例的引用。
57
iget-char vx, vy, 字段ID
根据字段ID读取实例的char型字段到vx，vy寄存器中是该实例的引用。
5720 0300 - iget-char v0, v2, Test3.ci1:C // field@0003
读取char型字段bi1（字段表#3条目）到v0，v2寄存器中是Test2实例的引用。
58
iget-short vx, vy, 字段ID
根据字段ID读取实例的short型字段到vx，vy寄存器中是该实例的引用。
5830 0800 - iget-short v0, v3, Test3.si1:S // field@0008
读取short型字段si1（字段表#8条目）到v0，v3寄存器中是Test2实例的引用。
59
iput vx, vy, 字段ID
根据字段ID将vx寄存器的值存入实例的int型字段，vy寄存器中是该实例的引用。
5920 0200 - iput v0, v2, Test2.i6:I // field@0002
将v0寄存器的值存入实例的int型字段i6（字段表#2条目），v2寄存器中是Test2实例的引用。
5A
iput-wide vx, vy, 字段ID
根据字段ID将vx,vx+1寄存器的值存入实例的double/long型字段，vy寄存器中是该实例的引用。
5A20 0000 - iput-wide v0, v2, Test2.d0:D // field@0000
将v0,v1寄存器的值存入实例的double型字段d0（字段表#0条目），v2寄存器中是Test2实例的引用。
5B
iput-object vx, vy, 字段ID
根据字段ID将vx寄存器的值存入实例的对象引用字段，vy寄存器中是该实例的引用。
5B20 0000 - iput-object v0, v2, LineReader.bis:Ljava/io/BufferedInputStream; // field@0000
将v0寄存器的值存入实例的对象引用字段bis（字段表#0条目），v2寄存器中是BufferedInputStream实例的引用。
5C
iput-boolean vx, vy, 字段ID
根据字段ID将vx寄存器的值存入实例的boolean型字段，vy寄存器中是该实例的引用。
5C30 0000 - iput-boolean v0, v3, Test2.b0:Z // field@0000
将v0寄存器的值存入实例的boolean型字段b0（字段表#0条目），v3寄存器中是Test2实例的引用。
5D
iput-byte vx, vy, 字段ID
根据字段ID将vx寄存器的值存入实例的byte型字段，vy寄存器中是该实例的引用。
5D20 0100 - iput-byte v0, v2, Test3.bi1:B // field@0001
将v0寄存器的值存入实例的byte型字段bi1（字段表#1条目），v2寄存器中是Test2实例的引用。
5E
iput-char vx, vy, 字段ID
根据字段ID将vx寄存器的值存入实例的char型字段，vy寄存器中是该实例的引用。
5E20 0300 - iput-char v0, v2, Test3.ci1:C // field@0003
将v0寄存器的值存入实例的char型字段ci1（字段表#3条目），v2寄存器中是Test2实例的引用。
5F
iput-short vx, vy, 字段ID
根据字段ID将vx寄存器的值存入实例的short型字段，vy寄存器中是该实例的引用。
5F21 0800 - iput-short v1, v2, Test3.si1:S // field@0008
将v0寄存器的值存入实例的short型字段si1（字段表#8条目），v2寄存器中是Test2实例的引用。
60
sget vx, 字段ID
根据字段ID读取静态int型字段到vx。
6000 0700 - sget v0, Test3.is1:I // field@0007
读取Test3的静态int型字段is1（字段表#7条目）到v0。
61
sget-wide vx, 字段ID
根据字段ID读取静态double/long型字段到vx,vx+1。
6100 0500 - sget-wide v0, Test2.l1:J // field@0005
读取Test2的静态long型字段l1（字段表#5条目）到v0,v1。
62
sget-object vx, 字段ID
根据字段ID读取静态对象引用字段到vx。
6201 0C00 - sget-object v1, Test3.os1:Ljava/lang/Object; // field@000c
读取Object的静态对象引用字段os1（字段表#CH条目）到v1。
63
sget-boolean vx, 字段ID
根据字段ID读取静态boolean型字段到vx。
6300 0C00 - sget-boolean v0, Test2.sb:Z // field@000c
读取Test2的静态boolean型字段sb（字段表#CH条目）到v0。
64
sget-byte vx, 字段ID
根据字段ID读取静态byte型字段到vx。
6400 0200 - sget-byte v0, Test3.bs1:B // field@0002
读取Test3的静态byte型字段bs1（字段表#2条目）到v0。
65
sget-char vx, 字段ID
根据字段ID读取静态char型字段到vx。
6500 0700 - sget-char v0, Test3.cs1:C // field@0007
读取Test3的静态char型字段cs1（字段表#7条目）到v0。
66
sget-short vx, 字段ID
根据字段ID读取静态short型字段到vx。
6600 0B00 - sget-short v0, Test3.ss1:S // field@000b
读取Test3的静态short型字段ss1（字段表#CH条目）到v0。
67
sput vx, 字段ID
根据字段ID将vx寄存器中的值赋值到int型静态字段。
6700 0100 - sput v0, Test2.i5:I // field@0001
将v0寄存器中的值赋值到Test2的int型静态字段i5（字段表#1条目）。
68
sput-wide vx, 字段ID
根据字段ID将vx,vx+1寄存器中的值赋值到double/long型静态字段。
6800 0500 - sput-wide v0, Test2.l1:J // field@0005
将v0,v1寄存器中的值赋值到Test2的long型静态字段l1（字段表#5条目）。
69
sput-object vx, 字段ID
根据字段ID将vx寄存器中的对象引用赋值到对象引用静态字段。
6900 0c00 - sput-object v0, Test3.os1:Ljava/lang/Object; // field@000c
将v0寄存器中的对象引用赋值到Test3的对象引用静态字段os1（字段表#CH条目）。
6A
sput-boolean vx, 字段ID
根据字段ID将vx寄存器中的值赋值到boolean型静态字段。
6A00 0300 - sput-boolean v0, Test3.bls1:Z // field@0003
将v0寄存器中的值赋值到Test3的boolean型静态字段bls1（字段表#3条目）。
6B
sput-byte vx, 字段ID
根据字段ID将vx寄存器中的值赋值到byte型静态字段。
6B00 0200 - sput-byte v0, Test3.bs1:B // field@0002
将v0寄存器中的值赋值到Test3的byte型静态字段bs1（字段表#2条目）。
6C
sput-char vx, 字段ID
根据字段ID将vx寄存器中的值赋值到char型静态字段。
6C01 0700 - sput-char v1, Test3.cs1:C // field@0007
将v1寄存器中的值赋值到Test3的char型静态字段cs1（字段表#7条目）。
6D
sput-short vx, 字段ID
根据字段ID将vx寄存器中的值赋值到short型静态字段。
6D00 0B00 - sput-short v0, Test3.ss1:S // field@000b
将v0寄存器中的值赋值到Test3的short型静态字段ss1（字段表#BH条目）。
6E
invoke-virtual {参数}, 方法名
调用带参数的虚拟方法。
6E53 0600 0421 - invoke-virtual { v4, v0, v1, v2, v3}, Test2.method5:(IIII)V // method@0006
调用Test2的method5（方法表#6条目）方法，该指令共有5个参数（操作码第二个字节的4个最高有效位5）注5。参数v4是"this"实例，v0, v1, v2, v3是method5方法的参数，(IIII)V的4个I分表表示4个int型参数，V表示返回值为void。
6F
invoke-super {参数}, 方法名
调用带参数的直接父类的虚拟方法。
6F10 A601 0100 invoke-super {v1},java.io.FilterOutputStream.close:()V // method@01a6
调用java.io.FilterOutputStream的close（方法表#1A6条目）方法，参数v1是"this"实例。()V表示close方法没有参数，V表示返回值为void。
70
invoke-direct {参数}, 方法名
不解析直接调用带参数的方法。
7010 0800 0100 - invoke-direct {v1}, java.lang.Object.<init>:()V // method@0008
调用java.lang.Object 的<init>（方法表#8条目）方法，参数v1是"this"实例注5。()V表示<init>方法没有参数，V表示返回值为void。
71
invoke-static {参数}, 方法名
调用带参数的静态方法。
7110 3400 0400 - invoke-static {v4}, java.lang.Integer.parseInt:( Ljava/lang/String;)I // method@0034
调用java.lang.Integer 的parseInt（方法表#34条目）静态方法，该指令只有1个参数v4注5，(Ljava/lang/String;)I中的Ljava/lang/String;表示parseInt方法需要String类型的参数，I表示返回值为int型。
72
invoke-interface {参数}, 方法名
调用带参数的接口方法。
7240 2102 3154 invoke-interface {v1, v3, v4, v5}, mwfw.IReceivingProtocolAdapter.receivePackage:(ILjava/lang/String;Ljava/io/InputStream;)Z // method@0221
调用mwfw.IReceivingProtocolAdapter 接口的receivePackage方法（方法表#221条目），该指令共有4个参数注5，参数v1是"this"实例，v3,v4,v5是receivePackage方法的参数，(ILjava/lang/String;Ljava/io/InputStream;)Z中的I表示int型参数，Ljava/lang/String;表示String类型参数，Ljava/io/InputStream;表示InputStream类型参数，Z表示返回值为boolean型。
73
unused_73
未使用
74
invoke-virtual/range {vx..vy}, 方法名
调用以寄存器范围为参数的虚拟方法。该指令第一个寄存器和寄存器的数量将传递给方法。
7403 0600 1300 - invoke-virtual {v19..v21}, Test2.method5:(IIII)V // method@0006
调用Test2的method5（方法表#6条目）方法，该指令共有3个参数。参数v19是"this"实例，v20,v21是method5方法的参数，(IIII)V的4个I分表表示4个int型参数，V表示返回值为void。
75
invoke-super/range {vx..vy}, 方法名
调用以寄存器范围为参数的直接父类的虚拟方法。该指令第一个寄存器和寄存器的数量将会传递给方法。
7501 A601 0100 invoke-super {v1},java.io.FilterOutputStream.close:()V // method@01a6
调用java.io.FilterOutputStream的close（方法表#1A6条目）方法，参数v1是"this"实例。()V表示close方法没有参数，V表示返回值为void。
76
invoke-direct/range {vx..vy}, 方法名
不解析直接调用以寄存器范围为参数的方法。该指令第一个寄存器和寄存器的数量将会传递给方法。
7603 3A00 1300 - invoke-direct/range {v19..21},java.lang.Object.<init>:()V // method@003a
调用java.lang.Object 的<init>（方法表#3A条目）方法，参数v19是"this"实例（操作码第五、第六字节表示范围从v19开始，第二个字节为03表示传入了3个参数），()V表示<init>方法没有参数，V表示返回值为void。
77
invoke-static/range {vx..vy}, 方法名
调用以寄存器范围为参数的静态方法。该指令第一个寄存器和寄存器的数量将会传递给方法。
7703 3A00 1300 - invoke-static/range {v19..21},java.lang.Integer.parseInt:(Ljava/lang/String;)I // method@0034
调用java.lang.Integer 的parseInt（方法表#34条目）静态方法，参数v19是"this"实例（操作码第五、第六字节表示范围从v19开始，第二个字节为03表示传入了3个参数），(Ljava/lang/String;)I中的Ljava/lang/String;表示parseInt方法需要String类型的参数，I表示返回值为int型。
78
invoke-interface-range {vx..vy}, 方法名
调用以寄存器范围为参数的接口方法。该指令第一个寄存器和寄存器的数量将会传递给方法。
7840 2102 0100 invoke-interface {v1..v4}, mwfw.IReceivingProtocolAdapter.receivePackage:(ILjava/lang/String;Ljava/io/InputStream;)Z // method@0221
调用mwfw.IReceivingProtocolAdapter 接口的receivePackage方法（方法表#221条目），该指令共有4个参数注5，参数v1是"this"实例，v2,v3,v4是receivePackage方法的参数，(ILjava/lang/String;Ljava/io/InputStream;)Z中的I表示int型参数，Ljava/lang/String;表示String类型参数，Ljava/io/InputStream;表示InputStream类型参数，Z表示返回值为boolean型。
79
unused_79
未使用
7A
unused_7A
未使用
7B
neg-int vx, vy
计算vx = -vy并将结果存入vx。
7B01 - neg-int v1,v0
计算-v0并将结果存入v1。
7C
not-int vx, vy
未知注4
7D
neg-long vx, vy
计算vx,vx+1 = -(vy,vy+1) 并将结果存入vx,vx+1。
7D02 - neg-long v2,v0
计算-(v0,v1) 并将结果存入(v2,v3)。
7E
not-long vx, vy
未知注4
7F
neg-float vx, vy
计算vx = -vy并将结果存入vx。
7F01 - neg-float v1,v0
计算-v0并将结果存入v1。
80
neg-double vx, vy
计算vx,vx+1=-(vy,vy+1) 并将结果存入vx,vx+1。
8002 - neg-double v2,v0
计算-(v0,v1) 并将结果存入(v2,v3)。
81
int-to-long vx, vy
转换vy寄存器中的int型值为long型值存入vx,vx+1。
8106 - int-to-long v6, v0
转换v0寄存器中的int型值为long型值存入v6,v7。
82
int-to-float vx, vy
转换vy寄存器中的int型值为float型值存入vx。
8206 - int-to-float v6, v0
转换v0寄存器中的int型值为float型值存入v6。
83
int-to-double vx, vy
转换vy寄存器中的int型值为double型值存入vx,vx+1。
8306 - int-to-double v6, v0
转换v0寄存器中的int型值为double型值存入v6,v7。
84
long-to-int vx, vy
转换vy,vy+1寄存器中的long型值为int型值存入vx。
8424 - long-to-int v4, v2
转换v2,v3寄存器中的long型值为int型值存入v4。
85
long-to-float vx, vy
转换vy,vy+1寄存器中的long型值为float型值存入vx。
8510 - long-to-float v0, v1
转换v1,v2寄存器中的long型值为float型值存入v0。
86
long-to-double vx, vy
转换vy,vy+1寄存器中的long型值为double型值存入vx,vx+1。
8610 - long-to-double v0, v1
转换v1,vy2寄存器中的long型值为double型值存入v0,v1。
87
float-to-int vx, vy
转换vy寄存器中的float型值为int型值存入vx。
8730 - float-to-int v0, v3
转换v3寄存器中的float型值为int型值存入v0。
88
float-to-long vx, vy
转换vy寄存器中的float型值为long型值存入vx,vx+1。
8830 - float-to-long v0, v3
转换v3寄存器中的float型值为long型值存入v0,v1。
89
float-to-double vx, vy
转换vy寄存器中的float型值为double型值存入vx,vx+1。
8930 - float-to-double v0, v3
转换v3寄存器中的float型值为double型值存入v0,v1。
8A
double-to-int vx, vy
转换vy,vy+1寄存器中的double型值为int型值存入vx。
8A40 - double-to-int v0, v4
转换v4,v5寄存器中的double型值为int型值存入v0。
8B
double-to-long vx, vy
转换vy,vy+1寄存器中的double型值为long型值存入vx,vx+1。
8B40 - double-to-long v0, v4
转换v4,v5寄存器中的double型值为long型值存入v0,v1。
8C
double-to-float vx, vy
转换vy,vy+1寄存器中的double型值为float型值存入vx。
8C40 - double-to-float v0, v4
转换v4,v5寄存器中的double型值为float型值存入v0。
8D
int-to-byte vx, vy
转换vy寄存器中的int型值为byte型值存入vx。
8D00 - int-to-byte v0, v0
转换v0寄存器中的int型值为byte型值存入v0。
8E
int-to-char vx, vy
转换vy寄存器中的int型值为char型值存入vx。
8E33 - int-to-char v3, v3
转换v3寄存器中的int型值为char型值存入v3。
8F
int-to-short vx, vy
转换vy寄存器中的int型值为short型值存入vx。
8F00 - int-to-short v3, v0
转换v0寄存器中的int型值为short型值存入v0。
90
add-int vx, vy, vz
计算vy + vz并将结果存入vx。
9000 0203 - add-int v0, v2, v3
计算v2 + v3并将结果存入v0注4。
91
sub-int vx, vy, vz
计算vy - vz并将结果存入vx。
9100 0203 - sub-int v0, v2, v3
计算v2 – v3并将结果存入v0。
92
mul-int vx, vy, vz
计算vy * vz并将结果存入vx。
9200 0203 - mul-int v0,v2,v3
计算v2 * w3并将结果存入v0。
93
div-int vx, vy, vz
计算vy / vz并将结果存入vx。
9303 0001 - div-int v3, v0, v1
计算v0 / v1并将结果存入v3。
94
rem-int vx, vy, vz
计算vy % vz并将结果存入vx。
9400 0203 - rem-int v0, v2, v3
计算v3 % v2并将结果存入v0。
95
and-int vx, vy, vz
计算vy 与 vz并将结果存入vx。
9503 0001 - and-int v3, v0, v1
计算v0 与 v1并将结果存入v3。
96
or-int vx, vy, vz
计算vy 或 vz并将结果存入vx。
9603 0001 - or-int v3, v0, v1
计算v0 或 v1并将结果存入v3。
97
xor-int vx, vy, vz
计算vy 异或 vz并将结果存入vx。
9703 0001 - xor-int v3, v0, v1
计算v0 异或 v1并将结果存入v3。
98
shl-int vx, vy, vz
左移vy，vz指定移动的位置，结果存入vx。
9802 0001 - shl-int v2, v0, v1
以v1指定的位置左移v0，结果存入v2。
99
shr-int vx, vy, vz
右移vy，vz指定移动的位置，结果存入vx。
9902 0001 - shr-int v2, v0, v1
以v1指定的位置右移v0，结果存入v2。
9A
ushr-int vx, vy, vz
无符号右移vy，vz指定移动的位置，结果存入vx。
9A02 0001 - ushr-int v2, v0, v1
以v1指定的位置无符号右移v0，结果存入v2。
9B
add-long vx, vy, vz
计算vy,vy+1 + vz,vz+1并将结果存入vx,vx+1注1。
9B00 0305 - add-long v0, v3, v5
计算v3,v4 + v5,v6并将结果存入v0,v1。
9C
sub-long vx, vy, vz
计算vy,vy+1 - vz,vz+1并将结果存入vx,vx+1注1。
9C00 0305 - sub-long v0, v3, v5
计算v3,v4 - v5,v6并将结果存入v0,v1。
9D
mul-long vx, vy, vz
计算vy,vy+1 * vz,vz+1并将结果存入vx,vx+1注1。
9D00 0305 - mul-long v0, v3, v5
计算v3,v4 * v5,v6并将结果存入v0,v1。
9E
div-long vx, vy, vz
计算vy,vy+1 / vz,vz+1并将结果存入vx,vx+1注1。
9E06 0002 - div-long v6, v0, v2
计算v0,v1 / v2,v3并将结果存入v6,v7。
9F
rem-long vx, vy, vz
计算vy,vy+1 % vz,vz+1并将结果存入vx,vx+1注1。
9F06 0002 - rem-long v6, v0, v2
计算v0,v1 % v2,v3并将结果存入v6,v7。
A0
and-long vx, vy, vz
计算vy,vy+1 与 vz,vz+1并将结果存入vx,vx+1注1。
A006 0002 - and-long v6, v0, v2
计算v0,v1 与 v2,v3并将结果存入v6,v7。
A1
or-long vx, vy, vz
计算vy,vy+1 或 vz,vz+1并将结果存入vx,vx+1注1。
A106 0002 - or-long v6, v0, v2
计算v0,v1 或 v2,v3并将结果存入v6,v7。
A2
xor-long vx, vy, vz
计算vy,vy+1 异或 vz,vz+1并将结果存入vx,vx+1注1。
A206 0002 - xor-long v6, v0, v2
计算v0,v1 异或 v2,v3并将结果存入v6,v7。
A3
shl-long vx, vy, vz
左移vy,vy+1，vz指定移动的位置，结果存入vx,vx+1注1。
A302 0004 - shl-long v2, v0, v4
以v4指定的位置左移v0,v1，结果存入v2,v3。
A4
shr-long vx, vy, vz
右移vy,vy+1，vz指定移动的位置，结果存入vx,vx+1注1。
A402 0004 - shr-long v2, v0, v4
以v4指定的位置右移v0,v1，结果存入v2,v3。
A5
ushr-long vx, vy, vz
无符号右移vy,vy+1，vz指定移动的位置，结果存入vx,vx+1注1。
A502 0004 - ushr-long v2, v0, v4
以v4指定的位置无符号右移v0,v1，结果存入v2,v3。
A6
add-float vx, vy, vz
计算vy + vz并将结果存入vx。
A600 0203 - add-float v0, v2, v3
计算v2 + v3并将结果存入v0。
A7
sub-float vx, vy, vz
计算vy - vz并将结果存入vx。
A700 0203 - sub-float v0, v2, v3
计算v2 - v3并将结果存入v0。
A8
mul-float vx, vy, vz
计算vy * vz并将结果存入vx。
A803 0001 - mul-float v3, v0, v1
计算v0 * v1并将结果存入v3。
A9
div-float vx, vy, vz
计算vy / vz并将结果存入vx。
A903 0001 - div-float v3, v0, v1
计算v0 / v1并将结果存入v3。
AA
rem-float vx, vy, vz
计算vy % vz并将结果存入vx。
AA03 0001 - rem-float v3, v0, v1
计算v0 % v1并将结果存入v3。
AB
add-double vx, vy, vz
计算vy,vy+1 + vz,vz+1并将结果存入vx,vx+1注1。
AB00 0305 - add-double v0, v3, v5
计算v3,v4 + v5,v6并将结果存入v0,v1。
AC
sub-double vx, vy, vz
计算vy,vy+1 - vz,vz+1并将结果存入vx,vx+1注1。
AC00 0305 - sub-double v0, v3, v5
计算v3,v4 - v5,v6并将结果存入v0,v1。
AD
mul-double vx, vy, vz
计算vy,vy+1 * vz,vz+1并将结果存入vx,vx+1注1。
AD06 0002 - mul-double v6, v0, v2
计算v0,v1 * v2,v3并将结果存入v6,v7。
AE
div-double vx, vy, vz
计算vy,vy+1 / vz,vz+1并将结果存入vx,vx+1注1。
AE06 0002 - div-double v6, v0, v2
计算v0,v1 / v2,v3并将结果存入v6,v7。
AF
rem-double vx, vy, vz
计算vy,vy+1 % vz,vz+1并将结果存入vx,vx+1注1。
AF06 0002 - rem-double v6, v0, v2
计算v0,v1 % v2,v3并将结果存入v6,v7。
B0
add-int/2addr vx, vy
计算vx + vy并将结果存入vx。
B010 - add-int/2addr v0,v1
计算v0 + v1并将结果存入v0。
B1
sub-int/2addr vx, vy
计算vx - vy并将结果存入vx。
B140 - sub-int/2addr v0, v4
计算v0 – v4并将结果存入v0。
B2
mul-int/2addr vx, vy
计算vx * vy并将结果存入vx。
B210 - mul-int/2addr v0, v1
计算v0 * v1并将结果存入v0。
B3
div-int/2addr vx, vy
计算vx / vy并将结果存入vx。
B310 - div-int/2addr v0, v1
计算v0 / v1并将结果存入v0。
B4
rem-int/2addr vx, vy
计算vx % vy并将结果存入vx。
B410 - rem-int/2addr v0, v1
计算v0 % v1并将结果存入v0。
B5
and-int/2addr vx, vy
计算vx 与 vy并将结果存入vx。
B510 - and-int/2addr v0, v1
计算v0 与 v1并将结果存入v0。
B6
or-int/2addr vx, vy
计算vx 或 vy并将结果存入vx。
B610 - or-int/2addr v0, v1
计算v0 或 v1并将结果存入v0。
B7
xor-int/2addr vx, vy
计算vx 异或 vy并将结果存入vx。
B710 - xor-int/2addr v0, v1
计算v0 异或 v1并将结果存入v0。
B8
shl-int/2addr vx, vy
左移vx，vy指定移动的位置，并将结果存入vx。
B810 - shl-int/2addr v0, v1
以v1指定的位置左移v0，结果存入v0。
B9
shr-int/2addr vx, vy
右移vx，vy指定移动的位置，并将结果存入vx。
B910 - shr-int/2addr v0, v1
以v1指定的位置右移v0，结果存入v0。
BA
ushr-int/2addr vx, vy
无符号右移vx，vy指定移动的位置，并将结果存入vx。
BA10 - ushr-int/2addr v0, v1
以v1指定的位置无符号右移v0，结果存入v0。
BB
add-long/2addr vx, vy
计算vx,vx+1 + vy,vy+1并将结果存入vx,vx+1注1。
BB20 - add-long/2addr v0, v2
计算v0,v1 + v2,v3并将结果存入v0,v1。
BC
sub-long/2addr vx, vy
计算vx,vx+1 - vy,vy+1并将结果存入vx,vx+1注1。
BC70 - sub-long/2addr v0, v7
计算v0,v1 - v7,v8并将结果存入v0,v1。
BD
mul-long/2addr vx, vy
计算vx,vx+1 * vy,vy+1并将结果存入vx,vx+1注1。
BD70 - mul-long/2addr v0, v7
计算v0,v1 * v7,v8并将结果存入v0,v1。
BE
div-long/2addr vx, vy
计算vx,vx+1 / vy,vy+1并将结果存入vx,vx+1注1。
BE20 - div-long/2addr v0, v2
计算v0,v1 / v2,v3并将结果存入v0,v1。
BF
rem-long/2addr vx, vy
计算vx,vx+1 % vy,vy+1并将结果存入vx,vx+1注1。
BF20 - rem-long/2addr v0, v2
计算v0,v1 % v2,v3并将结果存入v0,v1。
C0
and-long/2addr vx, vy
计算vx,vx+1 与 vy,vy+1并将结果存入vx,vx+1注1。
C020 - and-long/2addr v0, v2
计算v0,v1 与 v2,v3并将结果存入v0,v1。
C1
or-long/2addr vx, vy
计算vx,vx+1 或 vy,vy+1并将结果存入vx,vx+1注1。
C120 - or-long/2addr v0, v2
计算v0,v1 或 v2,v3并将结果存入v0,v1。
C2
xor-long/2addr vx, vy
计算vx,vx+1 异或 vy,vy+1并将结果存入vx,vx+1注1。
C220 - xor-long/2addr v0, v2
计算v0,v1 异或 v2,v3并将结果存入v0,v1。
C3
shl-long/2addr vx, vy
左移vx,vx+1，vy指定移动的位置，并将结果存入vx,vx+1。
C320 - shl-long/2addr v0, v2
以v2指定的位置左移v0,v1，结果存入v0,v1。
C4
shr-long/2addr vx, vy
右移vx,vx+1，vy指定移动的位置，并将结果存入vx,vx+1。
C420 - shr-long/2addr v0, v2
以v2指定的位置右移v0,v1，结果存入v0,v1。
C5
ushr-long/2addr vx, vy
无符号右移vx,vx+1，vy指定移动的位置，并将结果存入vx,vx+1。
C520 - ushr-long/2addr v0, v2
以v2指定的位置无符号右移v0,v1，结果存入v0,v1。
C6
add-float/2addr vx, vy
计算vx + vy并将结果存入vx。
C640 - add-float/2addr v0,v4
计算v0 + v4并将结果存入v0。
C7
sub-float/2addr vx, vy
计算vx - vy并将结果存入vx。
C740 - sub-float/2addr v0,v4
计算v0 - v4并将结果存入v0。
C8
mul-float/2addr vx, vy
计算vx * vy并将结果存入vx。
C810 - mul-float/2addr v0, v1
计算v0 * v1并将结果存入v0。
C9
div-float/2addr vx, vy
计算vx / vy并将结果存入vx。
C910 - div-float/2addr v0, v1
计算v0 / v1并将结果存入v0。
CA
rem-float/2addr vx, vy
计算vx % vy并将结果存入vx。
CA10 - rem-float/2addr v0, v1
计算v0 % v1并将结果存入v0。
CB
add-double/2addr vx, vy
计算vx,vx+1 + vy,vy+1并将结果存入vx,vx+1注1。
CB70 - add-double/2addr v0, v7
计算v0,v1 + v7,v8并将结果存入v0,v1。
CC
sub-double/2addr vx, vy
计算vx,vx+1 - vy,vy+1并将结果存入vx,vx+1注1。
CC70 - sub-double/2addr v0, v7
计算v0,v1 - v7,v8并将结果存入v0,v1。
CD
mul-double/2addr vx, vy
计算vx,vx+1 * vy,vy+1并将结果存入vx,vx+1注1。
CD20 - mul-double/2addr v0, v2
计算v0,v1 * v2,v3并将结果存入v0,v1。
CE
div-double/2addr vx, vy
计算vx,vx+1 / vy,vy+1并将结果存入vx,vx+1注1。
CE20 - div-double/2addr v0, v2
计算v0,v1 / v2,v3并将结果存入v0,v1。
CF
rem-double/2addr vx, vy
计算vx,vx+1 % vy,vy+1并将结果存入vx,vx+1注1。
CF20 - rem-double/2addr v0, v2
计算v0,v1 % v2,v3并将结果存入v0,v1。
D0
add-int/lit16 vx, vy, lit16
计算vy + lit16并将结果存入vx。
D001 D204 - add-int/lit16 v1, v0, #int 1234 // #04d2
计算v0 + 1234并将结果存入v1。
D1
sub-int/lit16 vx, vy, lit16
计算vy - lit16并将结果存入vx。
D101 D204 - sub-int/lit16 v1, v0, #int 1234 // #04d2
计算v0 - 1234并将结果存入v1。
D2
mul-int/lit16 vx, vy, lit16
计算vy * lit16并将结果存入vx。
D201 D204 - mul-int/lit16 v1, v0, #int 1234 // #04d2
计算v0 * 1234并将结果存入v1。
D3
div-int/lit16 vx, vy, lit16
计算vy / lit16并将结果存入vx。
D301 D204 - div-int/lit16 v1, v0, #int 1234 // #04d2
计算v0 / 1234并将结果存入v1。
D4
rem-int/lit16 vx, vy, lit16
计算vy % lit16并将结果存入vx。
D401 D204 - rem-int/lit16 v1, v0, #int 1234 // #04d2
计算v0 % 1234并将结果存入v1。
D5
and-int/lit16 vx, vy, lit16
计算vy 与 lit16并将结果存入vx。
D501 D204 - and-int/lit16 v1, v0, #int 1234 // #04d2
计算v0 与 1234并将结果存入v1。
D6
or-int/lit16 vx, vy, lit16
计算vy 或 lit16并将结果存入vx。
D601 D204 - or-int/lit16 v1, v0, #int 1234 // #04d2
计算v0 或 1234并将结果存入v1。
D7
xor-int/lit16 vx, vy, lit16
计算vy 异或 lit16并将结果存入vx。
D701 D204 - xor-int/lit16 v1, v0, #int 1234 // #04d2
计算v0 异或 1234并将结果存入v1。
D8
add-int/lit8 vx, vy, lit8
计算vy + lit8并将结果存入vx。
D800 0201 - add-int/lit8 v0,v2, #int1
计算v2 + 1并将结果存入v0。
D9
sub-int/lit8 vx, vy, lit8
计算vy - lit8并将结果存入vx。
D900 0201 - sub-int/lit8 v0,v2, #int1
计算v2 - 1并将结果存入v0。
DA
mul-int/lit8 vx, vy, lit8
计算vy * lit8并将结果存入vx。
DA00 0002 - mul-int/lit8 v0,v0, #int2
计算v0 * 2并将结果存入v0。
DB
div-int/lit8 vx, vy, lit8
计算vy / lit8并将结果存入vx。
DB00 0203 - mul-int/lit8 v0,v2, #int3
计算v2 / 3并将结果存入v0。
DC
rem-int/lit8 vx, vy, lit8
计算vy % lit8并将结果存入vx。
DC00 0203 - rem-int/lit8 v0,v2, #int3
计算v2 % 3并将结果存入v0。
DD
and-int/lit8 vx, vy, lit8
计算vy 与 lit8并将结果存入vx。
DD00 0203 - and-int/lit8 v0,v2, #int3
计算v2 与 3并将结果存入v0。
DE
or-int/lit8 vx, vy, lit8
计算vy 或 lit8并将结果存入vx。
DE00 0203 - or-int/lit8 v0, v2, #int 3
计算v2 或 3并将结果存入v0。
DF
xor-int/lit8 vx, vy, lit8
计算vy异或lit8并将结果存入vx。
DF00 0203 | 0008: xor-int/lit8 v0, v2, #int 3
计算v2 异或 3并将结果存入v0。
E0
shl-int/lit8 vx, vy, lit8
左移vy，lit8指定移动的位置，并将结果存入vx。
E001 0001 - shl-int/lit8 v1, v0, #int 1
将v0左移1位，结果存入v1。
E1
shr-int/lit8 vx, vy, lit8
右移vy，lit8指定移动的位置，并将结果存入vx。
E101 0001 - shr-int/lit8 v1, v0, #int 1
将v0右移1位，结果存入v1。
E2
ushr-int/lit8 vx, vy, lit8
无符号右移vy，lit8指定移动的位置，并将结果存入vx。
E201 0001 - ushr-int/lit8 v1, v0, #int 1
将v0无符号右移1位，结果存入v1。
E3
unused_E3
未使用
E4
unused_E4
未使用
E5
unused_E5
未使用
E6
unused_E6
未使用
E7
unused_E7
未使用
E8
unused_E8
未使用
E9
unused_E9
未使用
EA
unused_EA
未使用
EB
unused_EB
未使用
EC
unused_EC
未使用
ED
unused_ED
未使用
EE
execute-inline {参数}, 内联ID
根据内联ID注6执行内联方法。
EE20 0300 0100 - execute-inline {v1, v0}, inline #0003
执行内联方法#3，参数v1,v0，其中参数v1为"this"的实例，v0是方法的参数。
EF
unused_EF
未使用
F0
invoke-direct-empty
用于空方法的占位符，如Object.<init>。这相当于正常执行了nop指令注6。
F010 F608 0000 - invoke-direct-empty {v0}, Ljava/lang/Object;.<init>:()V // method@08f6
替代空方法java/lang/Object;<init>。
F1
unused_F1
未使用
F2
iget-quick vx, vy, 偏移量
获取vy寄存器中实例指向+偏移位置的数据区的值，存入vx注6。
F221 1000 - iget-quick v1, v2, [obj+0010]
获取v2寄存器中的实例指向+10H位置的数据区的值，存入v1。
F3
iget-wide-quick vx, vy, 偏移量
获取vy寄存器中实例指向+偏移位置的数据区的值，存入vx,vx+1注6。
F364 3001 - iget-wide-quick v4, v6, [obj+0130]
获取v6寄存器中的实例指向+130H位置的数据区的值，存入v4,v5。
F4
iget-object-quick vx, vy, 偏移量
获取vy寄存器中实例指向+偏移位置的数据区的对象引用，存入vx注6。
F431 0C00 - iget-object-quick v1, v3, [obj+000c]
获取v3寄存器中的实例指向+0CH位置的数据区的对象引用，存入v1。
F5
iput-quick vx, vy, 偏移量
将vx寄存器中的值存入vy寄存器中的实例指向+偏移位置的数据区注6。
F521 1000 - iput-quick v1, v2, [obj+0010]
将v1寄存器中的值存入v2寄存器中的实例指向+10H位置的数据区。
F6
iput-wide-quick vx, vy, 偏移量
将vx,vx+1寄存器中的值存入vy寄存器中的实例指向+偏移位置的数据区注6。
F652 7001 - iput-wide-quick v2, v5, [obj+0170]
将v2,v3寄存器中的值存入v5寄存器中的实例指向+170H位置的数据区。
F7
iput-object-quick vx, vy, 偏移量
将vx寄存器中的对象引用存入vy寄存器中的实例指向+偏移位置的数据区注6。
F701 4C00 - iput-object-quick v1, v0, [obj+004c]
将v1寄存器中的对象引用存入v0寄存器中的实例指向+4CH位置的数据区。
F8
invoke-virtual-quick {参数}, 虚拟表偏移量
调用虚拟方法，使用目标对象虚拟表注6。
F820 B800 CF00 - invoke-virtual-quick {v15, v12}, vtable #00b8
调用虚拟方法，目标对象的实例指向位于v15寄存器，方法位于虚拟表#B8条目，方法所需的参数位于v12。
F9
invoke-virtual-quick/range {参数范围}, 虚拟表偏移量
调用虚拟方法，使用目标对象虚拟表注6。
F906 1800 0000 - invoke-virtual-quick/range {v0..v5},vtable #0018
调用虚拟方法，目标对象的实例指向位于v0寄存器，方法位于虚拟表#18H条目，方法所需的参数位于v1..v5。
FA
invoke-super-quick {参数}, 虚拟表偏移量
调用父类虚拟方法，使用目标对象的直接父类的虚拟表注6。
FA40 8100 3254 - invoke-super-quick {v2, v3, v4, v5}, vtable #0081
调用父类虚拟方法，目标对象的实例指向位于v2寄存器，方法位于虚拟表#81H条目，方法所需的参数位于v3,v4,v5。
FB
invoke-super-quick/range {参数范围}, 虚拟表偏移量
调用父类虚拟方法，使用目标对象的直接父类的虚拟表注6。
F906 1B00 0000 - invoke-super-quick/range {v0..v5}, vtable #001b
调用父类虚拟方法，目标对象的实例指向位于v0寄存器，方法位于虚拟表#1B条目，方法所需的参数位于v1..v5。
FC
unused_FC
未使用
FD
unused_FD
未使用
FE
unused_FE
未使用
FF
unused_FF
未使用
注1：   Double和long值占用两个寄存器。（例：在vy地址上的值位于vy,vy+1寄存器）
注2：   偏移量可以是正或负，从指令起始字节起计算偏移量。偏移量在（2字节每1偏移量递增/递减）时解释执行。负偏移量用二进制补码格式存储。偏移量当前位置是指令起始字节。
注3：   比较操作，如果第一个操作数大于第二个操作数返回正值；如果两者相等，返回0；如果第一个操作数小于第二个操作数，返回负值。
注4：   正常使用没见到过的，从Android opcode constant list引入。
注5：   调用参数表的编译比较诡异。如果参数的数量大于4并且%4=1，第5（第9或其他%4=1的）个参数将编译在指令字节的下一个字节的4个最低位。奇怪的是，有一种情况不使用这种编译：方法有4个参数但用于编译单一参数，指令字节的下一个字节的4个最低位空置，将会编译为40而不是04。
注6：   这是一个不安全的指令，仅适用于ODEX文件。
smali语法
一.什么是Smali？
Smali，Baksmali分别是指安卓系统里的Java虚拟机（Dalvik）所使用的一种dex格式文件的汇编器，反汇编器。其语法是一种宽松式的Jasmin/dedexer语法，而且它实现了.dex格式所有功能（注解，调试信息，线路信息等）
二.smali的语法
1.原始类型
B---byte
C---char
D---double
F---float
I---int
J---long
S---short
V---void
Z---boolean
[XXX---array
Lxxx/yyy---object
解析下最后两项，数组的表示方式是：
在基本类型前加上前中括号“[”，例如int数组和float数组分别表示为：[I、[F；
对象的表示则以L作为开头，格式LpackageName/objectName;（注意必须有个分号跟在最后），例如String对象在smali中为：Ljava/lang/String;，其中java/lang对应java.lang包，String就是定义在该包中的一个对象。
2.方法的定义
 格式：Func-Name (Para-Type1Para-Type2Para-Type3...)Return-Type
注意：参数和参数间没有任何分隔符，
1.hello()v
　　就是void hello()
2.hello(lll)Z
　　就是boolean hello(int,int,int)
3.hello(Z[l[lLjava/lang/String;J)Ljava/lang/String 
　　就是String hello(boolean,int[],int[],String,long)
3.基本语法
.field private isFlag:z　　定义变量
.method　　方法
.parameter　　方法参数
.prologue　　方法开始
.line 123　　此方法位于第123行
invoke-super　　调用父函数
const/high16  v0, 0x7fo3　　把0x7fo3赋值给v0
invoke-direct　　调用函数
return-void　　函数返回void
.end method　　函数结束
new-instance　　创建实例
iput-object　　对象赋值
iget-object　　调用对象
invoke-static　　调用静态函数
4.条件跳转分支：
"if-eq vA, vB, :cond_**"   如果vA等于vB则跳转到:cond_**
"if-ne vA, vB, :cond_**"   如果vA不等于vB则跳转到:cond_**
"if-lt vA, vB, :cond_**"    如果vA小于vB则跳转到:cond_**
"if-ge vA, vB, :cond_**"   如果vA大于等于vB则跳转到:cond_**
"if-gt vA, vB, :cond_**"   如果vA大于vB则跳转到:cond_**
"if-le vA, vB, :cond_**"    如果vA小于等于vB则跳转到:cond_**
"if-eqz vA, :cond_**"   如果vA等于0则跳转到:cond_**
"if-nez vA, :cond_**"   如果vA不等于0则跳转到:cond_**
"if-ltz vA, :cond_**"    如果vA小于0则跳转到:cond_**
"if-gez vA, :cond_**"   如果vA大于等于0则跳转到:cond_**
"if-gtz vA, :cond_**"   如果vA大于0则跳转到:cond_**
"if-lez vA, :cond_**"    如果vA小于等于0则跳转到:cond_**
三.smali的包中信息
.class public Lcom/aaaaa;
.super Lcom/bbbbb;
.source "ccccc.java"
1.它是com.aaaaa这个package下的类
2.继承自com.bbbbb
3.由ccccc.java编译得到的smali文件
四.smali中的声明
# annotations
　.annotation system Ldalvik/annotation/MemberClasses;
　　value = {Lcom/aaa$qqq;,
　　　　　　Lcom/aaa$www;
　　　　　}
　.end annotation
这个声明是内部类的声明：aaa这个类它有两个成员内部类——qqq和www。
五.寄存器
　　本地寄存器用v开头数字结尾的符号来表示，如v0、v1、v2、...
　　参数寄存器则使用p开头数字结尾的符号来表示，如p0、p1、p2、...
注意：p0不一定是函数中的第一个参数，在非static函数中，p0代指“this”，p1表示函数的第一个参数，p2代表函数中的第二个参数…而在static函数中p0才对应第一个参数（因为Java的static方法中没有this方法。      
简单分析：
const/4 v0, 0x1
iput-boolean v0, p0, Lcom/aaa;->IsRegistered:Z
上面两句smali代码，首先使用本地v0寄存器，并将0x1存到v0中，然后第二句用iput-boolean这个指令把v0中的值存放到com.aaa.IsRegistered这个成员变量中。
相当于：this.IsRegistered=v0;
六.smali中的成员变量
成员变量格式是：
　　 .field public/private [static] [final] varName:<类型>。
对于不同的成员变量也有不同的指令。
一般来说，
　　获取的指令有：iget、sget、iget-boolean、sget-boolean、iget-object、sget-object等。
　　操作的指令有：iput、sput、iput-boolean、sput-boolean、iput-object、sput-object等。
没有“-object”后缀的表示操作的成员变量对象是基本数据类型，带“-object”表示操作的成员变量是对象类型，特别地，boolean类型则使用带“-boolean”的指令操作。
七.Smali成员变量指令简析
1.sget-object v0, Lcom/aaa;->ID:Ljava/lang/String;
sget-object就是用来获取变量值并保存到紧接着的参数的寄存器中
本例中，它获取ID这个String类型的成员变量并放到v0这个寄存器中。
注意：前面需要该变量所属的类的类型，后面需要加一个冒号和该成员变量的类型，中间是“->”表示所属关系。
2.iget-object v0, p0, Lcom/aaa;->view:Lcom/aaa/view;
可以看到iget-object指令比sget-object多了一个参数，就是该变量所在类的实例，在这里就是p0即“this”。
3.sput指令的使用
const/4 v3, 0x0
sput-object v3, Lcom/aaa;->timer:Lcom/aaa/timer;
　　相当于：this.timer=null
4.iput指令的使用
.local v0, args:Landroid/os/Message;
const/4 v1, 0x12
iput v1, v0, Landroid/os/Message;->what:I
　　相当于：args.what = 18;
八.函数调用
smali中的函数和成员变量也分为两种，分别为 direct 和 virtual
两者的区别
　　1.direct method 是指private函数
　　2.virtual method 是指 protected和 public 函数
　　3.所以在调用函数时，有invoke-direct，invoke-virtual，另外还有invoke-static、invoke-super以及invoke-interface等几种不同的指令。
　　4.当然其实还有invoke-XXX/range 指令的，这是参数多于4个的时候调用的指令，比较少见
1.invoke-static
用于调用static函数
　　例如：
　　　　invoke-static {}, Lcom/aaa;->CheckSignature()Z
　　注意：invoke-static后面有一对大括号“{}”，其实是调用该方法的实例+参数列表，由于这个方法既不需参数也是static的，所以{}内为空
　　例如：
　　　　const-string v0, "NDKLIB"
　　　　invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
　　这个是调用static void System.loadLibrary(String)来加载NDK编译的so库用的方法
2.invoke-super
调用父类方法用的指令，一般用于调用onCreate、onDestroy等方法。
3.invoke-direct
调用private函数：
　　例如：
　　　　invoke-direct {p0}, Landroid/app/TabActivity;-><init>()V
　　　　这里init()就是定义在TabActivity中的一个private函数
4.invoke-virtual
用于调用protected或public函数，同样注意修改smali时不要错用invoke-direct或invoke-static
5.invoke-xxxxx/range
当方法的参数多于5个时（含5个），不能直接使用以上的指令，而是在后面加上“/range”，range表示范围，使用方法也有所不同
九.函数的返回结果
在Java代码中调用函数和返回函数结果可以用一条语句完成，而在Smali里则需要分开来完成，在使用上述指令后，如果调用的函数返回非void，那么还需要用到move-result（返回基本数据类型）和move-result-object（返回对象）指令：
　　const-string v0, "Eric"
　　invoke-static {v0}, Lcmb/pbi;->t(Ljava/lang/String;)Ljava/lang/String;
　　move-result-object v2
　　 v2保存的就是调用t方法返回的String字符串


<bits/stdc++.h>
// C++ includes used for precompiling -*- C++ -*-
// Copyright (C) 2003-2014 Free Software Foundation, Inc. This file is part of the GNU ISO C++ Library.  This library is free// software; you can redistribute it and/or modify it under the// terms of the GNU General Public License as published by the// Free Software Foundation; either version 3, or (at your option)// any later version.
// This library is distributed in the hope that it will be useful,// but WITHOUT ANY WARRANTY; without even the implied warranty of// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the// GNU General Public License for more details.
// Under Section 7 of GPL version 3, you are granted additional// permissions described in the GCC Runtime Library Exception, version// 3.1, as published by the Free Software Foundation.
// You should have received a copy of the GNU General Public License and// a copy of the GCC Runtime Library Exception along with this program;// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see// <http://www.gnu.org/licenses/>.
/** @file stdc++.h *  This is an implementation file for a precompiled header. */
// 17.4.1.2 Headers
// C
#ifndef _GLIBCXX_NO_ASSERT
#include <cassert>
#endif
#include <cctype>
#include <cerrno>
#include <cfloat>
#include <ciso646>
#include <climits>
#include <clocale>
#include <cmath>
#include <csetjmp>
#include <csignal>
#include <cstdarg>
#include <cstddef>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>

#if __cplusplus >= 201103L
#include <ccomplex>
#include <cfenv>
#include <cinttypes>
#include <cstdalign>
#include <cstdbool>
#include <cstdint>
#include <ctgmath>
#include <cwchar>
#include <cwctype>
#endif

// C++
#include <algorithm>
#include <bitset>
#include <complex>
#include <deque>
#include <exception>
#include <fstream>
#include <functional>
#include <iomanip>
#include <ios>
#include <iosfwd>
#include <iostream>
#include <istream>
#include <iterator>
#include <limits>
#include <list>
#include <locale>
#include <map>
#include <memory>
#include <new>
#include <numeric>
#include <ostream>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <stdexcept>
#include <streambuf>
#include <string>
#include <typeinfo>
#include <utility>
#include <valarray>
#include <vector>

#if __cplusplus >= 201103L
#include <array>
#include <atomic>
#include <chrono>
#include <condition_variable>
#include <forward_list>
#include <future>
#include <initializer_list>
#include <mutex>
#include <random>
#include <ratio>
#include <regex>
#include <scoped_allocator>
#include <system_error>
#include <thread>
#include <tuple>
#include <typeindex>
#include <type_traits>
#include <unordered_map>
#include <unordered_set>
#endif


1.小红书，密码为xhsdev，选择sqlcipher3直接解密
2.微信的imei，现在可以通过files/KeyInfo.bin获取了，需要解密文件，算法为RC4，密钥为_wEcHAT_

常用网站
https://www.iopq.net/forum.php?mod=forumdisplay&fid=79&filter=author&orderby=dateline
https://www.iopq.net/search.php?mod=forum&searchid=563&orderby=dateline&ascdesc=desc&searchsubmit=yes&kw=//霸道の縂裁帖子
http://www.rexuexia.com/forum.php?mod=forumdisplay&fid=2&filter=author&orderby=dateline
https://www.cangbaowan.vip/forum-54-1.html
https://www.0du.net/forum.php?mod=forumdisplay&fid=2&filter=author&orderby=dateline
https://forum.ragezone.com/
https://www.iyio.net/search/label/%E5%85%8D%E8%B4%B9%E8%8A%82%E7%82%B9
https://clashbk.github.io/
https://bbs.pcbeta.com/
https://www.wenxiaobai.com/chat
https://askmany.cn/chat/
https://chat.deepseek.com/a/chat
https://chat.qwen.ai/
https://leetcode.cn/problemset/algorithms
https://pc.woozooo.com/mydisk.php
https://huggingface.co/models?sort=trending&search=gguf
https://modelscope.cn/models?name=gguf&page=1
https://truthful-busby-322.notion.site/NathMath-LLM-18e45165050a80408586c3f2bf93ce68
https://www.chiphell.com/forum.php?mod=forumdisplay&fid=26&filter=author&orderby=dateline
https://bbs.nga.cn/thread.php?fid=498&page=2&order_by=postdatedesc
https://www.cnbeta.com.tw/
https://www.v2ex.com/mission/daily
https://bbs.kanxue.com/new-digest-1.htm
https://bbs.kanxue.com/forum-161-1.htm?orderby=desc&digest=1
https://www.github-zh.com/top
https://www.github.com/topics/ #2d-graphics canvas infinite-canvas canvas2d rougelike rougelike-game 2d-game 2d-game-engine 2d-graphics-library graphics-engine pixel-art sprites  graphics opengl cross-platform  game-development lua lua-script lua-engine javascript game-engine zero-dependency animation platform-game game-engine skeletal skeletal-animation assists spine spritekit skeleton skeleton-animation chromium miniblink49 blink gecko web-browser browser simd pure-c annotation automation automatic automator automated uiautomator accessibility accessibility-service accessibility-automation  assistant hook  virtualapp pets shizuku obfuscator tasker canvas frida zygisk magisk ksu apatch kernelsu roguelike dungeon caves generator generation tiled
https://www.jitpack.io/
https://developer.aliyun.com/mvn/search
https://repo.maven.apache.org/maven2/
https://segmentfault.com/
https://yizezy.cn/
https://www.xjyxi.com/forum.php
https://src.cool/forum.php
https://jiaobenwang.com/
http://bbs.523play.com/
https://fm.jzyu.com/ymzq?down_price=0
https://www.gamecbg.com/forum.php?mod=forumdisplay&fid=36&filter=author&orderby=dateline
https://search.bilibili.com/all?keyword=frida&from_source=video_tag#bilibili Tag搜索